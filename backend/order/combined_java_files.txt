File: ./build/generated/sources/annotationProcessor/java/main/com/zzimcong/order/application/mapper/OrderMapperImpl.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderAddressResponse;
import com.zzimcong.order.application.dto.OrderItemResponse;
import com.zzimcong.order.application.dto.OrderResponse;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderAddress;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.entity.PaymentType;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-23T11:25:28+0900",
    comments = "version: 1.5.3.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.8.jar, environment: Java 22.0.1 (Eclipse Adoptium)"
)
@Component
public class OrderMapperImpl implements OrderMapper {

    @Autowired
    private OrderItemMapper orderItemMapper;

    @Override
    public OrderResponse orderToOrderResponse(Order order) {
        if ( order == null ) {
            return null;
        }

        List<OrderItemResponse> items = null;
        Long id = null;
        Long userId = null;
        BigDecimal orderAmount = null;
        BigDecimal paymentAmount = null;
        OrderStatus status = null;
        boolean deleted = false;
        OrderAddressResponse orderAddress = null;

        items = orderItemListToOrderItemResponseList( order.getOrderItems() );
        id = order.getId();
        userId = order.getUserId();
        orderAmount = order.getOrderAmount();
        paymentAmount = order.getPaymentAmount();
        status = order.getStatus();
        deleted = order.isDeleted();
        orderAddress = orderAddressToOrderAddressResponse( order.getOrderAddress() );

        PaymentType payment = null;
        String reason = null;

        OrderResponse orderResponse = new OrderResponse( id, userId, orderAmount, paymentAmount, payment, status, deleted, reason, orderAddress, items );

        return orderResponse;
    }

    protected List<OrderItemResponse> orderItemListToOrderItemResponseList(List<OrderItem> list) {
        if ( list == null ) {
            return null;
        }

        List<OrderItemResponse> list1 = new ArrayList<OrderItemResponse>( list.size() );
        for ( OrderItem orderItem : list ) {
            list1.add( orderItemMapper.orderItemToOrderItemResponse( orderItem ) );
        }

        return list1;
    }

    protected OrderAddressResponse orderAddressToOrderAddressResponse(OrderAddress orderAddress) {
        if ( orderAddress == null ) {
            return null;
        }

        String name = null;
        String streetAddress = null;
        String addressDetail = null;
        String zipcode = null;
        String phone = null;
        String message = null;

        name = orderAddress.getName();
        streetAddress = orderAddress.getStreetAddress();
        addressDetail = orderAddress.getAddressDetail();
        zipcode = orderAddress.getZipcode();
        phone = orderAddress.getPhone();
        message = orderAddress.getMessage();

        OrderAddressResponse orderAddressResponse = new OrderAddressResponse( name, streetAddress, addressDetail, zipcode, phone, message );

        return orderAddressResponse;
    }
}


--------


File: ./build/generated/sources/annotationProcessor/java/main/com/zzimcong/order/application/mapper/OrderRequestMapperImpl.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderAddressRequest;
import com.zzimcong.order.application.dto.OrderCreationRequest;
import com.zzimcong.order.application.dto.OrderItemRequest;
import com.zzimcong.order.application.dto.OrderPreparationRequest;
import com.zzimcong.order.application.dto.PaymentDetailsRequest;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderAddress;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.entity.PaymentDetails;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-23T11:25:28+0900",
    comments = "version: 1.5.3.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.8.jar, environment: Java 22.0.1 (Eclipse Adoptium)"
)
@Component
public class OrderRequestMapperImpl implements OrderRequestMapper {

    @Override
    public Order orderPreperationRequestToOrder(OrderPreparationRequest orderPreparationRequest) {
        if ( orderPreparationRequest == null ) {
            return null;
        }

        Order order = new Order();

        order.setOrderItems( orderItemRequestListToOrderItemList( orderPreparationRequest.items() ) );
        order.setOrderAmount( orderPreparationRequest.orderAmount() );
        order.setPaymentAmount( orderPreparationRequest.paymentAmount() );

        order.setStatus( OrderStatus.TEMP );
        order.setDeleted( false );

        linkOrderItems( order );

        return order;
    }

    @Override
    public OrderItem orderItemRequestToOrderItem(OrderItemRequest orderItemRequest) {
        if ( orderItemRequest == null ) {
            return null;
        }

        OrderItem orderItem = new OrderItem();

        orderItem.setProductId( orderItemRequest.productId() );
        orderItem.setPrice( orderItemRequest.price() );
        orderItem.setQuantity( orderItemRequest.quantity() );

        return orderItem;
    }

    @Override
    public void updateOrderFromRequest(OrderCreationRequest orderCreationRequest, Order order) {
        if ( orderCreationRequest == null ) {
            return;
        }

        if ( orderCreationRequest.orderAddressRequest() != null ) {
            order.setOrderAddress( orderAddressRequestToOrderAddress( orderCreationRequest.orderAddressRequest() ) );
        }
        if ( orderCreationRequest.paymentDetailsRequest() != null ) {
            order.setPaymentDetails( paymentDetailsRequestToPaymentDetails( orderCreationRequest.paymentDetailsRequest() ) );
        }

        linkOrderItems( order );
        logMappingResult( orderCreationRequest, order );
    }

    @Override
    public OrderAddress orderAddressRequestToOrderAddress(OrderAddressRequest orderAddressRequest) {
        if ( orderAddressRequest == null ) {
            return null;
        }

        OrderAddress orderAddress = new OrderAddress();

        orderAddress.setName( orderAddressRequest.name() );
        orderAddress.setStreetAddress( orderAddressRequest.streetAddress() );
        orderAddress.setAddressDetail( orderAddressRequest.addressDetail() );
        orderAddress.setZipcode( orderAddressRequest.zipcode() );
        orderAddress.setPhone( orderAddressRequest.phone() );
        orderAddress.setMessage( orderAddressRequest.message() );

        return orderAddress;
    }

    @Override
    public PaymentDetails paymentDetailsRequestToPaymentDetails(PaymentDetailsRequest paymentDetailsRequest) {
        if ( paymentDetailsRequest == null ) {
            return null;
        }

        PaymentDetails paymentDetails = new PaymentDetails();

        paymentDetails.setPaymentMethod( paymentDetailsRequest.paymentMethod() );
        paymentDetails.setCardNumber( paymentDetailsRequest.cardNumber() );
        paymentDetails.setCardHolderName( paymentDetailsRequest.cardHolderName() );
        paymentDetails.setExpirationDate( paymentDetailsRequest.expirationDate() );
        paymentDetails.setCvv( paymentDetailsRequest.cvv() );

        return paymentDetails;
    }

    protected List<OrderItem> orderItemRequestListToOrderItemList(List<OrderItemRequest> list) {
        if ( list == null ) {
            return null;
        }

        List<OrderItem> list1 = new ArrayList<OrderItem>( list.size() );
        for ( OrderItemRequest orderItemRequest : list ) {
            list1.add( orderItemRequestToOrderItem( orderItemRequest ) );
        }

        return list1;
    }
}


--------


File: ./build/generated/sources/annotationProcessor/java/main/com/zzimcong/order/application/mapper/OrderItemMapperImpl.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderItemResponse;
import com.zzimcong.order.domain.entity.OrderItem;
import java.math.BigDecimal;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-23T11:25:28+0900",
    comments = "version: 1.5.3.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.8.jar, environment: Java 22.0.1 (Eclipse Adoptium)"
)
@Component
public class OrderItemMapperImpl implements OrderItemMapper {

    @Override
    public OrderItemResponse orderItemToOrderItemResponse(OrderItem orderItem) {
        if ( orderItem == null ) {
            return null;
        }

        Long id = null;
        Long productId = null;
        BigDecimal price = null;
        Integer quantity = null;

        id = orderItem.getId();
        productId = orderItem.getProductId();
        price = orderItem.getPrice();
        quantity = orderItem.getQuantity();

        OrderItemResponse orderItemResponse = new OrderItemResponse( id, productId, price, quantity );

        return orderItemResponse;
    }

    @Override
    public OrderItem orderItemResponseToOrderItem(OrderItemResponse orderItemResponse) {
        if ( orderItemResponse == null ) {
            return null;
        }

        OrderItem orderItem = new OrderItem();

        orderItem.setId( orderItemResponse.id() );
        orderItem.setProductId( orderItemResponse.productId() );
        orderItem.setPrice( orderItemResponse.price() );
        orderItem.setQuantity( orderItemResponse.quantity() );

        return orderItem;
    }

    @Override
    public void updateOrderItemFromResponse(OrderItemResponse orderItemResponse, OrderItem orderItem) {
        if ( orderItemResponse == null ) {
            return;
        }

        if ( orderItemResponse.id() != null ) {
            orderItem.setId( orderItemResponse.id() );
        }
        if ( orderItemResponse.productId() != null ) {
            orderItem.setProductId( orderItemResponse.productId() );
        }
        if ( orderItemResponse.price() != null ) {
            orderItem.setPrice( orderItemResponse.price() );
        }
        if ( orderItemResponse.quantity() != null ) {
            orderItem.setQuantity( orderItemResponse.quantity() );
        }
    }
}


--------


File: ./src/test/java/com/zzimcong/order/OrderApplicationTests.java
--------
package com.zzimcong.order;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class OrderApplicationTests {

    @Test
    void contextLoads() {
    }

}


--------


File: ./src/main/java/com/zzimcong/order/config/WebMvcConfig.java
--------
//package com.zzimcong.order.config;
//
//import org.springframework.context.annotation.Configuration;
//import org.springframework.web.method.support.HandlerMethodArgumentResolver;
//import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
//
//import java.util.List;
//
//@Configuration
//public class WebMvcConfig implements WebMvcConfigurer {
//
//    private final UserInfoArgumentResolver userInfoArgumentResolver;
//
//    public WebMvcConfig(UserInfoArgumentResolver userInfoArgumentResolver) {
//        this.userInfoArgumentResolver = userInfoArgumentResolver;
//    }
//
//    @Override
//    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
//        resolvers.add(userInfoArgumentResolver);
//    }
//}

--------


File: ./src/main/java/com/zzimcong/order/config/SecurityConfig.java
--------
package com.zzimcong.order.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Slf4j(topic = "security")
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        log.info("Configuring security filter chain");
        http
                .csrf(csrf -> {
                    csrf.disable();
                    log.info("CSRF is disabled");
                })
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/v1/orders/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().permitAll()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                );

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

--------


File: ./src/main/java/com/zzimcong/order/config/KafkaConfig.java
--------
package com.zzimcong.order.config;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.support.serializer.JsonSerializer;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Bean
    public <T> ProducerFactory<String, T> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public <T> KafkaTemplate<String, T> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}

--------


File: ./src/main/java/com/zzimcong/order/config/SwaggerConfig.java
--------
package com.zzimcong.order.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("찜콩 API")
                        .version("1.0")
                        .description("선착순 구매 기능이 있는 이커머스 서비스 API 문서"));
    }
}

--------


File: ./src/main/java/com/zzimcong/order/config/UserInfoArgumentResolver.java
--------
//package com.zzimcong.order.config;
//
//import com.fasterxml.jackson.databind.ObjectMapper;
//import com.zzimcong.order.common.UserInfo;
//import jakarta.servlet.http.HttpServletRequest;
//import org.springframework.core.MethodParameter;
//import org.springframework.stereotype.Component;
//import org.springframework.web.bind.support.WebDataBinderFactory;
//import org.springframework.web.context.request.NativeWebRequest;
//import org.springframework.web.method.support.HandlerMethodArgumentResolver;
//import org.springframework.web.method.support.ModelAndViewContainer;
//
//import java.util.Base64;
//
//@Component
//public class UserInfoArgumentResolver implements HandlerMethodArgumentResolver {
//
//    private final ObjectMapper objectMapper;
//
//    public UserInfoArgumentResolver(ObjectMapper objectMapper) {
//        this.objectMapper = objectMapper;
//    }
//
//    @Override
//    public boolean supportsParameter(MethodParameter parameter) {
//        return parameter.getParameterType().equals(UserInfo.class);
//    }
//
//    @Override
//    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
//                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
//        HttpServletRequest request = (HttpServletRequest) webRequest.getNativeRequest();
//        String userInfoHeader = request.getHeader("X-User-Info");
//
//        if (userInfoHeader != null) {
//            String decodedUserInfo = new String(Base64.getDecoder().decode(userInfoHeader));
//            return objectMapper.readValue(decodedUserInfo, UserInfo.class);
//        }
//
//        return null;
//    }
//}

--------


File: ./src/main/java/com/zzimcong/order/config/JpaConfig.java
--------
package com.zzimcong.order.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
@EnableJpaAuditing
public class JpaConfig {
}

--------


File: ./src/main/java/com/zzimcong/order/config/CorsConfig.java
--------
package com.zzimcong.order.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CorsConfig {

    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("http://localhost:3000"); // React 앱의 주소
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        source.registerCorsConfiguration("/api/**", config);
        return new CorsFilter(source);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/OrderApplication.java
--------
package com.zzimcong.order;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.statemachine.config.EnableStateMachine;

@SpringBootApplication
@EnableFeignClients
@EnableStateMachine
@EnableScheduling
public class OrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }
}


--------


File: ./src/main/java/com/zzimcong/order/common/util/RedisUtil.java
--------
package com.zzimcong.order.common.util;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Service
@RequiredArgsConstructor
public class RedisUtil {
    private final StringRedisTemplate redisTemplate;//Redis에 접근하기 위한 Spring의 Redis 템플릿 클래스

    public String getData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 가져오는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        return valueOperations.get(key);
    }

    public void setData(String key, String value) {//지정된 키(key)에 값을 저장하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        valueOperations.set(key, value);
    }

    public void setDataExpire(String key, String value, long duration) {//지정된 키(key)에 값을 저장하고, 지정된 시간(duration) 후에 데이터가 만료되도록 설정하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        Duration expireDuration = Duration.ofSeconds(duration);
        valueOperations.set(key, value, expireDuration);
    }

    public void deleteData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 삭제하는 메서드
        redisTemplate.delete(key);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/common/exception/ErrorCode.java
--------
package com.zzimcong.order.common.exception;

import lombok.Getter;

@Getter
public enum ErrorCode {
    // BadRequestException (400)
    INVALID_INPUT("잘못된 입력입니다."),
    INVALID_ORDER_STATUS("유효하지 않은 주문 상태입니다."),
    MISSING_REQUEST_BODY("요청 바디가 없습니다."),
    PAYMENT_FAILED("결제에 실패했습니다."),

    // UnauthorizedException (401)

    // ForbiddenException (403)
    ACCESS_DENIED("접근이 거부되었습니다."),

    // NotFoundException (404)
    RESOURCE_NOT_FOUND("요청한 리소스를 찾을 수 없습니다."),
    TEMP_ORDER_NOT_FOUND("임시 주문을 찾을 수 없습니다."),
    ORDER_NOT_FOUND("주문을 찾을 수 없습니다."),

    // MethodNotAllowedException (405)
    METHOD_NOT_ALLOWED("허용되지 않은 HTTP 메서드입니다."),

    // ConflictException (409)
    INSUFFICIENT_STOCK("상품의 재고가 부족합니다."),
    CANNOT_CANCEL_ORDER("주문을 취소할 수 없습니다."),

    // InternalServerErrorException (500)
    ORDER_UPDATE_FAILED("주문 정보 업데이트 중 오류가 발생했습니다."),
    PAYMENT_RESULT_PROCESSING_FAILED("결제 결과 처리 중 오류가 발생했습니다."),
    PAYMENT_REQUEST_FAILED("결제 요청 전송 중 오류가 발생했습니다."),
    RESERVE_INVENTORY_FAILED("재고 예약 중 오류가 발생했습니다."),
    RESOURCE_LOAD_FAILED("내부 리소스 로딩에 실패했습니다."),
    INTERNAL_SERVER_ERROR("서버 내부 오류가 발생했습니다."),
    UNKNOWN_ERROR("알 수 없는 오류가 발생했습니다.");

    private final String message;

    ErrorCode(String message) {
        this.message = message;
    }
}

--------


File: ./src/main/java/com/zzimcong/order/common/exception/ForbiddenException.java
--------
package com.zzimcong.order.common.exception;

public class ForbiddenException extends BaseException {
    public ForbiddenException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ForbiddenException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/common/exception/UnauthorizedException.java
--------
package com.zzimcong.order.common.exception;

public class UnauthorizedException extends BaseException {
    public UnauthorizedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public UnauthorizedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/common/exception/ConflictException.java
--------
package com.zzimcong.order.common.exception;

public class ConflictException extends BaseException {
    public ConflictException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ConflictException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/common/exception/MethodNotAllowedException.java
--------
package com.zzimcong.order.common.exception;

public class MethodNotAllowedException extends BaseException {
    public MethodNotAllowedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public MethodNotAllowedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/common/exception/InternalServerErrorException.java
--------
package com.zzimcong.order.common.exception;

public class InternalServerErrorException extends BaseException {
    public InternalServerErrorException(ErrorCode errorCode) {
        super(errorCode);
    }

    public InternalServerErrorException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}


--------


File: ./src/main/java/com/zzimcong/order/common/exception/GlobalExceptionHandler.java
--------
package com.zzimcong.order.common.exception;

import com.zzimcong.order.api.response.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j(topic = "GLOBAL_EXCEPTION_HANDLER")
@ControllerAdvice
public class GlobalExceptionHandler {
    // BadRequestException (400)
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorResponse> httpMessageNotReadableException(HttpServletRequest request) {
        BadRequestException ex = new BadRequestException(ErrorCode.MISSING_REQUEST_BODY);
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    // UnauthorizedException (401)
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(UnauthorizedException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.UNAUTHORIZED, request.getRequestURI());
    }

    // ForbiddenException (403)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbiddenException(ForbiddenException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.FORBIDDEN, request.getRequestURI());
    }

    // NotFoundException (404)
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.NOT_FOUND, request.getRequestURI());
    }

    // MethodNotAllowedException (405)
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowedException(HttpServletRequest request) {
        MethodNotAllowedException ex = new MethodNotAllowedException(ErrorCode.METHOD_NOT_ALLOWED);
        return createErrorResponse(ex, HttpStatus.METHOD_NOT_ALLOWED, request.getRequestURI());
    }

    // ConflictException (409)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(ConflictException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.CONFLICT, request.getRequestURI());
    }

    // InternalServerErrorException (500)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllException(Exception ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
    }

    // Create ErrorResponse
    private ResponseEntity<ErrorResponse> createErrorResponse(Exception ex, HttpStatus status, String path) {
        logException(ex, status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.INTERNAL_SERVER_ERROR);
        ErrorResponse errorResponse = ErrorResponse.of(status, baseException, path);
        return new ResponseEntity<>(errorResponse, status);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        // 스택 트레이스를 분석하여 예외 발생 위치 추출
        StackTraceElement[] stackTraceElements = ex.getStackTrace();
        String errorLocation = "Unknown";
        if (stackTraceElements.length > 0) {
            StackTraceElement element = stackTraceElements[0];
            errorLocation = String.format("%s.%s (Line: %d)",
                    element.getClassName(),
                    element.getMethodName(),
                    element.getLineNumber());
        }
        log.error(
                "Exception occurred:: {}, Path: {}",
                errorLocation,
                path
        );
        log.error("Error Code: {}, HTTP Status: {}, Message: {}",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage());
    }
}


--------


File: ./src/main/java/com/zzimcong/order/common/exception/BadRequestException.java
--------
package com.zzimcong.order.common.exception;

public class BadRequestException extends BaseException {
    public BadRequestException(ErrorCode errorCode) {
        super(errorCode);
    }

    public BadRequestException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/common/exception/InventoryException.java
--------
package com.zzimcong.order.common.exception;

public class InventoryException extends BaseException {
    public InventoryException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}


--------


File: ./src/main/java/com/zzimcong/order/common/exception/BaseException.java
--------
package com.zzimcong.order.common.exception;

public class BaseException extends RuntimeException {
    private final ErrorCode errorCode;
    private final String message;

    public BaseException(ErrorCode errorCode) {
        this(errorCode, errorCode.getMessage());
    }

    public BaseException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.message = message;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    @Override
    public String getMessage() {
        return message;
    }
}

--------


File: ./src/main/java/com/zzimcong/order/common/exception/NotFoundException.java
--------
package com.zzimcong.order.common.exception;

public class NotFoundException extends BaseException {
    public NotFoundException(ErrorCode errorCode) {
        super(errorCode);
    }

    public NotFoundException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/api/response/ApiResponse.java
--------
package com.zzimcong.order.api.response;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }
}


--------


File: ./src/main/java/com/zzimcong/order/api/response/ErrorResponse.java
--------
package com.zzimcong.order.api.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.zzimcong.order.common.exception.BaseException;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {
    private int status;
    private String message;
    private String errorCode;
    private LocalDateTime timestamp;
    private String path;

    public static ErrorResponse of(HttpStatus status, BaseException ex, String path) {
        ErrorResponse response = new ErrorResponse();
        response.setStatus(status.value());
        response.setMessage(ex.getMessage());
        response.setErrorCode(ex.getErrorCode().name());
        response.setTimestamp(LocalDateTime.now());
        response.setPath(path);
        return response;
    }
}

--------


File: ./src/main/java/com/zzimcong/order/api/controller/OrderController.java
--------
package com.zzimcong.order.api.controller;

import com.zzimcong.order.application.dto.OrderCreationRequest;
import com.zzimcong.order.application.dto.OrderPreparationRequest;
import com.zzimcong.order.application.dto.OrderPreparationResponse;
import com.zzimcong.order.application.dto.OrderResponse;
import com.zzimcong.order.application.saga.OrderSaga;
import com.zzimcong.order.application.service.OrderService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j(topic = "order-service")
@RestController
@RequestMapping("/api/v1/orders")
public class OrderController {
    private final OrderService orderService;
    private final OrderSaga orderSaga;

    @Autowired
    public OrderController(OrderService orderService, OrderSaga orderSaga) {
        this.orderService = orderService;
        this.orderSaga = orderSaga;
    }

    // 주문창 이동
    @PostMapping("/prepare")
    public ResponseEntity<OrderPreparationResponse> prepareOrder(@RequestHeader("X-Auth-User-ID") Long userId,
                                                                 @RequestBody OrderPreparationRequest request) {
        OrderPreparationResponse response = orderSaga.prepareOrder(userId, request);
        return ResponseEntity.ok(response);
    }

    // 사용자 정보 입력 완료, 결제 호출
    @PostMapping("/create/{uuid}")
    public ResponseEntity<Void> createOrder(@RequestHeader("X-Auth-User-ID") Long userId,
                                            @PathVariable String uuid,
                                            @RequestBody OrderCreationRequest request) {
        log.info("Confirming order ID: {} for user ID: {}", uuid, userId);
        orderSaga.createOrder(userId, uuid, request);
        return ResponseEntity.accepted().build();
    }

    @PostMapping("/{orderId}/cancel")
    public ResponseEntity<Void> cancelOrder(@RequestHeader("X-Auth-User-ID") Long userId,
                                            @PathVariable Long orderId) {
        orderService.cancelOrderByOrderId(orderId);
        return ResponseEntity.accepted().build();
    }

    @PostMapping("/{orderId}/refund")
    public ResponseEntity<Void> requestRefund(@PathVariable Long orderId) {
        orderService.requestRefund(orderId);
        return ResponseEntity.accepted().build();
    }

    @GetMapping("/{orderId}")
    public ResponseEntity<OrderResponse> getOrder(@RequestHeader("X-Auth-User-ID") Long userId,
                                                  @PathVariable Long orderId) {
        OrderResponse orderResponse = orderService.getOrderResponse(orderId);
        return ResponseEntity.ok(orderResponse);
    }

    @GetMapping
    public ResponseEntity<Page<OrderResponse>> getOrderList(@RequestParam(defaultValue = "0") int page,
                                                            @RequestParam(defaultValue = "10") int size) {
        PageRequest pageRequest = PageRequest.of(page, size);
        Page<OrderResponse> responsePages = orderService.getOrderList(pageRequest);
        return ResponseEntity.ok(responsePages);
    }

    @GetMapping("/user")
    public ResponseEntity<Page<OrderResponse>> getUserOrders(@RequestHeader("X-Auth-User-ID") Long userId,
                                                             @RequestParam(defaultValue = "0") int page,
                                                             @RequestParam(defaultValue = "10") int size) {
        PageRequest pageRequest = PageRequest.of(page, size);
        Page<OrderResponse> orderPage = orderService.getUserOrders(userId, pageRequest);
        return ResponseEntity.ok(orderPage);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/api/client/ProductServiceClient.java
--------
package com.zzimcong.order.api.client;

import com.zzimcong.order.application.dto.ReleaseInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "product-service")
public interface ProductServiceClient {
    @PostMapping("/api/v1/products/{productId}/reserve")
    ReserveInventoryResponse reserveInventory(@PathVariable("productId") Long productId,
                                              @RequestBody ReserveInventoryRequest request);

    @PostMapping("/api/v1/products/{productId}/release")
    void releaseInventory(@PathVariable("productId") Long productId,
                          @RequestBody ReleaseInventoryRequest request);
}

--------


File: ./src/main/java/com/zzimcong/order/api/client/UserServiceClient.java
--------
package com.zzimcong.order.api.client;

import org.springframework.cloud.openfeign.FeignClient;

@FeignClient(name = "user-service")  // URL 제거, 서비스 이름만 사용
public interface UserServiceClient {
//    @GetMapping("/users/{userId}")
//    UserDto getUserById(@PathVariable("userId") Long userId);
}

--------


File: ./src/main/java/com/zzimcong/order/aspect/OrderAuthorizationAspect.java
--------
//package com.zzimcong.order.aspect;
//
//import com.zzimcong.order.application.service.OrderService;
//import com.zzimcong.order.common.exception.ErrorCode;
//import com.zzimcong.order.common.exception.ForbiddenException;
//import jakarta.servlet.http.HttpServletRequest;
//import org.aspectj.lang.JoinPoint;
//import org.aspectj.lang.annotation.Aspect;
//import org.aspectj.lang.annotation.Before;
//import org.springframework.stereotype.Component;
//import org.springframework.web.context.request.RequestContextHolder;
//import org.springframework.web.context.request.ServletRequestAttributes;
//
//@Aspect
//@Component
//public class OrderAuthorizationAspect {
//
//    private final OrderService orderService;
//
//    public OrderAuthorizationAspect(OrderService orderService) {
//        this.orderService = orderService;
//    }
//
//    @Before("execution(* com.zzimcong.order.api.controller.OrderFulfillmentController.*(.., Long, ..))")
//    public void validateUserAuthorization(JoinPoint joinPoint) {
//        // HTTP 요청에서 사용자 ID 추출
//        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();
//        String userId = request.getHeader("X-Auth-User-ID");
//
//        // orderId 파라미터 찾기
//        Long orderId = null;
//        Object[] args = joinPoint.getArgs();
//        for (Object arg : args) {
//            if (arg instanceof Long) {
//                orderId = (Long) arg;
//                break;
//            }
//        }
//
//        if (orderId == null) {
//            throw new IllegalArgumentException("주문 ID를 찾을 수 없습니다.");
//        }
//
//        if (userId == null) {
//            throw new ForbiddenException(ErrorCode.ACCESS_DENIED, "사용자 인증 정보가 없습니다.");
//        }
//
//        if (!orderService.isOrderOwnedByUser(orderId, Long.parseLong(userId))) {
//            throw new ForbiddenException(ErrorCode.ACCESS_DENIED, "주문 접근 권한이 없습니다.");
//        }
//    }
//}

--------


File: ./src/main/java/com/zzimcong/order/aspect/LoggingAspect.java
--------
package com.zzimcong.order.aspect;

import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Slf4j
@Aspect
@Component
public class LoggingAspect {

    @Around("execution(* com.zzimcong.order.api.controller.*.*(..))")
    public Object logAroundMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();
        String userId = request.getHeader("X-Auth-User-ID");

        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();

        // 메서드 실행 전 로깅
        log.info("User ID: {}, Method execution start: {}.{}",
                userId != null ? userId : "Unknown", className, methodName);

        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long executionTime = System.currentTimeMillis() - start;

        // 메서드 실행 후 로깅
        log.info("User ID: {}, Method execution end: {}.{}, Execution time: {}ms",
                userId != null ? userId : "Unknown", className, methodName, executionTime);

        return result;
    }
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderStatusUpdateRequest.java
--------
package com.zzimcong.order.application.dto;

public record OrderStatusUpdateRequest(
        String status
) {
}


--------


File: ./src/main/java/com/zzimcong/order/application/dto/PaymentDetailsRequest.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.order.domain.entity.PaymentType;

public record PaymentDetailsRequest(
        PaymentType paymentMethod,
        String cardNumber,
        String cardHolderName,
        String expirationDate,
        String cvv
) {
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/ReleaseInventoryRequest.java
--------
package com.zzimcong.order.application.dto;

public record ReleaseInventoryRequest(
        int quantity
) {
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderPreparationRequest.java
--------
package com.zzimcong.order.application.dto;

import java.math.BigDecimal;
import java.util.List;

public record OrderPreparationRequest(
        BigDecimal orderAmount,
        BigDecimal paymentAmount,
        List<OrderItemRequest> items
) {
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderItemResponse.java
--------
package com.zzimcong.order.application.dto;

import java.math.BigDecimal;

public record OrderItemResponse(
        Long id,
        Long productId,
        BigDecimal price,
        Integer quantity
) {
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderPreparationResponse.java
--------
package com.zzimcong.order.application.dto;

public record OrderPreparationResponse(
        String orderId,
        OrderPreparationStatus status
) {
}


--------


File: ./src/main/java/com/zzimcong/order/application/dto/CartItem.java
--------
package com.zzimcong.order.application.dto;

public record CartItem(
        Long productId,
        Integer price,
        Integer quantity
) {
}


--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderResponse.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.entity.PaymentType;

import java.math.BigDecimal;
import java.util.List;

public record OrderResponse(
        Long id,
        Long userId,
        BigDecimal orderAmount,
        BigDecimal paymentAmount,
        PaymentType payment,
        OrderStatus status,
        boolean deleted,
        String reason,
        OrderAddressResponse orderAddress,
        List<OrderItemResponse> items
) {
}


--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderCancellationRequest.java
--------
package com.zzimcong.order.application.dto;

public record OrderCancellationRequest(
        String cancellationReason
) {
}



--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderPreparationStatus.java
--------
package com.zzimcong.order.application.dto;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum OrderPreparationStatus {
    SUCCESS("주문 성공"),
    INVENTORY_SHORTAGE("재고 부족"),
    FAILED("주문 실패");


    private final String message;
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/PaymentResponse.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class PaymentResponse implements KafkaMessage {
    private Long userId;
    private Long orderId;
    private String uuid;
    private boolean success;
    private String status;

    public PaymentResponse(Long userId, String uuid, boolean success) {
        this.userId = userId;
        this.uuid = uuid;
        this.success = success;
        this.status = success ? "PAID" : "FAILED";
    }

    public PaymentResponse(Long userId, Long orderId, boolean success, String status) {
        this.userId = userId;
        this.orderId = orderId;
        this.success = success;
        this.status = status;
    }
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderListResponse.java
--------
package com.zzimcong.order.application.dto;

import java.util.List;

public record OrderListResponse(
        List<OrderResponse> orders,
        int totalPages,
        long totalElements
) {
}


--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderAddressRequest.java
--------
package com.zzimcong.order.application.dto;

public record OrderAddressRequest(
        String name,
        String streetAddress,
        String addressDetail,
        String zipcode,
        String phone,
        String message) {
}


--------


File: ./src/main/java/com/zzimcong/order/application/dto/ReserveInventoryResponse.java
--------
package com.zzimcong.order.application.dto;

public record ReserveInventoryResponse(
        boolean success,
        String message
) {
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/RefundResponse.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class RefundResponse implements KafkaMessage {
    private Long userId;
    private Long orderId;
    private boolean success;
    private OrderStatus status;

    public RefundResponse(Long userId, Long orderId, boolean success, OrderStatus status) {
        this.userId = userId;
        this.orderId = orderId;
        this.success = success;
        this.status = status;
    }
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderItemRequest.java
--------
package com.zzimcong.order.application.dto;

import java.math.BigDecimal;

public record OrderItemRequest(
        Long productId,
        BigDecimal price,
        Integer quantity
) {
}


--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderAddressResponse.java
--------
package com.zzimcong.order.application.dto;

public record OrderAddressResponse(
        String name,
        String streetAddress,
        String addressDetail,
        String zipcode,
        String phone,
        String message) {
}


--------


File: ./src/main/java/com/zzimcong/order/application/dto/RefundRequest.java
--------
package com.zzimcong.order.application.dto;

public record RefundRequest(
        String refundReason
) {
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderCreationRequest.java
--------
package com.zzimcong.order.application.dto;

public record OrderCreationRequest(
        OrderAddressRequest orderAddressRequest,
        PaymentDetailsRequest paymentDetailsRequest
) {
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/OrderRequest.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.order.domain.entity.PaymentType;

import java.math.BigDecimal;
import java.util.List;

public record OrderRequest(
        BigDecimal orderAmount,
        BigDecimal paymentAmount,
        PaymentType payment,
        String name,
        String addr,
        String addrDetail,
        String zipcode,
        String phone,
        String message,
        List<OrderItemRequest> items
) {
}


--------


File: ./src/main/java/com/zzimcong/order/application/dto/ReserveInventoryRequest.java
--------
package com.zzimcong.order.application.dto;

public record ReserveInventoryRequest(
//        Long productId,
        int quantity
) {
}

--------


File: ./src/main/java/com/zzimcong/order/application/dto/PaymentRequest.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class PaymentRequest implements KafkaMessage {
    private Long userId;
    private String uuid;
    private PaymentDetailsRequest paymentDetails;
    private BigDecimal amount;
}

--------


File: ./src/main/java/com/zzimcong/order/application/mapper/OrderMapper.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderResponse;
import com.zzimcong.order.domain.entity.Order;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring", uses = {OrderItemMapper.class})
public interface OrderMapper {
    @Mapping(target = "items", source = "orderItems")
    OrderResponse orderToOrderResponse(Order order);
}

--------


File: ./src/main/java/com/zzimcong/order/application/mapper/PaymentDetailsMapper.java
--------
//package com.zzimcong.order.application.mapper;
//
//import com.zzimcong.order.application.dto.PaymentDetailsRequest;
//import com.zzimcong.order.domain.entity.PaymentDetails;
//import org.mapstruct.BeanMapping;
//import org.mapstruct.Mapper;
//
//@Mapper(componentModel = "spring", uses = {PaymentDetailsMapper.class})
//public interface PaymentDetailsMapper {
//    @BeanMapping
//    PaymentDetails paymentDetailsRequestToPaymentDetails(PaymentDetailsRequest paymentDetailsRequest);
//}


--------


File: ./src/main/java/com/zzimcong/order/application/mapper/OrderItemMapper.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderItemResponse;
import com.zzimcong.order.domain.entity.OrderItem;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface OrderItemMapper {

    OrderItemResponse orderItemToOrderItemResponse(OrderItem orderItem);

    @InheritInverseConfiguration
    OrderItem orderItemResponseToOrderItem(OrderItemResponse orderItemResponse);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    void updateOrderItemFromResponse(OrderItemResponse orderItemResponse, @MappingTarget OrderItem orderItem);
}

--------


File: ./src/main/java/com/zzimcong/order/application/mapper/OrderRequestMapper.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.*;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderAddress;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.PaymentDetails;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface OrderRequestMapper {

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "userId", ignore = true)
    @Mapping(target = "status", constant = "TEMP")
    @Mapping(target = "deleted", constant = "false")
    @Mapping(target = "orderItems", source = "items")
    Order orderPreperationRequestToOrder(OrderPreparationRequest orderPreparationRequest);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "order", ignore = true)
    OrderItem orderItemRequestToOrderItem(OrderItemRequest orderItemRequest);

    @AfterMapping
    default void linkOrderItems(@MappingTarget Order order) {
        if (order.getOrderItems() != null) {
            order.getOrderItems().forEach(item -> item.setOrder(order));
        }
    }

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(source = "orderAddressRequest", target = "orderAddress")
    @Mapping(source = "paymentDetailsRequest", target = "paymentDetails")
    void updateOrderFromRequest(OrderCreationRequest orderCreationRequest, @MappingTarget Order order);

    @Mapping(target = "id", ignore = true)
    OrderAddress orderAddressRequestToOrderAddress(OrderAddressRequest orderAddressRequest);

    @Mapping(target = "id", ignore = true)
    PaymentDetails paymentDetailsRequestToPaymentDetails(PaymentDetailsRequest paymentDetailsRequest);

    @AfterMapping
    default void logMappingResult(OrderCreationRequest request, @MappingTarget Order order) {
        System.out.println("OrderCreationRequest: " + request);
        System.out.println("Mapped Order: " + order);
        System.out.println("PaymentDetails: " + order.getPaymentDetails());
    }
}

--------


File: ./src/main/java/com/zzimcong/order/application/saga/OrderSaga.java
--------
package com.zzimcong.order.application.saga;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.zzimcong.order.application.dto.*;
import com.zzimcong.order.application.mapper.OrderRequestMapper;
import com.zzimcong.order.application.service.OrderService;
import com.zzimcong.order.application.service.ProductService;
import com.zzimcong.order.common.exception.ErrorCode;
import com.zzimcong.order.common.exception.InternalServerErrorException;
import com.zzimcong.order.common.exception.InventoryException;
import com.zzimcong.order.common.exception.NotFoundException;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.repository.OrderRepository;
import feign.FeignException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataAccessException;
import org.springframework.data.redis.core.RedisOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.SessionCallback;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;
import java.util.ConcurrentModificationException;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.ExecutionException;

@Service
@Slf4j(topic = "order-saga")
@RequiredArgsConstructor
public class OrderSaga {
    private final OrderService orderService;
    private final ProductService productService;
    private final OrderRequestMapper orderRequestMapper;
    private final ObjectMapper objectMapper;
    private final RedisTemplate<String, String> redisTemplate;
    private final OrderRepository orderRepository;
    private final KafkaTemplate<String, PaymentRequest> kafkaTemplate;


    /***************************************************************************
     주문 준비 프로세스(재고 예약, 임시 주문 생성, 임시 주문 정보 Redis에 저장)
     ***************************************************************************/

    // 주문 준비
    public OrderPreparationResponse prepareOrder(Long userId, OrderPreparationRequest request) {
        boolean allReserved = reserveInventory(request);
        if (allReserved) {
            Order tempOrder = createTempOrder(userId, request);
            String orderUuid = saveTempOrderToRedis(userId, tempOrder);
            return new OrderPreparationResponse(orderUuid, OrderPreparationStatus.SUCCESS);
        } else {
            return new OrderPreparationResponse(null, OrderPreparationStatus.INVENTORY_SHORTAGE);
        }
    }

    // 재고 예약
    @Retryable(value = {InventoryException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
    public boolean reserveInventory(OrderPreparationRequest request) {
        log.info("재고 예약 시작");
        return request.items().stream()
                .allMatch(item -> {
                    try {
                        return productService.reserveInventory(item.productId(), item.quantity());
                    } catch (FeignException e) {
                        log.error("재고 예약 실패. 상품 ID: {}, 수량: {}", item.productId(), item.quantity(), e);
                        throw new InventoryException(ErrorCode.RESERVE_INVENTORY_FAILED, e.getMessage());
                    }
                });
    }

    // 임시 주문 생성
    public Order createTempOrder(Long userId, OrderPreparationRequest request) {
        log.info("Creating temporary order for user ID: {}", userId);

        Order tempOrder = orderRequestMapper.orderPreperationRequestToOrder(request);
        tempOrder.setUserId(userId);

        return tempOrder;
    }

    // 임시 주문 정보 Redis에 저장
    private String saveTempOrderToRedis(Long userId, Order tempOrder) {
        String orderUuid = generateOrderUuid();
        String key = "temp_order:" + userId + ":" + orderUuid;

        try {
            String orderJson = objectMapper.writeValueAsString(tempOrder);
            Boolean setSuccess = redisTemplate.opsForValue()
                    .setIfAbsent(key, orderJson, Duration.ofMinutes(30));

            if (Boolean.FALSE.equals(setSuccess)) {
                throw new ConcurrentModificationException("동시에 같은 키로 주문 생성 시도");
            }

            log.info("Temporary order created with ID: {}", orderUuid);
        } catch (JsonProcessingException e) {
            log.error("Error creating temporary order", e);
            throw new RuntimeException("임시 주문 생성 중 오류가 발생했습니다.");
        }

        return orderUuid;
    }

    private String generateOrderUuid() {
        return UUID.randomUUID().toString();
    }

    /***************************************************************************
     주문 생성 프로세스(주문 정보 업데이트, 결제 요청)
     ***************************************************************************/

    // 주문 생성
    public void createOrder(Long userId, String uuid, OrderCreationRequest request) {
        log.info("주문 생성 시작. 사용자 ID: {}, UUID: {}", userId, uuid);
        Order order = updateOrderDetails(userId, uuid, request);
        processPayment(userId, uuid, request.paymentDetailsRequest(), order);
    }

    // 주문 정보 업데이트
    public Order updateOrderDetails(Long userId, String uuid, OrderCreationRequest orderCreationRequest) {
        String key = "temp_order:" + userId + ":" + uuid;

        return (Order) redisTemplate.execute(new SessionCallback<Object>() {
            @Override
            public Object execute(RedisOperations operations) throws DataAccessException {
                operations.watch(key);
                String orderJson = (String) operations.opsForValue().get(key);

                if (orderJson == null) {
                    throw new NotFoundException(ErrorCode.TEMP_ORDER_NOT_FOUND, "uuid : " + uuid);
                }

                try {
                    operations.multi();

                    Order order = objectMapper.readValue(orderJson, Order.class);
                    orderRequestMapper.updateOrderFromRequest(orderCreationRequest, order);

                    order.setStatus(OrderStatus.PAYMENT_REQUESTED);

                    String updatedOrderJson = objectMapper.writeValueAsString(order);
                    operations.opsForValue().set(key, updatedOrderJson);
                    operations.expire(key, Duration.ofMinutes(15));

                    List<Object> txResults = operations.exec();

                    if (txResults == null || txResults.isEmpty()) {
                        throw new ConcurrentModificationException("주문 정보가 동시에 수정되었습니다. 다시 시도해주세요.");
                    }

                    log.info("Order details updated successfully for order: {}", uuid);
                    return order;

                } catch (JsonProcessingException e) {
                    operations.discard();
                    log.error("Error updating temporary order", e);
                    throw new InternalServerErrorException(ErrorCode.ORDER_UPDATE_FAILED);
                }
            }
        });
    }

    // 결제 요청
    public void processPayment(Long userId, String uuid, PaymentDetailsRequest request, Order order) {
        log.info("결제 처리 시작. 사용자 ID: {}, UUID: {}", userId, uuid);
        PaymentRequest paymentRequest = new PaymentRequest(userId, uuid, request, order.getPaymentAmount());
        try {
            kafkaTemplate.send("payment-requests", paymentRequest).get();
            log.info("결제 요청 전송 완료. UUID: {}", uuid);
        } catch (InterruptedException | ExecutionException e) {
            log.error("결제 요청 전송 실패. UUID: {}", uuid, e);
            throw new InternalServerErrorException(ErrorCode.PAYMENT_REQUEST_FAILED, e.getMessage());
        }
    }

    // 결제 결과 처리
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    @KafkaListener(topics = "payment-results")
    public void handlePaymentResult(PaymentResponse result) {
        log.info("결제 결과 수신. UUID: {}, 사용자 ID: {}, 성공 여부: {}", result.getUuid(), result.getUserId(), result.isSuccess());

        String key = "temp_order:" + result.getUserId() + ":" + result.getUuid();
        String orderJson = redisTemplate.opsForValue().get(key);

        if (orderJson == null) {
            log.warn("존재하지 않는 주문에 대한 결제 결과 수신: {}", result.getUuid());
            return;
        }

        try {
            Order order = objectMapper.readValue(orderJson, Order.class);
            log.debug("Redis에서 불러온 주문 정보: {}", order);

            if (result.isSuccess()) {
                order.setStatus(OrderStatus.ORDER_COMPLETED);
                for (OrderItem item : order.getOrderItems()) {
                    item.setOrder(order);
                    log.debug("주문 아이템 설정: {}", item);
                }
                log.info(order.toString());
                Order savedOrder = orderRepository.save(order);
                log.info("주문 저장 완료. 주문 ID: {}", savedOrder.getId());
            } else {
                log.warn("결제 실패. 보상 트랜잭션 시작");
                compensatePaymentFailure(order);
            }

            boolean deleted = redisTemplate.delete(key);
            log.info("Redis에서 임시 주문 정보 삭제 {}: {}", (deleted ? "성공" : "실패"), key);

        } catch (JsonProcessingException e) {
            log.error("결제 결과 처리 중 JSON 파싱 오류 발생", e);
            throw new InternalServerErrorException(ErrorCode.PAYMENT_RESULT_PROCESSING_FAILED);
        } catch (Exception e) {
            log.error("주문 처리 중 예기치 못한 오류 발생", e);
            throw new InternalServerErrorException(ErrorCode.UNKNOWN_ERROR);
        }
    }

    // 보상 트랜잭션: 결제 실패 시 재고 회수
    private void compensatePaymentFailure(Order order) {
        log.info("결제 실패에 대한 보상 트랜잭션 시작. 주문 ID: {}", order.getId());
        for (OrderItem item : order.getOrderItems()) {
            try {
                productService.releaseInventory(item.getProductId(), item.getQuantity());
                log.info("재고 해제 성공: 상품 ID: {}, 수량: {}", item.getProductId(), item.getQuantity());
            } catch (FeignException e) {
                log.error("재고 해제 실패: 상품 ID: {}, 수량: {}, 오류: {}",
                        item.getProductId(), item.getQuantity(), e.getMessage());
                // 추가적인 오류 처리 로직
                // 예: 관리자에게 알림, 수동 처리를 위한 큐에 추가 등
            }
        }
        log.info("보상 트랜잭션 완료");
    }
}

--------


File: ./src/main/java/com/zzimcong/order/application/service/ShippingService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.repository.OrderRepository;
import com.zzimcong.zzimconginventorycore.common.event.ShippingEvent;
import com.zzimcong.zzimconginventorycore.common.event.ShippingEventType;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

@Slf4j(topic = "shipping-service")
@Service
@EnableScheduling
@AllArgsConstructor
public class ShippingService {
    private final OrderRepository orderRepository;
    private final KafkaTemplate<String, ShippingEvent> kafkaTemplate;
//    private final JavaMailSender javaMailSender;

    // 주문 완료 -> 배송 준비로 상태 변경
    // 1시간 전에 주문 완료된 주문을 찾아 배송 준비로 변경
    @Scheduled(fixedDelay = 60000)
    @Transactional
    public void updateOrdersToPreparing() {
        LocalDateTime oneHourAgo = LocalDateTime.now().minusHours(1);
        List<Order> orders = orderRepository.findByStatusAndCreatedAtBefore(OrderStatus.ORDER_COMPLETED, oneHourAgo);

        for (Order order : orders) {
//            order.setStatus(OrderStatus.PREPARING_FOR_SHIPMENT);
//            orderRepository.save(order);
            kafkaTemplate.send("shipping-events", new ShippingEvent(order.getId(), ShippingEventType.PREPARING));
        }
    }

    // 배송 준비 -> 배송 중으로 상태 변경
    // 매일 오후 11시 실행
    @Scheduled(cron = "0 0 23 * * ?")
    @Transactional
    public void updateOrdersToShipping() {
        List<Order> orders = orderRepository.findByStatus(OrderStatus.PREPARING_FOR_SHIPMENT);

        for (Order order : orders) {
//            order.setStatus(OrderStatus.SHIPPING);
//            orderRepository.save(order);
            kafkaTemplate.send("shipping-events", new ShippingEvent(order.getId(), ShippingEventType.SHIPPING));
        }
    }

    // 배송 중 -> 배송 완료로 상태 변경
    // 매일 오전 11시 실행
    @Scheduled(cron = "0 0 11 * * ?")
    @Transactional
    public void updateOrdersToDelivered() {
        List<Order> orders = orderRepository.findByStatus(OrderStatus.SHIPPING);

        for (Order order : orders) {
//            order.setStatus(OrderStatus.DELIVERED);
//            orderRepository.save(order);
            kafkaTemplate.send("shipping-events", new ShippingEvent(order.getId(), ShippingEventType.DELIVERED));
//            sendMail(order);
        }
    }

    // 반품 요청 -> 환불 완료로 상태 변경
    @Scheduled(fixedDelay = 86400000)
    public void autoRefundOrders() {
        log.info("Starting auto-refund of orders");
        LocalDateTime refundDate = LocalDateTime.now().minusDays(1);
        List<Order> ordersToRefund =
                orderRepository.findByStatusAndDeliveredAtBefore(OrderStatus.REFUND_REQUESTED, refundDate);
        log.info("Found {} orders to auto-refund", ordersToRefund.size());

        for (Order order : ordersToRefund) {
//            order.setStatus(OrderStatus.REFUND_COMPLETED);
//            orderRepository.save(order);
            kafkaTemplate.send("shipping-events", new ShippingEvent(order.getId(), ShippingEventType.PICKUP_COMPLETED));
        }
    }

    // 메일 전송
//    private void sendMail(Order order) {
//        SimpleMailMessage message = new SimpleMailMessage();
//        message.setTo(order.getUserId().getEmail());
//        message.setSubject("배송이 완료되었습니다.");
//        message.setText("배송이 완료되었습니다. 주문 번호: " + order.getId());
//        javaMailSender.send(message);
//    }
}

--------


File: ./src/main/java/com/zzimcong/order/application/service/ProductService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.api.client.ProductServiceClient;
import com.zzimcong.order.application.dto.ReleaseInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryResponse;
import feign.FeignException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

@Service
public class ProductService {
    private final ProductServiceClient productServiceClient;

    @Autowired
    public ProductService(ProductServiceClient productServiceClient) {
        this.productServiceClient = productServiceClient;
    }

    public boolean reserveInventory(Long productId, int quantity) {
        try {
            ReserveInventoryResponse response = productServiceClient.reserveInventory(
                    productId, new ReserveInventoryRequest(quantity));
            return response.success();
        } catch (FeignException e) {
            if (e.status() == HttpStatus.BAD_REQUEST.value()) {
                // 재고 부족 등의 이유로 예약 실패
                return false;
            }
            throw new RuntimeException("재고 예약 중 오류 발생", e);
        }
    }

    public void releaseInventory(Long productId, int quantity) {
        productServiceClient.releaseInventory(productId, new ReleaseInventoryRequest(quantity));
    }
}

--------


File: ./src/main/java/com/zzimcong/order/application/service/OrderService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.application.dto.OrderResponse;
import com.zzimcong.order.application.dto.RefundResponse;
import com.zzimcong.order.application.mapper.OrderMapper;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.repository.OrderRepository;
import com.zzimcong.zzimconginventorycore.common.event.ShippingEvent;
import com.zzimcong.zzimconginventorycore.common.event.ShippingEventType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

@Slf4j(topic = "order-service")
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderRepository orderRepository;
    private final OrderMapper orderMapper;
    private final KafkaTemplate<String, Order> kafkaTemplate;

    /**********************************************
     배송 준비 중, 배송 중, 배송완료, 회수완료 처리
     **********************************************/
    @Transactional
    @KafkaListener(topics = "shipping-events")
    public void handleShippingEvent(ShippingEvent event) {
        log.info("Received shipping event for order ID: {}, Event type: {}", event.getOrderId(), event.getEventType());
        Order order = getOrder(event.getOrderId());

        if (event.getEventType() == ShippingEventType.PICKUP_COMPLETED) {
            // PICKUP_COMPLETED 이벤트 별도 처리
            refundOrder(order);
            log.info("Processed PICKUP_COMPLETED event for Order ID: {}", order.getId());
        } else {
            // 다른 이벤트들에 대한 상태 업데이트
            updateOrderStatusForShippingEvent(order, event.getEventType());
        }
    }

    // 배송 이벤트에 따른 주문 상태 업데이트
    private void updateOrderStatusForShippingEvent(Order order, ShippingEventType eventType) {
        OrderStatus newStatus = switch (eventType) {
            case PREPARING -> OrderStatus.PREPARING_FOR_SHIPMENT;
            case SHIPPING -> OrderStatus.SHIPPING;
            case DELIVERED -> OrderStatus.DELIVERED;
            default -> throw new IllegalArgumentException("예상치 못한 배송 이벤트 타입: " + eventType);
        };
        updateOrderStatus(order, newStatus);
        log.info("Updated order status: {}, Order ID: {}", newStatus, order.getId());
    }

    // 주문 상태 업데이트
    @Transactional
    public void updateOrderStatus(Order order, OrderStatus status) {
        log.info("Updating order status. Order ID: {}, New status: {}", order.getId(), status);
        order.setStatus(status);
        orderRepository.save(order);
    }


    /**********************************************
     취소, 환불 처리
     **********************************************/
    // 주문 취소 요청
    @Transactional
    public void cancelOrderByOrderId(Long orderId) {
        log.info("Cancelling order with ID: {}", orderId);
        Order order = getOrder(orderId);
        tryCancelOrder(order);
        kafkaTemplate.send("refund-request", order);
    }

    // 주문 취소 가능 여부 확인
    @Transactional
    public void tryCancelOrder(Order order) {
        log.info("Setting order status to CANCELED. Order ID: {}", order.getId());
        if (order.getStatus() == OrderStatus.PREPARING_FOR_SHIPMENT) {
            throw new RuntimeException("배송 준비 중인 주문은 취소할 수 없습니다: " + order.getId());
        } else if (order.getStatus() == OrderStatus.SHIPPING) {
            throw new RuntimeException("배송 중인 주문은 취소할 수 없습니다: " + order.getId());
        } else if (order.getStatus() == OrderStatus.DELIVERED) {
            throw new RuntimeException("배송 완료된 주문은 취소할 수 없습니다: " + order.getId());
        } else if (order.getStatus() != OrderStatus.ORDER_COMPLETED) {
            throw new RuntimeException("취소할 수 없는 주문 상태입니다: " + order.getId());
        }
    }

    // 환불 요청 수신
    @Transactional
    public void requestRefund(Long orderId) {
        log.info("Requesting refund for order ID: {}", orderId);
        Order order = getOrder(orderId);
        if (order.getStatus() != OrderStatus.DELIVERED) {
            throw new RuntimeException("배송 완료된 주문만 환불할 수 있습니다: " + order.getId());
        } else {
            updateOrderStatus(order, OrderStatus.REFUND_REQUESTED);
        }
    }

    // 환불 완료 처리 요청
    @Transactional
    public void refundOrder(Order order) {
        log.info("Processing refund for order ID: {}", order.getId());
        kafkaTemplate.send("refund-request", order);
    }

    // 환불 결과 처리
    @Transactional
    @KafkaListener(topics = "refund-results")
    public void handleRefundResult(RefundResponse response) {
        log.info("Received refund result: {}", response);
        if (response.isSuccess()) {
            if (response.getStatus() == OrderStatus.REFUND_REQUESTED) {
                updateOrderStatus(getOrder(response.getOrderId()), OrderStatus.REFUND_COMPLETED);
            } else {
                updateOrderStatus(getOrder(response.getOrderId()), OrderStatus.CANCELED);
            }
        }
    }


    /**********************************************
     주문 조회
     **********************************************/
    public Order getOrder(Long orderId) {
        log.debug("Fetching order with ID: {}", orderId);
        return orderRepository.findById(orderId)
                .orElseThrow(() -> {
                    log.error("Order not found with ID: {}", orderId);
                    return new RuntimeException("주문을 찾을 수 없습니다: " + orderId);
                });
    }

    public OrderResponse getOrderResponse(Long orderId) {
        log.debug("Fetching order response for order ID: {}", orderId);
        Order order = getOrder(orderId);
        return orderMapper.orderToOrderResponse(order);
    }

    public Page<OrderResponse> getOrderList(Pageable pageable) {
        log.debug("Fetching order list. Page: {}, Size: {}", pageable.getPageNumber(), pageable.getPageSize());
        Page<Order> orderPage = orderRepository.findAll(pageable);
        return orderPage.map(orderMapper::orderToOrderResponse);
    }

    public Page<OrderResponse> getUserOrders(Long userId, Pageable pageable) {
        log.debug("Fetching orders for user ID: {}. Page: {}, Size: {}", userId, pageable.getPageNumber(), pageable.getPageSize());
        Page<Order> ordersWithItems = orderRepository.findByUserId(userId, pageable);
        return ordersWithItems.map(orderMapper::orderToOrderResponse);
    }


    /**********************************************
     주문 자동 확정
     **********************************************/
    // 매일 배송완료 주문 자동 확정
    @Scheduled(fixedDelay = 86400000)
    public void autoConfirmOrders() {
        log.info("Starting auto-confirmation of orders");
        List<Order> ordersToConfirm = getOrdersToConfirm();
        log.info("Found {} orders to auto-confirm", ordersToConfirm.size());

        for (Order order : ordersToConfirm) {
            try {
                confirmOrder(order);
            } catch (Exception e) {
                log.error("Error during auto-confirmation of order ID: {}", order.getId(), e);
            }
        }
    }

    public List<Order> getOrdersToConfirm() {
        LocalDateTime confirmationDate = LocalDateTime.now().minusDays(1);
        log.debug("Fetching orders to confirm before: {}", confirmationDate);
        return orderRepository.findByStatusAndDeliveredAtBefore(OrderStatus.DELIVERED, confirmationDate);
    }

    @Transactional
    public void confirmOrder(Order order) {
        log.info("Confirming order with ID: {}", order.getId());
        updateOrderStatus(order, OrderStatus.ORDER_CONFIRMED);
    }


    /**********************************************
     주문 소유자 확인
     **********************************************/
    public boolean isOrderOwnedByUser(Long orderId, Long userId) {
        log.debug("Checking if order ID: {} is owned by user ID: {}", orderId, userId);
        Order order = getOrder(orderId);
        return order.getUserId().equals(userId);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/application/service/PaymentService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.application.dto.PaymentRequest;
import com.zzimcong.order.application.dto.PaymentResponse;
import com.zzimcong.order.application.dto.RefundResponse;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

import java.util.Random;

@Slf4j(topic = "payment-service")
@Service
public class PaymentService {
    private final KafkaTemplate<String, KafkaMessage> kafkaTemplate;
    private final Random random = new Random();

    @Autowired
    public PaymentService(KafkaTemplate<String, KafkaMessage> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    @KafkaListener(topics = "payment-requests")
    public void processPayment(PaymentRequest request) {
        // 90% 확률로 결제 성공, 10% 확률로 결제 실패 시뮬레이션
        boolean isSuccess = random.nextInt(100) < 90;

        PaymentResponse result = new PaymentResponse(request.getUserId(), request.getUuid(), isSuccess);

        if (isSuccess) {
            log.info("결제 성공: 주문 ID {}", request.getUuid());
        } else {
            log.info("결제 실패: 주문 ID {}", request.getUuid());
        }

        // 결제 결과를 Kafka로 전송
        kafkaTemplate.send("payment-results", result);
    }

    public void refundPayment(Order order) {
        // 실제 환불 처리 대신 로그만 남김
        log.info("환불 처리 완료: 주문 ID {}, 금액 {}", order.getId(), order.getPaymentAmount());

        // 환불 결과를 Kafka로 전송
        RefundResponse refundResult = new RefundResponse(order.getUserId(), order.getId(), true, order.getStatus());
        kafkaTemplate.send("refund-results", refundResult);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/infrastructure/statemachine/OrderStateMachineFactory.java
--------
package com.zzimcong.order.infrastructure.statemachine;

import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.zzimconginventorycore.common.event.OrderEventType;
import org.springframework.statemachine.StateMachine;
import org.springframework.statemachine.config.StateMachineFactory;
import org.springframework.statemachine.support.DefaultStateMachineContext;
import org.springframework.stereotype.Component;

@Component
public class OrderStateMachineFactory {
    private final StateMachineFactory<OrderStatus, OrderEventType> stateMachineFactory;

    public OrderStateMachineFactory(StateMachineFactory<OrderStatus, OrderEventType> stateMachineFactory) {
        this.stateMachineFactory = stateMachineFactory;
    }

    public StateMachine<OrderStatus, OrderEventType> create(Order order) {
        StateMachine<OrderStatus, OrderEventType> sm = stateMachineFactory.getStateMachine(order.getId().toString());
        sm.stop();
        sm.getStateMachineAccessor().doWithAllRegions(sma -> {
            sma.resetStateMachine(new DefaultStateMachineContext<>(order.getStatus(), null, null, null));
        });
        sm.start();
        return sm;
    }
}

--------


File: ./src/main/java/com/zzimcong/order/infrastructure/statemachine/OrderStateMachineConfig.java
--------
package com.zzimcong.order.infrastructure.statemachine;

import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.zzimconginventorycore.common.event.OrderEventType;
import org.springframework.context.annotation.Configuration;
import org.springframework.statemachine.config.EnableStateMachineFactory;
import org.springframework.statemachine.config.StateMachineConfigurerAdapter;
import org.springframework.statemachine.config.builders.StateMachineStateConfigurer;
import org.springframework.statemachine.config.builders.StateMachineTransitionConfigurer;

import java.util.EnumSet;

@Configuration
@EnableStateMachineFactory
public class OrderStateMachineConfig extends StateMachineConfigurerAdapter<OrderStatus, OrderEventType> {

    @Override
    public void configure(StateMachineStateConfigurer<OrderStatus, OrderEventType> states) throws Exception {
        states
                .withStates()
                .initial(OrderStatus.TEMP)
                .states(EnumSet.allOf(OrderStatus.class));
    }

    @Override
    public void configure(StateMachineTransitionConfigurer<OrderStatus, OrderEventType> transitions) throws Exception {
        transitions
                .withExternal()
                .source(OrderStatus.TEMP).target(OrderStatus.STOCK_RESERVED)
                .event(OrderEventType.INVENTORY_RESERVED)
                .and()
                .withExternal()
                .source(OrderStatus.STOCK_RESERVED).target(OrderStatus.PAYMENT_PROCESSED)
                .event(OrderEventType.PAYMENT_PROCESSED)
                .and()
                .withExternal()
                .source(OrderStatus.PAYMENT_PROCESSED).target(OrderStatus.ORDER_COMPLETED)
                .event(OrderEventType.ORDER_COMPLETED)
                .and()
                .withExternal()
                .source(OrderStatus.ORDER_COMPLETED).target(OrderStatus.PREPARING_FOR_SHIPMENT)
                .event(OrderEventType.SHIPMENT_PREPARING)
                .and()
                .withExternal()
                .source(OrderStatus.PREPARING_FOR_SHIPMENT).target(OrderStatus.SHIPPING)
                .event(OrderEventType.SHIPMENT_STARTED)
                .and()
                .withExternal()
                .source(OrderStatus.SHIPPING).target(OrderStatus.DELIVERED)
                .event(OrderEventType.SHIPMENT_DELIVERED);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/infrastructure/kafka/ShippingProducerListener.java
--------
package com.zzimcong.order.infrastructure.kafka;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.support.ProducerListener;

public class ShippingProducerListener implements ProducerListener<String, Object> {

    private static final Logger logger = LoggerFactory.getLogger(ShippingProducerListener.class);

    @Override
    public void onSuccess(ProducerRecord<String, Object> producerRecord, RecordMetadata recordMetadata) {
        logger.info("Message sent successfully to topic {} partition {} offset {}",
                recordMetadata.topic(), recordMetadata.partition(), recordMetadata.offset());
    }

    @Override
    public void onError(ProducerRecord<String, Object> producerRecord, RecordMetadata recordMetadata, Exception exception) {
        logger.error("Error sending message to topic {} partition {}",
                producerRecord.topic(), producerRecord.partition(), exception);
    }
}

--------


File: ./src/main/java/com/zzimcong/order/infrastructure/kafka/KafkaProducer.java
--------
package com.zzimcong.order.infrastructure.kafka;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.stereotype.Component;

import java.util.concurrent.CompletableFuture;

@Component
public class KafkaProducer<T> {
    private static final Logger logger = LoggerFactory.getLogger(KafkaProducer.class);

    private final KafkaTemplate<String, T> kafkaTemplate;

    public KafkaProducer(KafkaTemplate<String, T> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    public void send(String topic, T payload) {
        logger.info("Sending Kafka message to topic: {} with payload: {}", topic, payload);
        CompletableFuture<SendResult<String, T>> future = kafkaTemplate.send(topic, payload);

        future.whenComplete((result, ex) -> {
            if (ex == null) {
                logger.info("Message sent successfully to topic: {}", topic);
            } else {
                logger.error("Failed to send message to topic: {}", topic, ex);
            }
        });
    }
}

--------


File: ./src/main/java/com/zzimcong/order/infrastructure/kafka/PaymentEvent.java
--------
package com.zzimcong.order.infrastructure.kafka;

import com.zzimcong.order.domain.entity.PaymentType;
import lombok.Data;
import lombok.Setter;

import java.math.BigDecimal;

@Data
@Setter
public class PaymentEvent {
    private Long orderId;
    private BigDecimal amount;
    private PaymentType payment;
    private boolean success;

    public PaymentEvent(Long orderId, BigDecimal amount, PaymentType payment) {
        this.orderId = orderId;
        this.amount = amount;
        this.payment = payment;
        this.success = false;
    }
}

--------


File: ./src/main/java/com/zzimcong/order/domain/repository/OrderRepository.java
--------
package com.zzimcong.order.domain.repository;

import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;

import java.time.LocalDateTime;
import java.util.List;

public interface OrderRepository extends JpaRepository<Order, Long> {
    List<Order> findByStatus(OrderStatus orderStatus);

    List<Order> findByStatusAndDeliveredAtBefore(OrderStatus orderStatus, LocalDateTime confirmationDate);

    List<Order> findByStatusAndCreatedAtBefore(OrderStatus orderStatus, LocalDateTime oneHourAgo);

    @EntityGraph(attributePaths = "orderItems")
    Page<Order> findByUserId(Long userId, Pageable pageable);
}


--------


File: ./src/main/java/com/zzimcong/order/domain/repository/OrderItemRepository.java
--------
package com.zzimcong.order.domain.repository;

import com.zzimcong.order.domain.entity.OrderItem;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface OrderItemRepository extends JpaRepository<OrderItem, Long> {
    List<OrderItem> findByOrderId(Long orderId);
}


--------


File: ./src/main/java/com/zzimcong/order/domain/entity/PaymentType.java
--------
package com.zzimcong.order.domain.entity;

public enum PaymentType {
    KB, KAKAO, NAVER, KEB, IBK, NH
}

--------


File: ./src/main/java/com/zzimcong/order/domain/entity/Order.java
--------
package com.zzimcong.order.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import org.hibernate.annotations.ColumnDefault;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@ToString
@NoArgsConstructor
@Entity
@Table(name = "orders")
public class Order extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "order_id")
    private Long id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "order_address_id")
    private OrderAddress orderAddress;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal orderAmount;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal paymentAmount;

    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "payment_details_id")
    private PaymentDetails paymentDetails;

    @Enumerated(EnumType.STRING)
    @Column(length = 30)
    @ColumnDefault("'ORDER_COMPLETED'")
    private OrderStatus status = OrderStatus.ORDER_COMPLETED;

    @Column(nullable = false)
    private boolean deleted = false;

    @Column(length = 255)
    private String cancellationReason;

    @Column(length = 255)
    private String refundReason;

    private LocalDateTime deliveredAt;

    private LocalDateTime refundRequestedAt;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItem> orderItems = new ArrayList<>();
}

--------


File: ./src/main/java/com/zzimcong/order/domain/entity/OrderItem.java
--------
package com.zzimcong.order.domain.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "order_items") // 복수형 사용
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "order_item_id")
    private Long id;

    @Column(name = "product_id", nullable = false)
    private Long productId;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(nullable = false)
    private Integer quantity;

    @JsonIgnore
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;
}

--------


File: ./src/main/java/com/zzimcong/order/domain/entity/OrderStatus.java
--------
package com.zzimcong.order.domain.entity;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum OrderStatus {
    TEMP("임시 주문"),
    STOCK_RESERVED("재고 확보 완료"),
    PAYMENT_REQUESTED("결제 요청됨"),
    PAYMENT_PROCESSED("결제 완료"),
    SAGA_FAILED("주문 처리 실패"),
    ORDER_COMPLETED("주문 완료"),
    PREPARING_FOR_SHIPMENT("배송 준비 중"),
    SHIPPING("배송 중"),
    DELIVERED("배송 완료"),
    ORDER_CONFIRMED("주문 확정"),
    CANCELED("취소됨"),
    REFUND_REQUESTED("환불 신청됨"),
    REFUND_COMPLETED("환불 완료됨");

    private final String description;
}

--------


File: ./src/main/java/com/zzimcong/order/domain/entity/OrderAddress.java
--------
package com.zzimcong.order.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "order_addresses")
public class OrderAddress extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "order_address_id")
    private Long id;

    @Column(nullable = false, length = 64)
    private String name;

    @Column(nullable = false, length = 255)
    private String streetAddress;

    @Column(nullable = false, length = 255)
    private String addressDetail;

    @Column(nullable = false, length = 10)
    private String zipcode;

    @Column(nullable = false, length = 20)
    private String phone;

    @Column(length = 255)
    private String message;

    @OneToOne(mappedBy = "orderAddress")
    private Order order;
}

--------


File: ./src/main/java/com/zzimcong/order/domain/entity/BaseEntity.java
--------
package com.zzimcong.order.domain.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@Setter
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
public abstract class BaseEntity {

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

}

--------


File: ./src/main/java/com/zzimcong/order/domain/entity/PaymentDetails.java
--------
package com.zzimcong.order.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "payment_details")
public class PaymentDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "payment_details_id")
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(length = 20)
    private PaymentType paymentMethod;

    private String cardNumber;
    private String cardHolderName;
    private String expirationDate;
    private String cvv;

    @OneToOne(mappedBy = "paymentDetails")
    private Order order;
}


--------


