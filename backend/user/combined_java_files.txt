File: ./src/test/java/com/lunartown/user/UserApplicationTests.java
--------
package com.zzimcong.user;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class UserApplicationTests {

    @Test
    void contextLoads() {
    }

}


--------


File: ./src/test/java/com/lunartown/user/EmailSenderTest.java
--------
package com.zzimcong.user;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.mail.MailException;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;

@SpringBootTest
public class EmailSenderTest {

    @Autowired
    private JavaMailSender mailSender;

    @Test
    public void testSendEmail() {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom("zzimcong99@gmail.com");
        message.setTo("recipient@example.com");
        message.setSubject("Test Subject");
        message.setText("Test Body");

        try {
            mailSender.send(message);
            System.out.println("Test email sent successfully");
        } catch (MailException e) {
            System.err.println("Failed to send test email. Error: " + e.getMessage());
            e.printStackTrace();

            if (e.getCause() != null) {
                System.err.println("Root cause: " + e.getCause().getMessage());
                e.getCause().printStackTrace();
            }
        }
    }
}

--------


File: ./src/main/java/com/zzimcong/user/common/util/KeyManagementUtil.java
--------
package com.zzimcong.user.common.util;

import lombok.Getter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

@Component
public class KeyManagementUtil {

    private final Environment environment;
    @Getter
    private String encryptionKey;

    @Autowired
    public KeyManagementUtil(Environment environment) {
        this.environment = environment;
        initEncryptionKey();
    }

    private void initEncryptionKey() {
        // 시스템 환경 변수에서 먼저 확인
        encryptionKey = System.getenv("ENCRYPTION_KEY");

        // 시스템 환경 변수에 없으면 스프링 Environment에서 확인
        if (encryptionKey == null || encryptionKey.isEmpty()) {
            encryptionKey = environment.getProperty("encryption.key");
        }

        // 둘 다 없으면 예외 발생
        if (encryptionKey == null || encryptionKey.isEmpty()) {
            throw new IllegalStateException("ENCRYPTION_KEY가 설정되지 않았습니다.");
        }
    }

}

--------


File: ./src/main/java/com/zzimcong/user/common/util/EmailVerificationToken.java
--------
package com.zzimcong.user.common.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@AllArgsConstructor
public class EmailVerificationToken {
    private String token;
    private String email;
    private LocalDateTime expiryDate;
}

--------


File: ./src/main/java/com/zzimcong/user/common/util/RedisUtil.java
--------
package com.zzimcong.user.common.util;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Service
@RequiredArgsConstructor
public class RedisUtil {
    private final StringRedisTemplate redisTemplate;//Redis에 접근하기 위한 Spring의 Redis 템플릿 클래스

    public String getData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 가져오는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        return valueOperations.get(key);
    }

    public void setData(String key, String value) {//지정된 키(key)에 값을 저장하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        valueOperations.set(key, value);
    }

    public void setDataExpire(String key, String value, long duration) {//지정된 키(key)에 값을 저장하고, 지정된 시간(duration) 후에 데이터가 만료되도록 설정하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        Duration expireDuration = Duration.ofSeconds(duration);
        valueOperations.set(key, value, expireDuration);
    }

    public void deleteData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 삭제하는 메서드
        redisTemplate.delete(key);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/common/util/AESUtil.java
--------
package com.zzimcong.user.common.util;

import com.zzimcong.user.common.exception.BadRequestException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.InternalServerErrorException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Slf4j(topic = "AESUtil")
@Component
public class AESUtil {
    private static final String ALGORITHM = "AES";
    private static final String CIPHER_INSTANCE = "AES/ECB/PKCS5Padding";  // 명시적으로 모드와 패딩 지정

    private final KeyManagementUtil keyManagementUtil;

    @Autowired
    public AESUtil(KeyManagementUtil keyManagementUtil) {
        this.keyManagementUtil = keyManagementUtil;
    }

    public String encrypt(String data) {
        if(data == null) throw new BadRequestException(ErrorCode.INVALID_EMAIL);
        try {
            Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE);
            cipher.init(Cipher.ENCRYPT_MODE, getKeySpec());
            byte[] encryptedData = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(encryptedData);
        } catch (Exception e) {
            log.error("Encryption failed", e);
            throw new InternalServerErrorException(ErrorCode.ENCRYPTION_FAILED);
        }
    }

    public String decrypt(String encryptedData) {
        try {
            Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE);
            cipher.init(Cipher.DECRYPT_MODE, getKeySpec());
            byte[] decryptedData = cipher.doFinal(Base64.getDecoder().decode(encryptedData));
            return new String(decryptedData, StandardCharsets.UTF_8);
        } catch (Exception e) {
            log.error("Decryption failed", e);
            throw new InternalServerErrorException(ErrorCode.DECRYPTION_FAILED);
        }
    }

    private SecretKeySpec getKeySpec() {
        String key = keyManagementUtil.getEncryptionKey();
        byte[] decodedKey = Base64.getDecoder().decode(key);
        return new SecretKeySpec(decodedKey, ALGORITHM);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/common/UserInfo.java
--------
package com.zzimcong.user.common;

import lombok.Data;

@Data
public class UserInfo {
    private Long id;
    private String username;
    private String role;
    // 필요한 다른 필드들...
}

--------


File: ./src/main/java/com/zzimcong/user/common/exception/ErrorCode.java
--------
package com.zzimcong.user.common.exception;

import lombok.Getter;

@Getter
public enum ErrorCode {
    // BadRequestException (400)
    INVALID_INPUT("잘못된 입력입니다."),
    INVALID_EMAIL("잘못된 이메일 형식입니다."),
    INVALID_PASSWORD("잘못된 비밀번호 형식입니다."),
    INVALID_VERIFICATION_CODE("잘못된 인증 코드입니다."),
    EMAIL_VERIFICATION_FAILED("이메일 인증에 실패했습니다."),
    MISSING_REQUEST_BODY("요청 바디가 없습니다."),

    // UnauthorizedException (401)
    INVALID_CREDENTIALS("잘못된 인증 정보입니다."),
    INVALID_TOKEN("유효하지 않은 토큰입니다."),
    EXPIRED_TOKEN("만료된 토큰입니다."),
    TOKEN_NOT_FOUND("토큰을 찾을 수 없습니다."),

    // ForbiddenException (403)
    ACCESS_DENIED("접근 권한이 없습니다."),

    // NotFoundException (404)
    RESOURCE_NOT_FOUND("요청한 리소스를 찾을 수 없습니다."),
    USER_NOT_FOUND("사용자를 찾을 수 없습니다."),

    // MethodNotAllowedException (405)
    METHOD_NOT_ALLOWED("허용되지 않은 HTTP 메서드입니다."),

    // ConflictException (409)
    DUPLICATE_EMAIL("이미 존재하는 이메일입니다."),

    // InternalServerErrorException (500)
    ENCRYPTION_FAILED("사용자 정보 암호화에 실패했습니다."),
    DECRYPTION_FAILED("사용자 정보 복호화에 실패했습니다."),
    RESOURCE_LOAD_FAILED("내부 리소스 로딩에 실패했습니다."),
    EMAIL_SEND_FAILED("이메일 전송에 실패했습니다."),
    INTERNAL_SERVER_ERROR("서버 내부 오류가 발생했습니다."),
    UNKNOWN_ERROR("알 수 없는 오류가 발생했습니다.");

    private final String message;

    ErrorCode(String message) {
        this.message = message;
    }
}

--------


File: ./src/main/java/com/zzimcong/user/common/exception/ForbiddenException.java
--------
package com.zzimcong.user.common.exception;

public class ForbiddenException extends BaseException {
    public ForbiddenException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ForbiddenException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/common/exception/UnauthorizedException.java
--------
package com.zzimcong.user.common.exception;

public class UnauthorizedException extends BaseException {
    public UnauthorizedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public UnauthorizedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/common/exception/ConflictException.java
--------
package com.zzimcong.user.common.exception;

public class ConflictException extends BaseException {
    public ConflictException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ConflictException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/common/exception/MethodNotAllowedException.java
--------
package com.zzimcong.user.common.exception;

public class MethodNotAllowedException extends BaseException {
    public MethodNotAllowedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public MethodNotAllowedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/common/exception/InternalServerErrorException.java
--------
package com.zzimcong.user.common.exception;

public class InternalServerErrorException extends BaseException {
    public InternalServerErrorException(ErrorCode errorCode) {
        super(errorCode);
    }

    public InternalServerErrorException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}


--------


File: ./src/main/java/com/zzimcong/user/common/exception/GlobalExceptionHandler.java
--------
package com.zzimcong.user.common.exception;

import com.zzimcong.user.api.response.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.protocol.HTTP;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j(topic = "GLOBAL_EXCEPTION_HANDLER")
@ControllerAdvice
public class GlobalExceptionHandler {
    // BadRequestException (400)
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorResponse> httpMessageNotReadableException(HttpServletRequest request) {
        BadRequestException ex = new BadRequestException(ErrorCode.MISSING_REQUEST_BODY);
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    // UnauthorizedException (401)
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(UnauthorizedException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.UNAUTHORIZED, request.getRequestURI());
    }

    // ForbiddenException (403)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbiddenException(ForbiddenException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.FORBIDDEN, request.getRequestURI());
    }

    // NotFoundException (404)
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.NOT_FOUND, request.getRequestURI());
    }

    // MethodNotAllowedException (405)
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowedException(HttpServletRequest request) {
        MethodNotAllowedException ex = new MethodNotAllowedException(ErrorCode.METHOD_NOT_ALLOWED);
        return createErrorResponse(ex, HttpStatus.METHOD_NOT_ALLOWED, request.getRequestURI());
    }

    // ConflictException (409)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(ConflictException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.CONFLICT, request.getRequestURI());
    }

    // InternalServerErrorException (500)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllException(Exception ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
    }

    // Create ErrorResponse
    private ResponseEntity<ErrorResponse> createErrorResponse(Exception ex, HttpStatus status, String path) {
        logException(ex, status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.INTERNAL_SERVER_ERROR);
        ErrorResponse errorResponse = ErrorResponse.of(baseException, status, path);
        return new ResponseEntity<>(errorResponse, status);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        // 스택 트레이스를 분석하여 예외 발생 위치 추출
        StackTraceElement[] stackTraceElements = ex.getStackTrace();
        String errorLocation = "Unknown";
        if (stackTraceElements.length > 0) {
            StackTraceElement element = stackTraceElements[0];
            errorLocation = String.format("%s.%s (Line: %d)",
                    element.getClassName(),
                    element.getMethodName(),
                    element.getLineNumber());
        }
        log.error(
                "Exception occurred:: {}, Path: {}",
                errorLocation,
                path
        );
        log.error("Error Code: {}, HTTP Status: {}, Message: {}",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage());
    }
}


--------


File: ./src/main/java/com/zzimcong/user/common/exception/BadRequestException.java
--------
package com.zzimcong.user.common.exception;

public class BadRequestException extends BaseException {
    public BadRequestException(ErrorCode errorCode) {
        super(errorCode);
    }

    public BadRequestException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/common/exception/BaseException.java
--------
package com.zzimcong.user.common.exception;

public class BaseException extends RuntimeException {
    private final ErrorCode errorCode;
    private final String message;

    public BaseException(ErrorCode errorCode) {
        this(errorCode, errorCode.getMessage());
    }

    public BaseException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.message = message;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    @Override
    public String getMessage() {
        return message;
    }
}

--------


File: ./src/main/java/com/zzimcong/user/common/exception/NotFoundException.java
--------
package com.zzimcong.user.common.exception;

public class NotFoundException extends BaseException {
    public NotFoundException(ErrorCode errorCode) {
        super(errorCode);
    }

    public NotFoundException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/UserApplication.java
--------
package com.zzimcong.user;

import com.zzimcong.user.infrastructure.config.EmailProperties;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
@EnableConfigurationProperties(EmailProperties.class)
public class UserApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }
}


--------


File: ./src/main/java/com/zzimcong/user/api/response/ApiResponse.java
--------
package com.zzimcong.user.api.response;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }
}


--------


File: ./src/main/java/com/zzimcong/user/api/response/ErrorResponse.java
--------
package com.zzimcong.user.api.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.zzimcong.user.common.exception.BaseException;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {
    private int status;
    private String message;
    private String errorCode;
    private LocalDateTime timestamp;
    private String path;

    public static ErrorResponse of(BaseException ex, HttpStatus status, String path) {
        ErrorResponse response = new ErrorResponse();
        response.setStatus(status.value());
        response.setMessage(ex.getMessage());
        response.setErrorCode(ex.getErrorCode().name());
        response.setTimestamp(LocalDateTime.now());
        response.setPath(path);
        return response;
    }
}

--------


File: ./src/main/java/com/zzimcong/user/api/controller/EmailVerificationsController.java
--------
package com.zzimcong.user.api.controller;

import com.zzimcong.user.application.dto.EmailCheckDto;
import com.zzimcong.user.application.dto.EmailRequestDto;
import com.zzimcong.user.application.service.EmailVerificationService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j(topic = "EMAIL_VERIFICATIONS_CONTROLLER")
@RestController
@RequestMapping("/api/v1/email-verifications")
public class EmailVerificationsController {
    private final EmailVerificationService emailVerificationService;

    @Autowired
    public EmailVerificationsController(EmailVerificationService emailVerificationService) {
        this.emailVerificationService = emailVerificationService;
    }

    @PostMapping("/send")
    public ResponseEntity<String> sendVerificationEmail(@RequestBody @Valid EmailRequestDto emailDto) {
        log.info("인증 이메일 전송 요청: {}", emailDto.getEmail());
        emailVerificationService.sendVerificationEmail(emailDto.getEmail());
        return ResponseEntity.ok("인증 이메일이 성공적으로 전송되었습니다.");
    }

    @PostMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestBody @Valid EmailCheckDto emailCheckDto) {
        log.info("이메일 인증 요청: {}", emailCheckDto.getEmail());
        String token = emailVerificationService.verifyEmailAndGenerateToken(emailCheckDto.getEmail(), emailCheckDto.getAuthNum());
        return ResponseEntity.ok(token);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/api/controller/CustomErrorController.java
--------
package com.zzimcong.user.api.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.zzimcong.user.api.response.ErrorResponse;
import com.zzimcong.user.common.exception.BaseException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.InternalServerErrorException;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import jakarta.servlet.http.HttpServletRequest;

@Slf4j(topic = "CUSTOM_ERROR_CONTROLLER")
@RestController
public class CustomErrorController implements ErrorController {
    private final ObjectMapper objectMapper;

    public CustomErrorController(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @RequestMapping("/error")
    public void handleError(HttpServletRequest request, HttpServletResponse response) throws Exception {
        Integer status = (Integer) request.getAttribute("status");
        Exception ex = (Exception) request.getAttribute("exception");
        String path = (String) request.getAttribute("path");

        if (status == null) {
            status = HttpStatus.INTERNAL_SERVER_ERROR.value();
        }

        log.info("Error occurred: status={}, path={}", status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.UNKNOWN_ERROR);

        ErrorResponse errorResponse = ErrorResponse.of(baseException, HttpStatus.valueOf(status), path);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(status);
        response.getWriter().write(objectMapper.writeValueAsString(errorResponse));
    }
}

--------


File: ./src/main/java/com/zzimcong/user/api/controller/AuthController.java
--------
package com.zzimcong.user.api.controller;

import com.zzimcong.user.api.response.ApiResponse;
import com.zzimcong.user.application.service.AuthService;
import com.zzimcong.user.application.service.EmailVerificationService;
import com.zzimcong.user.application.dto.*;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j(topic = "AUTH_CONTROLLER")
@RestController
@RequestMapping("/api/v1/auth")
public class AuthController {
    private final AuthService authService;
    private final EmailVerificationService emailVerificationService;

    @Autowired
    public AuthController(AuthService authService, EmailVerificationService emailVerificationService) {
        this.authService = authService;
        this.emailVerificationService = emailVerificationService;
    }

    @GetMapping("/info")
    public String getUserInfo(HttpServletRequest request) {
        return "User Info";
    }

    // 이메일 중복 확인
    @PostMapping("/check-email")
    public ResponseEntity<?> checkEmailAvailability(@RequestBody EmailRequestDto emailRequestDto) {
        boolean isAvailable = emailVerificationService.isEmailAvailable(emailRequestDto.getEmail());
        String message = isAvailable ? "사용 가능한 이메일입니다." : "이미 사용 중인 이메일입니다.";
        return ResponseEntity.ok(ApiResponse.success(null, message));
    }

    @PostMapping("/signup")
    public ResponseEntity<?> signUp(@RequestBody @Valid SignupRequestDto signupRequestDto,
                                    @RequestParam String token) {
        authService.signUp(signupRequestDto, token);
        return ResponseEntity.ok(ApiResponse.success(null, "회원가입이 완료되었습니다."));
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequestDto loginRequestDto, HttpServletRequest request) {
        AuthResultDto authResultDto = authService.login(loginRequestDto);
        return ResponseEntity.ok(ApiResponse.success(authResultDto, "로그인에 성공했습니다."));
    }

    @PostMapping("/logout")
    public ResponseEntity<?> logout(@RequestBody LogoutRequest logoutRequest) {
        authService.logout(logoutRequest.getAccessToken());
        return ResponseEntity.ok(ApiResponse.success(null, "로그아웃되었습니다."));
    }

    // refreshToken을 이용한 accessToken 재발급
    @PostMapping("/refresh")
    public ResponseEntity<?> refreshToken(@RequestBody RefreshRequestDto refreshRequestDto) {
        String refreshToken = refreshRequestDto.getRefreshToken();
        String accessToken = authService.refreshToken(refreshToken);
        return ResponseEntity.ok(ApiResponse.success(accessToken, "토큰이 갱신되었습니다."));
    }

    private String extractRefreshTokenFromCookie(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("refreshToken".equals(cookie.getName())) {
                    return cookie.getValue();
                }
            }
        }
        return null;
    }
}

--------


File: ./src/main/java/com/zzimcong/user/api/controller/UserController.java
--------
package com.zzimcong.user.api.controller;

import com.zzimcong.user.application.dto.EmailRequestDto;
import com.zzimcong.user.application.dto.UserModifyRequestDto;
import com.zzimcong.user.application.dto.UserResponseDto;
import com.zzimcong.user.application.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j(topic = "USER_CONTROLLER")
@RestController
@RequestMapping("/api/v1/users")
public class UserController {
    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }

    //회원정보
    @GetMapping
    public ResponseEntity<UserResponseDto> getUserByEmail(@RequestBody EmailRequestDto emailRequestDto) {
        UserResponseDto user = userService.getUserByEmail(emailRequestDto.getEmail());
        return ResponseEntity.ok(user);
    }

    //회원정보 수정
    @PutMapping
    public ResponseEntity<UserResponseDto> updateUser(@RequestBody UserModifyRequestDto userModifyRequestDto) {
        UserResponseDto updatedUser = userService.updateUser(userModifyRequestDto);
        return ResponseEntity.ok(updatedUser);
    }

    //회원탈퇴
    @PostMapping("/signout")
    public ResponseEntity<UserResponseDto> signoutUser(@RequestBody EmailRequestDto emailRequestDto) {
        UserResponseDto signoutUser = userService.signoutUser(emailRequestDto.getEmail());
        return ResponseEntity.ok(signoutUser);
    }
}


--------


File: ./src/main/java/com/zzimcong/user/application/dto/AuthResultDto.java
--------
package com.zzimcong.user.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class AuthResultDto {
    private String accessToken;
    private String refreshToken;
}

--------


File: ./src/main/java/com/zzimcong/user/application/dto/UserResponseDto.java
--------
package com.zzimcong.user.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class UserResponseDto {
    private Long id;
    private String email;
    private String username;
    private String phone;
}

--------


File: ./src/main/java/com/zzimcong/user/application/dto/LogoutRequest.java
--------
package com.zzimcong.user.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LogoutRequest {
    private String accessToken;
}


--------


File: ./src/main/java/com/zzimcong/user/application/dto/LoginRequestDto.java
--------
package com.zzimcong.user.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LoginRequestDto {
    private String email;
    private String password;
}

--------


File: ./src/main/java/com/zzimcong/user/application/dto/EmailCheckDto.java
--------
package com.zzimcong.user.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import lombok.Data;

@Data
public class EmailCheckDto {
    @Email
    @NotEmpty(message = "이메일을 입력해 주세요")
    private String email;

    @NotEmpty(message = "인증 번호를 입력해 주세요")
    private String authNum;

}

--------


File: ./src/main/java/com/zzimcong/user/application/dto/EmailRequestDto.java
--------
package com.zzimcong.user.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class EmailRequestDto {
    //1. @기호를 포함해야 한다.
    //2. @기호를 기준으로 이메일 주소를 이루는 로컬호스트와 도메인 파트가 존재해야 한다.
    //3. 도메인 파트는 최소하나의 점과 그 뒤에 최소한 2개의 알파벳을 가진다
    @Email(message = "이메일 형식이 올바르지 않습니다.")
    @NotEmpty(message = "이메일을 입력해 주세요")
    private String email;
}

--------


File: ./src/main/java/com/zzimcong/user/application/dto/UserModifyRequestDto.java
--------
package com.zzimcong.user.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class UserModifyRequestDto {
    private String email;
    private String username;
    private String phone;
    private String password;
}


--------


File: ./src/main/java/com/zzimcong/user/application/dto/SignupRequestDto.java
--------
package com.zzimcong.user.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SignupRequestDto {
    @NotBlank(message = "이메일은 필수 입력 값입니다.")
    @Email(message = "이메일 형식이 아닙니다.")
    private String email;

    @NotBlank(message = "이름은 필수 입력 값입니다.")
    private String name;

    @NotBlank(message = "전화번호는 필수 입력 값입니다.")
    private String phone;

    @NotBlank(message = "비밀번호는 필수 입력 값입니다.")
    private String password;
}


--------


File: ./src/main/java/com/zzimcong/user/application/dto/RefreshRequestDto.java
--------
package com.zzimcong.user.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class RefreshRequestDto {
    private String refreshToken;
}


--------


File: ./src/main/java/com/zzimcong/user/application/service/CookieService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.infrastructure.config.RefreshTokenCookieProperties;
import jakarta.servlet.http.Cookie;
import org.springframework.stereotype.Service;

@Service
public class CookieService {

    private final RefreshTokenCookieProperties refreshTokenCookieProperties;

    public CookieService(RefreshTokenCookieProperties refreshTokenCookieProperties) {
        this.refreshTokenCookieProperties = refreshTokenCookieProperties;
    }

    public Cookie createRefreshTokenCookie(String refreshToken) {
        Cookie cookie = new Cookie(refreshTokenCookieProperties.getName(), refreshToken);
        cookie.setHttpOnly(refreshTokenCookieProperties.isHttpOnly());
        cookie.setSecure(refreshTokenCookieProperties.isSecure());
        cookie.setPath(refreshTokenCookieProperties.getPath());
        cookie.setMaxAge(refreshTokenCookieProperties.getMaxAge());
        return cookie;
    }
}

--------


File: ./src/main/java/com/zzimcong/user/application/service/UserService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.common.exception.BadRequestException;
import com.zzimcong.user.common.util.AESUtil;
import com.zzimcong.user.application.dto.SignupRequestDto;
import com.zzimcong.user.domain.entity.User;
import com.zzimcong.user.application.dto.UserModifyRequestDto;
import com.zzimcong.user.application.dto.UserResponseDto;
import com.zzimcong.user.common.exception.ConflictException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.NotFoundException;
import com.zzimcong.user.domain.mapper.UserMapper;
import com.zzimcong.user.domain.repository.UserRepository;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Slf4j(topic = "USER_SERVICE")
@Service
public class UserService {
    private final UserRepository userRepository;
    private final UserMapper userMapper;
    private final AESUtil aesUtil;

    @Autowired
    public UserService(UserRepository userRepository, UserMapper userMapper, AESUtil aesUtil) {
        this.userRepository = userRepository;
        this.userMapper = userMapper;
        this.aesUtil = aesUtil;
    }

    //이메일 중복 체크
    public boolean checkEmailAvailability(String email) {
        return !userRepository.existsByEmail(aesUtil.encrypt(email));
    }

    //유저 생성
    public User createUser(SignupRequestDto signupRequestDto) {
        if (userRepository.existsByEmail(aesUtil.encrypt(signupRequestDto.getEmail()))) {
            throw new ConflictException(ErrorCode.DUPLICATE_EMAIL);
        }
        User user = userMapper.toEntity(signupRequestDto);
        return userRepository.save(user);
    }

    //유저 조회
    public UserResponseDto getUserByEmail(String email) {
        User user = userRepository.findByEmail(aesUtil.encrypt(email))
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        return userMapper.toDto(user);
    }

    public UserResponseDto getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        return userMapper.toDto(user);
    }

    //유저 수정
    @Transactional
    public UserResponseDto updateUser(UserModifyRequestDto userModifyRequestDto) {
        User findUser = userRepository.findByEmail(aesUtil.encrypt(userModifyRequestDto.getEmail()))
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        findUser = userMapper.updateFromDto(findUser, userModifyRequestDto);
        User updatedUser = userRepository.save(findUser);
        return userMapper.toDto(updatedUser);
    }

    //유저 삭제
    public UserResponseDto signoutUser(String email) {
        User findUser = userRepository.findByEmail(aesUtil.encrypt(email))
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        findUser.setSignout(true);
        User signoutUser = userRepository.save(findUser);
        return userMapper.toDto(signoutUser);
    }
}


--------


File: ./src/main/java/com/zzimcong/user/application/service/AuthService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.application.dto.AuthResultDto;
import com.zzimcong.user.application.dto.LoginRequestDto;
import com.zzimcong.user.application.dto.SignupRequestDto;
import com.zzimcong.user.common.exception.UnauthorizedException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.infrastructure.security.jwt.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

@Slf4j(topic = "AUTH_SERVICE")
@Service
public class AuthService {
    private final TokenService tokenService;
    private final UserService userService;
    private final EmailVerificationService emailVerificationService;
    private final JwtUtil jwtUtil;
    private final AuthenticationManager authenticationManager;

    public AuthService(TokenService tokenService,
                       UserService userService,
                       EmailVerificationService emailVerificationService,
                       JwtUtil jwtUtil,
                       AuthenticationManager authenticationManager) {
        this.tokenService = tokenService;
        this.userService = userService;
        this.emailVerificationService = emailVerificationService;
        this.jwtUtil = jwtUtil;
        this.authenticationManager = authenticationManager;
    }

    public void signUp(SignupRequestDto signupRequestDto, String token) {
        emailVerificationService.validateTokenForRegistration(signupRequestDto.getEmail(), token);
        userService.createUser(signupRequestDto);
    }

    public AuthResultDto login(LoginRequestDto requestDto) {
        try {
            Authentication authentication = authenticateUser(requestDto);
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            Long id = Long.parseLong(userDetails.getUsername());
            return generateAuthResultDto(id);
        } catch (AuthenticationException e) {
            throw new UnauthorizedException(ErrorCode.INVALID_CREDENTIALS, "잘못된 이메일 또는 비밀번호입니다.");
        }
    }

    public void logout(String accessToken) {
        try {
            if (!jwtUtil.validateToken(accessToken)) {
                throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
            }
            Long id = jwtUtil.extractId(accessToken);
            tokenService.deleteRefreshToken(String.valueOf(id));
        } catch (ExpiredJwtException e) {
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }
    }

    public String refreshToken(String refreshToken) {
        if (refreshToken == null) {
            throw new UnauthorizedException(ErrorCode.TOKEN_NOT_FOUND);
        }
        try {
            if (!jwtUtil.validateToken(refreshToken)) {
                throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
            }
            Long id = jwtUtil.extractId(refreshToken);
            userService.getUserById(id);
            return jwtUtil.generateAccessToken(id);
        } catch (ExpiredJwtException e) {
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }
    }

    private Authentication authenticateUser(LoginRequestDto requestDto) {
        return authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(requestDto.getEmail(), requestDto.getPassword())
        );
    }

    private AuthResultDto generateAuthResultDto(Long id) {
        String accessToken = jwtUtil.generateAccessToken(id);
        String refreshToken = jwtUtil.generateRefreshToken(id);
        tokenService.storeRefreshToken(String.valueOf(id), refreshToken);
        return new AuthResultDto(accessToken, refreshToken);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/application/service/EmailVerificationService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.common.util.EmailVerificationToken;
import com.zzimcong.user.common.util.RedisUtil;
import com.zzimcong.user.infrastructure.config.EmailProperties;
import com.zzimcong.user.common.exception.ConflictException;
import com.zzimcong.user.common.exception.UnauthorizedException;
import com.zzimcong.user.common.exception.ErrorCode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j(topic = "EMAIL_VERIFICATION_SERVICE")
@Service
public class EmailVerificationService {
    private final Set<EmailVerificationToken> emailVerificationTokens =
            Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final EmailProperties emailProperties;
    private final EmailService emailService;
    private final UserService userService;
    private final RedisUtil redisUtil;

    public EmailVerificationService(EmailProperties emailProperties, EmailService emailService, UserService userService, RedisUtil redisUtil) {
        this.emailProperties = emailProperties;
        this.emailService = emailService;
        this.userService = userService;
        this.redisUtil = redisUtil;
    }

    public void sendVerificationEmail(String email) {
        if (!isEmailAvailable(email)) {
            log.warn("사용할 수 없는 이메일입니다: {}", email);
            throw new ConflictException(ErrorCode.DUPLICATE_EMAIL);
        }
        String verificationCode = emailService.generateVerificationCode();
        emailService.sendVerificationEmail(email, verificationCode);
        storeVerificationCode(verificationCode, email);
        log.info("인증 이메일 전송: {}", email);
    }

    public boolean isEmailAvailable(String email) {
        return userService.checkEmailAvailability(email);
    }

    private void storeVerificationCode(String code, String email) {
        redisUtil.setDataExpire(code, email,
                emailProperties.getVerification().getCode().getExpiry().getSeconds());
    }

    public String verifyEmailAndGenerateToken(String email, String verificationCode) {
        if (!verifyEmailCode(email, verificationCode)) {
            throw new UnauthorizedException(ErrorCode.INVALID_VERIFICATION_CODE);
        }
        String token = UUID.randomUUID().toString();
        EmailVerificationToken verificationToken =
                new EmailVerificationToken(token, email, LocalDateTime.now().plusMinutes(
                        emailProperties.getVerification().getToken().getExpiry().getMinutes()));
        emailVerificationTokens.add(verificationToken);
        log.info("이메일 인증 성공 및 토큰 생성: {}", email);
        return token;
    }

    private boolean verifyEmailCode(String email, String code) {
        String storedEmail = redisUtil.getData(code);
        return storedEmail != null && storedEmail.equals(email);
    }

    public void validateTokenForRegistration(String email, String token) {
        EmailVerificationToken verificationToken = emailVerificationTokens.stream()
                .filter(t -> t.getToken().trim().equalsIgnoreCase(token.trim())
                        && t.getEmail().trim().equalsIgnoreCase(email.trim()))
                .findFirst()
                .orElseThrow(() -> new UnauthorizedException(ErrorCode.INVALID_TOKEN));

        if (LocalDateTime.now().isAfter(verificationToken.getExpiryDate())) {
            emailVerificationTokens.remove(verificationToken);
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }

        emailVerificationTokens.remove(verificationToken);
    }

    @Scheduled(fixedRate = 60000) // 1분마다 실행
    public void cleanupExpiredTokens() {
        emailVerificationTokens.removeIf(token -> LocalDateTime.now().isAfter(token.getExpiryDate()));
    }
}

--------


File: ./src/main/java/com/zzimcong/user/application/service/EmailService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.common.exception.InternalServerErrorException;
import com.zzimcong.user.infrastructure.config.EmailProperties;
import com.zzimcong.user.common.exception.ErrorCode;
import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import org.springframework.util.StreamUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Random;

@Slf4j(topic = "EMAIL_SERVICE")
@Service
@RequiredArgsConstructor
public class EmailService {
    private final EmailProperties emailProperties;
    private final JavaMailSender mailSender;
    private final ResourceLoader resourceLoader;

    public String generateVerificationCode() {
        Random random = new Random();
        return String.format("%0" + emailProperties.getVerification().getCode().getLength() + "d",
                random.nextInt((int) Math.pow(10, emailProperties.getVerification().getCode().getLength())));
    }

    private String prepareEmailContent(String verificationCode) {
        try {
            String template = loadEmailTemplate();
            return template.replace("${verificationCode}", verificationCode);
        } catch (IOException e) {
            log.error("Failed to load email template", e);
            throw new InternalServerErrorException(ErrorCode.RESOURCE_LOAD_FAILED,
                    "이메일 템플릿 로딩에 실패했습니다.");
        }
    }

    private String loadEmailTemplate() throws IOException {
        Resource resource = resourceLoader.getResource(emailProperties.getTemplate().getPath());
        return StreamUtils.copyToString(resource.getInputStream(), StandardCharsets.UTF_8);
    }

    public void sendVerificationEmail(String toEmail, String verificationCode) {
        try {
            String content = prepareEmailContent(verificationCode);
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8");

            helper.setFrom(emailProperties.getSender());
            helper.setTo(toEmail);
            helper.setSubject(emailProperties.getSubject());
            helper.setText(content, true);

            mailSender.send(message);
            log.info("인증 메일이 성공적으로 전송되었습니다: {}", toEmail);
        } catch (MessagingException e) {
            log.error("인증 메일 전송에 실패했습니다: {}", toEmail, e);
            throw new InternalServerErrorException(ErrorCode.EMAIL_SEND_FAILED,
                    "인증 메일 전송에 실패했습니다.");
        }
    }
}

--------


File: ./src/main/java/com/zzimcong/user/application/service/TokenService.java
--------
package com.zzimcong.user.application.service;

import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
public class TokenService {
    private final RedisTemplate<String, String> redisTemplate;

    public TokenService(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public void storeRefreshToken(String username, String refreshToken) {
        redisTemplate.opsForValue().set(username, refreshToken);
        redisTemplate.expire(username, 7, TimeUnit.DAYS);
    }

    public void deleteRefreshToken(String username) {
        redisTemplate.delete(username);
    }

    public String getRefreshToken(String username) {
        return redisTemplate.opsForValue().get(username);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/application/service/UserDetailsServiceImpl.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.common.util.AESUtil;
import com.zzimcong.user.domain.entity.User;
import com.zzimcong.user.common.exception.NotFoundException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.domain.repository.UserRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;
    private final AESUtil aesUtil;

    public UserDetailsServiceImpl(UserRepository userRepository, AESUtil aesUtil) {
        this.userRepository = userRepository;
        this.aesUtil = aesUtil;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(aesUtil.encrypt(email))
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        return org.springframework.security.core.userdetails.User
                .withUsername(String.valueOf(user.getId()))
                .password(user.getPassword())
                .roles("USER")
                .build();
    }
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/config/EmailConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;

import java.util.Properties;

@Configuration
public class EmailConfig {

    private final EmailProperties emailProperties;

    public EmailConfig(EmailProperties emailProperties) {
        this.emailProperties = emailProperties;
    }

    @Bean
    public JavaMailSender mailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(emailProperties.getHost());
        mailSender.setPort(emailProperties.getPort());
        mailSender.setUsername(emailProperties.getUsername());
        mailSender.setPassword(emailProperties.getPassword());

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", String.valueOf(emailProperties.getProperties().getMail().getSmtp().isAuth()));
        props.put("mail.smtp.starttls.enable", String.valueOf(
                emailProperties.getProperties().getMail().getSmtp().getStarttls().isEnable()));

        // 개발 환경에서만 디버그 모드 활성화
        if (System.getProperty("spring.profiles.active", "").contains("dev")) {
            props.put("mail.debug", "true");
        }

        return mailSender;
    }
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/config/RefreshTokenCookieProperties.java
--------
package com.zzimcong.user.infrastructure.config;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;

@Component
@ConfigurationProperties(prefix = "auth.cookie.refresh-token")
@Validated
@Getter
@Setter
public class RefreshTokenCookieProperties {
    @NotBlank
    private String name;

    @Min(0)
    private int maxAge;

    private boolean httpOnly;
    private boolean secure;

    @NotBlank
    private String path;
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/config/RedisConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

@Configuration
@EnableCaching
public class RedisConfig {
    @Bean
    public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, String> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new StringRedisSerializer());
        return template;
    }

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(cacheConfig)
                .build();
    }
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/config/WebConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import com.zzimcong.user.infrastructure.config.interceptor.TokenInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    private final TokenInterceptor tokenInterceptor;

    public WebConfig(TokenInterceptor tokenInterceptor) {
        this.tokenInterceptor = tokenInterceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(tokenInterceptor).addPathPatterns("/api/**");
    }
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/config/SwaggerConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("찜콩 API")
                        .version("1.0")
                        .description("선착순 구매 기능이 있는 이커머스 서비스 API 문서"));
    }
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/config/EmailProperties.java
--------
package com.zzimcong.user.infrastructure.config;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

@ConfigurationProperties(prefix = "email")
@Validated
@Data
public class EmailProperties {
    @NotBlank
    private String host;

    @Min(1)
    @Max(65535)
    private int port;

    @NotBlank
    private String username;

    @NotBlank
    private String password;

    private Properties properties = new Properties();

    @Data
    public static class Properties {
        private Mail mail = new Mail();

        @Data
        public static class Mail {
            private Smtp smtp = new Smtp();

            @Data
            public static class Smtp {
                private boolean auth;
                private Starttls starttls = new Starttls();

                @Data
                public static class Starttls {
                    private boolean enable;
                }
            }
        }
    }

    @NotBlank
    private String sender;

    @NotBlank
    private String subject;

    private Template template = new Template();
    private Verification verification = new Verification();

    @Data
    public static class Template {
        @NotBlank
        private String path;
    }

    @Data
    public static class Verification {
        private Code code = new Code();
        private Token token = new Token();

        @Data
        public static class Code {
            @Min(4)
            @Max(10)
            private int length = 6;

            private Expiry expiry = new Expiry();

            @Data
            public static class Expiry {
                @Min(60)
                @Max(600)
                private long seconds = 300;
            }
        }

        @Data
        public static class Token {
            private Expiry expiry = new Expiry();

            @Data
            public static class Expiry {
                @Min(5)
                @Max(60)
                private long minutes = 30;
            }
        }
    }
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/config/JpaConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
@EnableJpaAuditing
public class JpaConfig {
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/config/interceptor/TokenInterceptor.java
--------
package com.zzimcong.user.infrastructure.config.interceptor;

import com.zzimcong.user.application.service.CookieService;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

@Component
public class TokenInterceptor implements HandlerInterceptor {

    private final CookieService cookieService;

    public TokenInterceptor(CookieService cookieService) {
        this.cookieService = cookieService;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {
        String refreshToken = (String) request.getAttribute("refreshToken");
        if (refreshToken != null) {
            Cookie refreshTokenCookie = cookieService.createRefreshTokenCookie(refreshToken);
            response.addCookie(refreshTokenCookie);
        }
    }
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/config/CorsConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("http://localhost:3000"); // React 앱의 주소
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        source.registerCorsConfiguration("/api/**", config);
        return new CorsFilter(source);
    }
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/security/jwt/JwtUtil.java
--------
package com.zzimcong.user.infrastructure.security.jwt;

import com.zzimcong.user.common.exception.BadRequestException;
import com.zzimcong.user.common.exception.ErrorCode;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;
import java.util.function.Function;

@Slf4j(topic = "JWT_UTIL")
@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.access-token.expiration}")
    private long accessTokenExpiration;

    @Value("${jwt.refresh-token.expiration}")
    private long refreshTokenExpiration;

    private Key getSigningKey() {
        byte[] keyBytes = secret.getBytes();
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateAccessToken(Long id) {
        return generateToken(id, accessTokenExpiration);
    }


    public String generateRefreshToken(Long id) {
        return generateToken(id, refreshTokenExpiration);
    }

    private String generateToken(Long id, long expiration) {
        Date now = new Date(System.currentTimeMillis());
        Date expiryDate = new Date(now.getTime() + expiration * 1000);
        log.info("Generating token for subject: {}, expiration: {}", id, expiryDate);
        return Jwts.builder()
                .setSubject(String.valueOf(id))
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(expiryDate)
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public Long extractId(String token) {
        return Long.parseLong(extractClaim(token, Claims::getSubject));
    }

    public Boolean validateToken(String token, Long id) {
        final Long tokenId = extractId(token);
        return (tokenId.equals(id) && !isTokenExpired(token));
    }

    public Boolean validateToken(String token) {
        try {
            // 1. 토큰 파싱 및 서명 검증
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token);

            // 2. 추가적인 검증 (예: 만료 시간)
            Claims claims = extractAllClaims(token);
            return !isTokenExpired(claims);
        } catch (JwtException | IllegalArgumentException e) {
            log.error("Invalid JWT token", e);
            // 3. 예외 처리
            return false;
        }
    }

    private boolean isTokenExpired(Claims claims) {
        return claims.getExpiration().before(new Date());
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        try {
            return Jwts.parserBuilder().setSigningKey(getSigningKey()).build().parseClaimsJws(token).getBody();
        }  catch (Exception ex) {
            log.error("Invalid JWT token", ex);
            throw new BadRequestException(ErrorCode.INVALID_TOKEN);
        }
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/security/jwt/JwtRequestFilter.java
--------
package com.zzimcong.user.infrastructure.security.jwt;

import com.zzimcong.user.api.response.ErrorResponse;
import com.zzimcong.user.common.exception.*;
import com.zzimcong.user.domain.entity.User;
import com.zzimcong.user.domain.repository.UserRepository;
import com.zzimcong.user.infrastructure.security.UserDetailsImpl;
import io.jsonwebtoken.ExpiredJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Slf4j(topic = "JWT_REQUEST_FILTER")
@Component
public class JwtRequestFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final UserRepository userRepository;

    public JwtRequestFilter(JwtUtil jwtUtil, UserRepository userRepository) {
        this.jwtUtil = jwtUtil;
        this.userRepository = userRepository;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        try {

            final String authorizationHeader = request.getHeader("Authorization");

            Long id = null;
            String jwt = null;

            if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
                jwt = authorizationHeader.substring(7);
                try {
                    id = jwtUtil.extractId(jwt);
                } catch (ExpiredJwtException e) {
                    log.warn("JWT 토큰이 만료되었습니다", e);
                    throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
                } catch (Exception e) {
                    log.error("JWT 토큰에서 id를 추출하는 중 오류가 발생했습니다", e);
                    throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
                }
            }

            if (id != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                User user = userRepository.findById(id)
                        .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

                if (jwtUtil.validateToken(jwt, user.getId())) {
                    UserDetailsImpl userDetails = new UserDetailsImpl(user);

                    UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                            userDetails, null, userDetails.getAuthorities());
                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                    SecurityContextHolder.getContext().setAuthentication(authToken);
                } else {
                    log.warn("JWT 토큰 검증에 실패했습니다");
                    throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
                }
            }

            chain.doFilter(request, response);
        } catch (Exception e) {
            log.error("JWT 토큰 검증 중 오류가 발생했습니다", e);
            ErrorResponse errorResponse = createErrorResponse(e, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
            response.getWriter().write(errorResponse.toString());
        }
    }

    // Create ErrorResponse
    private ErrorResponse createErrorResponse(Exception ex, HttpStatus status, String path) {
        logException(ex, status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.INTERNAL_SERVER_ERROR);
        return ErrorResponse.of(baseException, status, path);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        log.error(
                "\n\nException occurred:: Error Code: {}, HTTP Status: {}, Message: {}, Path: {}\n",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage(),
                path,
                ex
        );
    }
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/security/SecurityConfig.java
--------
package com.zzimcong.user.infrastructure.security;

import com.zzimcong.user.infrastructure.security.jwt.JwtRequestFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JwtRequestFilter jwtAuthFilter;

    public SecurityConfig(JwtRequestFilter jwtAuthFilter) {
        this.jwtAuthFilter = jwtAuthFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/v1/auth/**").permitAll()
                        .requestMatchers("/api/v1/email-verifications/**").permitAll()
                        .requestMatchers("/api/v1/users/**").authenticated()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

--------


File: ./src/main/java/com/zzimcong/user/infrastructure/security/UserDetailsImpl.java
--------
package com.zzimcong.user.infrastructure.security;

import com.zzimcong.user.domain.entity.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;

public class UserDetailsImpl implements UserDetails {
    private final User user;

    public UserDetailsImpl(User user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority(user.getRole()));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return String.valueOf(user.getId());
    }
}

--------


File: ./src/main/java/com/zzimcong/user/domain/repository/UserRepository.java
--------
package com.zzimcong.user.domain.repository;

import com.zzimcong.user.domain.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Boolean existsByEmail(String email);

    Optional<User> findByEmail(String email);
}


--------


File: ./src/main/java/com/zzimcong/user/domain/entity/BaseEntity.java
--------
package com.zzimcong.user.domain.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@Setter
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
public abstract class BaseEntity {

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

}

--------


File: ./src/main/java/com/zzimcong/user/domain/entity/User.java
--------
package com.zzimcong.user.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Getter
@Setter
@Table(name = "user")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long id;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String phone;

    @Column(nullable = false)
    private boolean abuser = false;

    @Column(nullable = false)
    private boolean signout = false;

    @Column(nullable = false)
    private String role = "USER";
}


--------


File: ./src/main/java/com/zzimcong/user/domain/mapper/UserMapper.java
--------
package com.zzimcong.user.domain.mapper;

import com.zzimcong.user.common.util.AESUtil;
import com.zzimcong.user.application.dto.SignupRequestDto;
import com.zzimcong.user.domain.entity.User;
import com.zzimcong.user.application.dto.UserModifyRequestDto;
import com.zzimcong.user.application.dto.UserResponseDto;
import com.zzimcong.user.common.exception.InternalServerErrorException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

@Component
public class UserMapper {
    private static final Logger logger = LoggerFactory.getLogger(UserMapper.class);
    private final AESUtil aesUtil;
    private final PasswordEncoder passwordEncoder;

    public UserMapper(PasswordEncoder passwordEncoder, AESUtil aesUtil) {
        this.aesUtil = aesUtil;
        this.passwordEncoder = passwordEncoder;
    }

    //Dto -> Entity 변환
    public User toEntity(SignupRequestDto dto) {
        if (dto == null) {
            return null;
        }
        User user = new User();
        try {
            user.setName(aesUtil.encrypt(dto.getName()));
            user.setEmail(aesUtil.encrypt(dto.getEmail()));
            user.setPhone(aesUtil.encrypt(dto.getPhone()));
            user.setPassword(passwordEncoder.encode(dto.getPassword()));
        } catch (InternalServerErrorException e) {
            logger.error("Error encrypting user data: {}", e.getMessage());
            throw e;
        }

        return user;
    }

    //Entity -> Dto 변환
    public UserResponseDto toDto(User user) {
        if (user == null) {
            return null;
        }
        UserResponseDto dto = new UserResponseDto();
        try {
            dto.setId(user.getId());
            dto.setEmail(aesUtil.decrypt(user.getEmail()));
            dto.setUsername(aesUtil.decrypt(user.getName()));
            dto.setPhone(aesUtil.decrypt(user.getPhone()));
        } catch (InternalServerErrorException e) {
            logger.error("Error decrypting user data: {}", e.getMessage());
            throw e;
        }

        return dto;
    }

    //Dto를 이용해 Entity 업데이트
    public User updateFromDto(User user, UserModifyRequestDto dto) {
        if (user == null || dto == null) {
            return null;
        }
        user.setName(aesUtil.encrypt(dto.getUsername()));
        user.setPhone(aesUtil.encrypt(dto.getPhone()));
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        return user;
    }
}


--------


