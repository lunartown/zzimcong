File: ./order/src/test/java/com/zzimcong/order/OrderApplicationTests.java
--------
package com.zzimcong.order;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class OrderApplicationTests {

    @Test
    void contextLoads() {
    }

}


--------


File: ./order/src/main/java/com/zzimcong/order/config/WebMvcConfig.java
--------
package com.zzimcong.order.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.List;

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    private final UserInfoArgumentResolver userInfoArgumentResolver;

    public WebMvcConfig(UserInfoArgumentResolver userInfoArgumentResolver) {
        this.userInfoArgumentResolver = userInfoArgumentResolver;
    }

    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        resolvers.add(userInfoArgumentResolver);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/config/SecurityConfig.java
--------
package com.zzimcong.order.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Slf4j(topic = "security")
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        log.info("Configuring security filter chain");
        http
                .csrf(csrf -> {
                    csrf.disable();
                    log.info("CSRF is disabled");
                })
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/v1/orders/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().permitAll()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                );

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/config/KafkaConfig.java
--------
package com.zzimcong.order.config;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.support.serializer.JsonSerializer;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Bean
    public <T> ProducerFactory<String, T> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public <T> KafkaTemplate<String, T> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/config/SwaggerConfig.java
--------
package com.zzimcong.order.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("찜콩 API")
                        .version("1.0")
                        .description("선착순 구매 기능이 있는 이커머스 서비스 API 문서"));
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/config/UserInfoArgumentResolver.java
--------
package com.zzimcong.order.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.zzimcong.order.common.UserInfo;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.core.MethodParameter;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.ModelAndViewContainer;

import java.util.Base64;

@Component
public class UserInfoArgumentResolver implements HandlerMethodArgumentResolver {

    private final ObjectMapper objectMapper;

    public UserInfoArgumentResolver(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.getParameterType().equals(UserInfo.class);
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        HttpServletRequest request = (HttpServletRequest) webRequest.getNativeRequest();
        String userInfoHeader = request.getHeader("X-User-Info");

        if (userInfoHeader != null) {
            String decodedUserInfo = new String(Base64.getDecoder().decode(userInfoHeader));
            return objectMapper.readValue(decodedUserInfo, UserInfo.class);
        }

        return null;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/config/JpaConfig.java
--------
package com.zzimcong.order.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
@EnableJpaAuditing
public class JpaConfig {
}

--------


File: ./order/src/main/java/com/zzimcong/order/config/CorsConfig.java
--------
package com.zzimcong.order.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CorsConfig {

    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("http://localhost:3000"); // React 앱의 주소
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        source.registerCorsConfiguration("/api/**", config);
        return new CorsFilter(source);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/OrderApplication.java
--------
package com.zzimcong.order;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.statemachine.config.EnableStateMachine;

@SpringBootApplication
@EnableFeignClients
@EnableStateMachine
@EnableScheduling
public class OrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/common/util/RedisUtil.java
--------
package com.zzimcong.order.common.util;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Service
@RequiredArgsConstructor
public class RedisUtil {
    private final StringRedisTemplate redisTemplate;//Redis에 접근하기 위한 Spring의 Redis 템플릿 클래스

    public String getData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 가져오는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        return valueOperations.get(key);
    }

    public void setData(String key, String value) {//지정된 키(key)에 값을 저장하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        valueOperations.set(key, value);
    }

    public void setDataExpire(String key, String value, long duration) {//지정된 키(key)에 값을 저장하고, 지정된 시간(duration) 후에 데이터가 만료되도록 설정하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        Duration expireDuration = Duration.ofSeconds(duration);
        valueOperations.set(key, value, expireDuration);
    }

    public void deleteData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 삭제하는 메서드
        redisTemplate.delete(key);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/UserInfo.java
--------
package com.zzimcong.order.common;

import lombok.Data;

@Data
public class UserInfo {
    private Long id;
    private String username;
    private String role;
    // 필요한 다른 필드들...
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/ErrorCode.java
--------
package com.zzimcong.order.common.exception;

import lombok.Getter;

@Getter
public enum ErrorCode {
    // BadRequestException (400)
    INVALID_INPUT("잘못된 입력입니다."),
    INVALID_ORDER_STATUS("유효하지 않은 주문 상태입니다."),
    MISSING_REQUEST_BODY("요청 바디가 없습니다."),

    // UnauthorizedException (401)

    // ForbiddenException (403)
    ACCESS_DENIED("접근이 거부되었습니다."),

    // NotFoundException (404)
    RESOURCE_NOT_FOUND("요청한 리소스를 찾을 수 없습니다."),
    ORDER_NOT_FOUND("주문을 찾을 수 없습니다."),

    // MethodNotAllowedException (405)
    METHOD_NOT_ALLOWED("허용되지 않은 HTTP 메서드입니다."),

    // ConflictException (409)
    INSUFFICIENT_STOCK("상품의 재고가 부족합니다."),
    CANNOT_CANCEL_ORDER("주문을 취소할 수 없습니다."),

    // InternalServerErrorException (500)
    RESOURCE_LOAD_FAILED("내부 리소스 로딩에 실패했습니다."),
    INTERNAL_SERVER_ERROR("서버 내부 오류가 발생했습니다."),
    UNKNOWN_ERROR("알 수 없는 오류가 발생했습니다.");

    private final String message;

    ErrorCode(String message) {
        this.message = message;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/ForbiddenException.java
--------
package com.zzimcong.order.common.exception;

public class ForbiddenException extends BaseException {
    public ForbiddenException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ForbiddenException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/UnauthorizedException.java
--------
package com.zzimcong.order.common.exception;

public class UnauthorizedException extends BaseException {
    public UnauthorizedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public UnauthorizedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/ConflictException.java
--------
package com.zzimcong.order.common.exception;

public class ConflictException extends BaseException {
    public ConflictException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ConflictException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/MethodNotAllowedException.java
--------
package com.zzimcong.order.common.exception;

public class MethodNotAllowedException extends BaseException {
    public MethodNotAllowedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public MethodNotAllowedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/InternalServerErrorException.java
--------
package com.zzimcong.order.common.exception;

public class InternalServerErrorException extends BaseException {
    public InternalServerErrorException(ErrorCode errorCode) {
        super(errorCode);
    }

    public InternalServerErrorException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/GlobalExceptionHandler.java
--------
package com.zzimcong.order.common.exception;

import com.zzimcong.order.api.response.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j(topic = "GLOBAL_EXCEPTION_HANDLER")
@ControllerAdvice
public class GlobalExceptionHandler {
    // BadRequestException (400)
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorResponse> httpMessageNotReadableException(HttpServletRequest request) {
        BadRequestException ex = new BadRequestException(ErrorCode.MISSING_REQUEST_BODY);
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    // UnauthorizedException (401)
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(UnauthorizedException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.UNAUTHORIZED, request.getRequestURI());
    }

    // ForbiddenException (403)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbiddenException(ForbiddenException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.FORBIDDEN, request.getRequestURI());
    }

    // NotFoundException (404)
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.NOT_FOUND, request.getRequestURI());
    }

    // MethodNotAllowedException (405)
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowedException(HttpServletRequest request) {
        MethodNotAllowedException ex = new MethodNotAllowedException(ErrorCode.METHOD_NOT_ALLOWED);
        return createErrorResponse(ex, HttpStatus.METHOD_NOT_ALLOWED, request.getRequestURI());
    }

    // ConflictException (409)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(ConflictException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.CONFLICT, request.getRequestURI());
    }

    // InternalServerErrorException (500)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllException(Exception ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
    }

    // Create ErrorResponse
    private ResponseEntity<ErrorResponse> createErrorResponse(Exception ex, HttpStatus status, String path) {
        logException(ex, status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.INTERNAL_SERVER_ERROR);
        ErrorResponse errorResponse = ErrorResponse.of(status, baseException, path);
        return new ResponseEntity<>(errorResponse, status);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        // 스택 트레이스를 분석하여 예외 발생 위치 추출
        StackTraceElement[] stackTraceElements = ex.getStackTrace();
        String errorLocation = "Unknown";
        if (stackTraceElements.length > 0) {
            StackTraceElement element = stackTraceElements[0];
            errorLocation = String.format("%s.%s (Line: %d)",
                    element.getClassName(),
                    element.getMethodName(),
                    element.getLineNumber());
        }
        log.error(
                "Exception occurred:: {}, Path: {}",
                errorLocation,
                path
        );
        log.error("Error Code: {}, HTTP Status: {}, Message: {}",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage());
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/BadRequestException.java
--------
package com.zzimcong.order.common.exception;

public class BadRequestException extends BaseException {
    public BadRequestException(ErrorCode errorCode) {
        super(errorCode);
    }

    public BadRequestException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/BaseException.java
--------
package com.zzimcong.order.common.exception;

public class BaseException extends RuntimeException {
    private final ErrorCode errorCode;
    private final String message;

    public BaseException(ErrorCode errorCode) {
        this(errorCode, errorCode.getMessage());
    }

    public BaseException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.message = message;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    @Override
    public String getMessage() {
        return message;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/NotFoundException.java
--------
package com.zzimcong.order.common.exception;

public class NotFoundException extends BaseException {
    public NotFoundException(ErrorCode errorCode) {
        super(errorCode);
    }

    public NotFoundException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/api/response/ApiResponse.java
--------
package com.zzimcong.order.api.response;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/api/response/ErrorResponse.java
--------
package com.zzimcong.order.api.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.zzimcong.order.common.exception.BaseException;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {
    private int status;
    private String message;
    private String errorCode;
    private LocalDateTime timestamp;
    private String path;

    public static ErrorResponse of(HttpStatus status, BaseException ex, String path) {
        ErrorResponse response = new ErrorResponse();
        response.setStatus(status.value());
        response.setMessage(ex.getMessage());
        response.setErrorCode(ex.getErrorCode().name());
        response.setTimestamp(LocalDateTime.now());
        response.setPath(path);
        return response;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/api/controller/OrderController.java
--------
package com.zzimcong.order.api.controller;

import com.zzimcong.order.application.dto.OrderRequest;
import com.zzimcong.order.application.dto.OrderResponse;
import com.zzimcong.order.application.saga.OrderSaga;
import com.zzimcong.order.application.service.OrderService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j(topic = "order-service")
@RestController
@RequestMapping("/api/v1/orders")
public class OrderController {
    private final OrderService orderService;
    private final OrderSaga orderSaga;

    @Autowired
    public OrderController(OrderService orderService, OrderSaga orderSaga) {
        this.orderService = orderService;
        this.orderSaga = orderSaga;
    }

    @PostMapping
    public ResponseEntity<Void> createOrder(@RequestHeader("X-Auth-User-ID") Long userId, @RequestBody OrderRequest orderRequest) {
        orderSaga.startOrderSaga(userId, orderRequest);
        return ResponseEntity.accepted().build();
    }

    @GetMapping("/{orderId}")
    public ResponseEntity<OrderResponse> getOrder(@RequestHeader("X-Auth-User-ID") Long userId, @PathVariable Long orderId) {
        OrderResponse orderResponse = orderService.getOrderResponse(orderId);
        return ResponseEntity.ok(orderResponse);
    }

    @GetMapping
    public ResponseEntity<Page<OrderResponse>> getOrderList(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        PageRequest pageRequest = PageRequest.of(page, size);
        Page<OrderResponse> responsePages = orderService.getOrderList(pageRequest);
        return ResponseEntity.ok(responsePages);
    }

    @GetMapping("/user")
    public ResponseEntity<Page<OrderResponse>> getUserOrders(
            @RequestHeader("X-Auth-User-ID") Long userId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        PageRequest pageRequest = PageRequest.of(page, size);
        Page<OrderResponse> orderPage = orderService.getUserOrders(userId, pageRequest);
        return ResponseEntity.ok(orderPage);
    }

    @PostMapping("/{orderId}/cancel")
    public ResponseEntity<Void> cancelOrder(
            @RequestHeader("X-Auth-User-ID") Long userId,
            @PathVariable Long orderId) {
        orderService.cancelOrderByOrderId(orderId);
        return ResponseEntity.accepted().build();
    }

    @PostMapping("/{orderId}/refund")
    public ResponseEntity<Void> requestRefund(@PathVariable Long orderId) {
        orderService.requestRefund(orderId);
        return ResponseEntity.accepted().build();
    }

//    @GetMapping("/{orderId}/items")
//    public ResponseEntity<List<OrderItemResponse>> getOrderItems(@PathVariable Long orderId) {
//        List<OrderItem> items = orderService.getOrderItems(orderId);
//        List<OrderItemResponse> itemResponses = items.stream()
//                .map(OrderItemResponse::createOrderItemResponse)
//                .collect(Collectors.toList());
//        return ResponseEntity.ok(itemResponses);
//    }

}

--------


File: ./order/src/main/java/com/zzimcong/order/api/client/ProductServiceClient.java
--------
package com.zzimcong.order.api.client;

import com.zzimcong.order.application.dto.ReleaseInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "product-service")
public interface ProductServiceClient {
    @PostMapping("/api/v1/products/{productId}/reserve")
    ReserveInventoryResponse reserveInventory(@PathVariable("productId") Long productId,
                                              @RequestBody ReserveInventoryRequest request);

    @PostMapping("/api/v1/products/{productId}/release")
    void releaseInventory(@PathVariable("productId") Long productId,
                          @RequestBody ReleaseInventoryRequest request);
}

--------


File: ./order/src/main/java/com/zzimcong/order/api/client/UserServiceClient.java
--------
package com.zzimcong.order.api.client;

import org.springframework.cloud.openfeign.FeignClient;

@FeignClient(name = "user-service")  // URL 제거, 서비스 이름만 사용
public interface UserServiceClient {
//    @GetMapping("/users/{userId}")
//    UserDto getUserById(@PathVariable("userId") Long userId);
}

--------


File: ./order/src/main/java/com/zzimcong/order/aspect/OrderAuthorizationAspect.java
--------
package com.zzimcong.order.aspect;

import com.zzimcong.order.common.UserInfo;
import com.zzimcong.order.common.exception.ErrorCode;
import com.zzimcong.order.common.exception.ForbiddenException;
import com.zzimcong.order.application.service.OrderService;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class OrderAuthorizationAspect {

    private final OrderService orderService;

    public OrderAuthorizationAspect(OrderService orderService) {
        this.orderService = orderService;
    }

    @Before("execution(* com.zzimcong.order.api.controller.OrderController.*(.., com.zzimcong.order.common.UserInfo, Long, ..)) && args(userInfo, orderId, ..)")
    public void validateUserAuthorization(JoinPoint joinPoint, UserInfo userInfo, Long orderId) {
        if (!orderService.isOrderOwnedByUser(orderId, userInfo.getId())) {
            throw new ForbiddenException(ErrorCode.ACCESS_DENIED, "주문 접근 권한이 없습니다.");
        }
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/aspect/LoggingAspect.java
--------
package com.zzimcong.order.aspect;

import com.zzimcong.order.common.UserInfo;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Slf4j
@Aspect
@Component
public class LoggingAspect {

    @Around("execution(* com.zzimcong.order.api.controller.*.*(.., com.zzimcong.order.common.UserInfo, ..))")
    public Object logAroundMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        UserInfo userInfo = null;
        for (Object arg : joinPoint.getArgs()) {
            if (arg instanceof UserInfo) {
                userInfo = (UserInfo) arg;
                break;
            }
        }

        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();

        log.info("사용자 ID: {}, 메서드 실행: {}.{}",
                userInfo != null ? userInfo.getId() : "Unknown",
                className, methodName);

        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long executionTime = System.currentTimeMillis() - start;

        log.info("사용자 ID: {}, 메서드 종료: {}.{}, 실행 시간: {}ms",
                userInfo != null ? userInfo.getId() : "Unknown",
                className, methodName, executionTime);

        return result;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderStatusUpdateRequest.java
--------
package com.zzimcong.order.application.dto;

import lombok.Getter;

@Getter
public class OrderStatusUpdateRequest {
    public String status;
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/ReleaseInventoryRequest.java
--------
package com.zzimcong.order.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ReleaseInventoryRequest {
    private int quantity;
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/CartItemDto.java
--------
package com.zzimcong.order.application.dto;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class CartItemDto {
    public Long productId;
    public Integer price;
    public Integer quantity;
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderItemResponse.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.order.domain.entity.OrderItem;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
public class OrderItemResponse {
    public Long id;
    public Long productId;
    public BigDecimal price;
    public Integer quantity;

    private OrderItemResponse(OrderItem orderItem) {
        this.id = orderItem.getId();
        this.productId = orderItem.getProductId();
        this.price = orderItem.getPrice();
        this.quantity = orderItem.getQuantity();
    }

    //factory method
    public static OrderItemResponse createOrderItemResponse(OrderItem orderItem) {
        return new OrderItemResponse(orderItem);
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderResponse.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.entity.PaymentType;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

@Getter
@Setter
@NoArgsConstructor
public class OrderResponse {
    public Long id;
    public Long userId;
    public BigDecimal orderAmount;
    public BigDecimal paymentAmount;
    public PaymentType payment;
    public OrderStatus status;
    public boolean deleted = false;
    public String reason;
    public String name;
    public String addr;
    public String addrDetail;
    public String zipcode;
    public String phone;
    public String message;
    public List<OrderItemResponse> items;

    private OrderResponse(Order order) {
        this.setId(order.getId());
        this.setUserId(order.getUserId());
        this.setOrderAmount(order.getOrderAmount());
        this.setPaymentAmount(order.getPaymentAmount());
        this.setPayment(order.getPayment());
        this.setStatus(order.getStatus());
        this.setDeleted(order.isDeleted());
        this.setReason(order.getReason());
        this.setName(order.getName());
        this.setAddr(order.getAddr());
        this.setAddrDetail(order.getAddrDetail());
        this.setZipcode(order.getZipcode());
        this.setPhone(order.getPhone());
        this.setMessage(order.getMessage());
    }

    private OrderResponse(Order order, List<OrderItem> orderItems) {
        this(order);
        this.setItems(orderItems.stream()
                .map(OrderItemResponse::createOrderItemResponse)
                .collect(Collectors.toList()));
    }

    //factory method
    public static OrderResponse createOrderResponse(Order order) {
        return new OrderResponse(order);
    }

    public static OrderResponse createOrderResponse(Order order, List<OrderItem> orderItems) {
        return new OrderResponse(order, orderItems);
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderListResponse.java
--------
package com.zzimcong.order.application.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class OrderListResponse {
    private List<OrderResponse> orders;
    private int totalPages;
    private long totalElements;
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/PaymentResult.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class PaymentResult implements KafkaMessage {
    private Long orderId;
    private boolean success;
    private String status;

    public PaymentResult(Long orderId, boolean success) {
        this.orderId = orderId;
        this.success = success;
        this.status = success ? "PAID" : "FAILED";
    }

    public PaymentResult(Long orderId, boolean success, String status) {
        this.orderId = orderId;
        this.success = success;
        this.status = status;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/ReserveInventoryResponse.java
--------
package com.zzimcong.order.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ReserveInventoryResponse {
    private boolean success;
    private String message;
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderItemRequest.java
--------
package com.zzimcong.order.application.dto;

import lombok.Getter;
import lombok.Setter;

import java.math.BigDecimal;

@Getter
@Setter
public class OrderItemRequest {
    public Long productId;
    public BigDecimal price;
    public Integer quantity;
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderRequest.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.order.domain.entity.PaymentType;
import lombok.Getter;
import lombok.Setter;

import java.math.BigDecimal;
import java.util.List;

@Getter
@Setter
public class OrderRequest {
    private BigDecimal orderAmount;
    private BigDecimal paymentAmount;
    private PaymentType payment;
    private String name;
    private String addr;
    private String addrDetail;
    private String zipcode;
    private String phone;
    private String message;
    private List<OrderItemRequest> items;
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/ReserveInventoryRequest.java
--------
package com.zzimcong.order.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ReserveInventoryRequest {
    private int quantity;
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/PaymentRequest.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class PaymentRequest implements KafkaMessage {
    private Long orderId;
    private BigDecimal amount;
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/saga/OrderSaga.java
--------
package com.zzimcong.order.application.saga;

import com.zzimcong.order.application.dto.OrderRequest;
import com.zzimcong.order.application.dto.PaymentRequest;
import com.zzimcong.order.application.dto.PaymentResponse;
import com.zzimcong.order.application.service.OrderService;
import com.zzimcong.order.application.service.PaymentService;
import com.zzimcong.order.application.service.ProductService;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.zzimconginventorycore.common.event.OrderEvent;
import com.zzimcong.zzimconginventorycore.common.event.OrderEventType;
import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class OrderSaga {
    private final OrderService orderService;
    private final ProductService productService;
    private final PaymentService paymentService;
    private final KafkaTemplate<String, KafkaMessage> kafkaTemplate;

    @Autowired
    public OrderSaga(OrderService orderService, ProductService productService,
                     PaymentService paymentService,
                     KafkaTemplate<String, KafkaMessage> kafkaTemplate) {
        this.orderService = orderService;
        this.productService = productService;
        this.paymentService = paymentService;
        this.kafkaTemplate = kafkaTemplate;
    }

    public void startOrderSaga(Long userId, OrderRequest request) {
        Order order = orderService.createOrder(userId, request);
        kafkaTemplate.send("order-events", new OrderEvent(order.getId(), OrderEventType.ORDER_CREATED));
    }

    @Transactional
    @KafkaListener(topics = "order-events")
    public void handleOrderEvent(OrderEvent event) {
        Order order = orderService.getOrder(event.getOrderId());
        switch (event.getEventType()) {
            case ORDER_CREATED:
                reserveInventory(order);
                break;
            case INVENTORY_RESERVED:
                processPayment(order);
                break;
            case PAYMENT_PROCESSED:
                completeOrder(order);
                break;
            case SHIPMENT_PREPARING:
            case SHIPMENT_STARTED:
            case SHIPMENT_DELIVERED:
                orderService.updateOrderStatus(order, mapEventTypeToOrderStatus(event.getEventType()));
                break;
            case SAGA_FAILED:
                compensateOrderFailure(order, event.getErrorMessage());
                break;
        }
    }

    private void reserveInventory(Order order) {
        boolean allReserved = order.getOrderItems().stream()
                .allMatch(item -> productService.reserveInventory(item.getProductId(), item.getQuantity()));

        if (allReserved) {
            kafkaTemplate.send("order-events", new OrderEvent(order.getId(), OrderEventType.INVENTORY_RESERVED));
        } else {
            kafkaTemplate.send("order-events", new OrderEvent(order.getId(), OrderEventType.SAGA_FAILED, "재고 예약 실패"));
        }
    }

    private void processPayment(Order order) {
        // Kafka를 통해 결제 서비스에 비동기 요청
        kafkaTemplate.send("payment-requests", new PaymentRequest(order.getId(), order.getPaymentAmount()));
    }

    @KafkaListener(topics = "payment-results")
    public void handlePaymentResult(PaymentResult result) {
        if (result.isSuccess()) {
            kafkaTemplate.send("order-events", new OrderEvent(result.getOrderId(), OrderEventType.PAYMENT_PROCESSED));
        } else {
            kafkaTemplate.send("order-events", new OrderEvent(result.getOrderId(), OrderEventType.SAGA_FAILED, "결제 실패"));
        }
    }

    private void completeOrder(Order order) {
        orderService.completeOrder(order);
        kafkaTemplate.send("order-events", new OrderEvent(order.getId(), OrderEventType.ORDER_COMPLETED));
    }

    private void compensateOrderFailure(Order order, String errorMessage) {
        // 실패 원인에 따라 보상 트랜잭션 수행
        if (errorMessage.contains("재고 예약 실패")) {
            orderService.cancelOrder(order);
        } else if (errorMessage.contains("결제 처리 실패")) {
            order.getOrderItems()
                    .forEach(item -> productService.releaseInventory(item.getProductId(), item.getQuantity()));
            orderService.cancelOrder(order);
        } else if (errorMessage.contains("배송 준비 실패")) {
            paymentService.refundPayment(order);
            order.getOrderItems()
                    .forEach(item -> productService.releaseInventory(item.getProductId(), item.getQuantity()));
            orderService.cancelOrder(order);
        }
    }

    private OrderStatus mapEventTypeToOrderStatus(OrderEventType eventType) {
        return switch (eventType) {
            case SHIPMENT_PREPARING -> OrderStatus.PREPARING_FOR_SHIPMENT;
            case SHIPMENT_STARTED -> OrderStatus.SHIPPING;
            case SHIPMENT_DELIVERED -> OrderStatus.DELIVERED;
            default -> throw new IllegalArgumentException("Unexpected event type: " + eventType);
        };
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/service/ShippingService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.repository.OrderRepository;
import com.zzimcong.zzimconginventorycore.common.event.OrderEvent;
import com.zzimcong.zzimconginventorycore.common.event.OrderEventType;
import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

@Service
@EnableScheduling
public class ShippingService {
    private final OrderRepository orderRepository;
    private final KafkaTemplate<String, KafkaMessage> kafkaTemplate;

    @Autowired
    public ShippingService(OrderRepository orderRepository, KafkaTemplate<String, KafkaMessage> kafkaTemplate) {
        this.orderRepository = orderRepository;
        this.kafkaTemplate = kafkaTemplate;
    }

    @Scheduled(fixedDelay = 60000) // 1분마다 실행
    @Transactional
    public void updateOrdersToPreparing() {
        LocalDateTime oneHourAgo = LocalDateTime.now().minusHours(1);
        List<Order> orders = orderRepository.findByStatusAndCreatedAtBefore(OrderStatus.ORDER_COMPLETED, oneHourAgo);

        for (Order order : orders) {
            order.setStatus(OrderStatus.PREPARING_FOR_SHIPMENT);
            orderRepository.save(order);
            kafkaTemplate.send("order-events", new OrderEvent(order.getId(), OrderEventType.SHIPMENT_PREPARING));
        }
    }

    @Scheduled(cron = "0 0 23 * * ?") // 매일 오후 11시 실행
    @Transactional
    public void updateOrdersToShipping() {
        List<Order> orders = orderRepository.findByStatus(OrderStatus.PREPARING_FOR_SHIPMENT);

        for (Order order : orders) {
            order.setStatus(OrderStatus.SHIPPING);
            orderRepository.save(order);
            kafkaTemplate.send("order-events", new OrderEvent(order.getId(), OrderEventType.SHIPMENT_STARTED));
        }
    }

    @Scheduled(cron = "0 0 11 * * ?") // 매일 오전 11시 실행
    @Transactional
    public void updateOrdersToDelivered() {
        List<Order> orders = orderRepository.findByStatus(OrderStatus.SHIPPING);

        for (Order order : orders) {
            order.setStatus(OrderStatus.DELIVERED);
            orderRepository.save(order);
            kafkaTemplate.send("order-events", new OrderEvent(order.getId(), OrderEventType.SHIPMENT_DELIVERED));
        }
    }

    public void startShipping(Order order) {
        order.setStatus(OrderStatus.SHIPPING);
        orderRepository.save(order);
    }

    public void completeDelivery(Order order) {
        order.setStatus(OrderStatus.DELIVERED);
        orderRepository.save(order);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/service/ProductService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.api.client.ProductServiceClient;
import com.zzimcong.order.application.dto.ReleaseInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryResponse;
import feign.FeignException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

@Service
public class ProductService {
    private final ProductServiceClient productServiceClient;

    @Autowired
    public ProductService(ProductServiceClient productServiceClient) {
        this.productServiceClient = productServiceClient;
    }

    public boolean reserveInventory(Long productId, int quantity) {
        try {
            ReserveInventoryResponse response = productServiceClient.reserveInventory(
                    productId, new ReserveInventoryRequest(quantity));
            return response.isSuccess();
        } catch (FeignException e) {
            if (e.status() == HttpStatus.BAD_REQUEST.value()) {
                // 재고 부족 등의 이유로 예약 실패
                return false;
            }
            throw new RuntimeException("재고 예약 중 오류 발생", e);
        }
    }

    public void releaseInventory(Long productId, int quantity) {
        productServiceClient.releaseInventory(productId, new ReleaseInventoryRequest(quantity));
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/service/OrderService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.application.dto.OrderItemRequest;
import com.zzimcong.order.application.dto.OrderItemResponse;
import com.zzimcong.order.application.dto.OrderRequest;
import com.zzimcong.order.application.dto.OrderResponse;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.repository.OrderRepository;
import com.zzimcong.zzimconginventorycore.common.event.ShippingEvent;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j(topic = "order-service")
@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final PaymentService paymentService;

    @Autowired
    public OrderService(OrderRepository orderRepository, PaymentService paymentService) {
        this.orderRepository = orderRepository;
        this.paymentService = paymentService;
    }

    @KafkaListener(topics = "shipping-events")
    @Transactional
    public void handleShippingEvent(ShippingEvent event) {
        Order order = orderRepository.findById(event.getOrderId())
                .orElseThrow(() -> new RuntimeException("주문을 찾을 수 없습니다: " + event.getOrderId()));

        switch (event.getEventType()) {
            case PREPARING:
                order.setStatus(OrderStatus.PREPARING_FOR_SHIPMENT);
                break;
            case SHIPPING:
                order.setStatus(OrderStatus.SHIPPING);
                break;
            case DELIVERED:
                order.setStatus(OrderStatus.DELIVERED);
                break;
        }

        orderRepository.save(order);
        log.info("주문 상태 업데이트: {}, 주문 ID: {}", order.getStatus(), order.getId());
    }

    @Transactional
    public Order createOrder(Long userId, OrderRequest request) {
        log.info("Creating new order for customer: {}", request.getName());

        // 주문 생성
        Order order = new Order();
        order.setUserId(userId);
        order.setStatus(OrderStatus.CREATED);
        order.setName(request.getName());
        order.setAddr(request.getAddr());
        order.setAddrDetail(request.getAddrDetail());
        order.setZipcode(request.getZipcode());
        order.setPhone(request.getPhone());
        order.setMessage(request.getMessage());
        order.setOrderAmount(request.getOrderAmount());
        order.setPaymentAmount(request.getPaymentAmount());
        order.setPayment(request.getPayment());

        // 주문 아이템 추가
        List<OrderItem> orderItems = new ArrayList<>();
        for (OrderItemRequest itemRequest : request.getItems()) {
            OrderItem item = new OrderItem();
            item.setOrder(order);
            item.setProductId(itemRequest.getProductId());
            item.setQuantity(itemRequest.getQuantity());
            item.setPrice(itemRequest.getPrice());
            orderItems.add(item);
        }
        order.setOrderItems(orderItems);

        Order savedOrder = orderRepository.save(order);

        log.info("Order created with ID: {}", savedOrder.getId());

        return savedOrder;
    }

    @Transactional
    public void updateOrderStatus(Order order, OrderStatus status) {
        order.setStatus(status);
        orderRepository.save(order);
    }

    public Order getOrder(Long orderId) {
        return orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("주문을 찾을 수 없습니다."));
    }

    public OrderResponse getOrderResponse(Long orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("주문을 찾을 수 없습니다."));
        return OrderResponse.createOrderResponse(order, order.getOrderItems());
    }

    public Page<OrderResponse> getOrderList(Pageable pageable) {
        Page<Order> orderPage = orderRepository.findAll(pageable);
        return orderPage.map(
                (order) -> OrderResponse.createOrderResponse(order, order.getOrderItems()));
    }

    public Page<OrderResponse> getUserOrders(Long userId, Pageable pageable) {
        Page<Order> ordersWithItems = orderRepository.findByUserId(userId, pageable);
        List<OrderResponse> orderResponses = ordersWithItems.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
        return new PageImpl<>(orderResponses, pageable, ordersWithItems.getTotalElements());
    }

    private OrderResponse convertToDTO(Order order) {
        OrderResponse dto = new OrderResponse();
        BeanUtils.copyProperties(order, dto);
        dto.setItems(order.getOrderItems().stream()
                .map(this::convertToItemDTO)
                .collect(Collectors.toList()));
        return dto;
    }

    private OrderItemResponse convertToItemDTO(OrderItem item) {
        OrderItemResponse dto = new OrderItemResponse();
        BeanUtils.copyProperties(item, dto);
        return dto;
    }

    public List<OrderItem> getOrderItems(Long orderId) {
        Order order = getOrder(orderId);
        return order.getOrderItems();
    }

    @Transactional
    public void completeOrder(Order order) {
        order.setStatus(OrderStatus.ORDER_COMPLETED);
        orderRepository.save(order);
    }

    @Transactional
    public void cancelOrderByOrderId(Long orderId) {
        Order order = getOrder(orderId);
        cancelOrder(order);
        paymentService.refundPayment(order);
    }

    @Transactional
    public void cancelOrder(Order order) {
        order.setStatus(OrderStatus.CANCELED);
        orderRepository.save(order);
    }

    @Transactional
    public void requestRefund(Long orderId) {
        Order order = getOrder(orderId);
        order.setStatus(OrderStatus.REFUND_REQUESTED);
        orderRepository.save(order);
    }

    @Scheduled(fixedDelay = 86400000) // 매일 실행
    public void autoConfirmOrders() {
        List<Order> ordersToConfirm = getOrdersToConfirm();
        for (Order order : ordersToConfirm) {
            try {
                confirmOrder(order);
            } catch (Exception e) {
                // 로깅 및 예외 처리
            }
        }
    }

    public List<Order> getOrdersToConfirm() {
        LocalDateTime confirmationDate = LocalDateTime.now().minusDays(1);
        return orderRepository.findByStatusAndDeliveredAtBefore(OrderStatus.DELIVERED, confirmationDate);
    }

    @Transactional
    public void confirmOrder(Order order) {
        order.setStatus(OrderStatus.ORDER_CONFIRMED);
        orderRepository.save(order);
    }

    @Scheduled(fixedDelay = 86400000) // 매일 실행
    public void autoRefundOrders() {
        List<Order> ordersToRefund = getOrdersToRefund();
        for (Order order : ordersToRefund) {
            try {
                refundOrder(order);
            } catch (Exception e) {
                // 로깅 및 예외 처리
            }
        }
    }

    public List<Order> getOrdersToRefund() {
        LocalDateTime confirmationDate = LocalDateTime.now().minusDays(1);
        return orderRepository.findByStatusAndDeliveredAtBefore(OrderStatus.REFUND_REQUESTED, confirmationDate);
    }

    @Transactional
    public void refundOrder(Order order) {
        order.setStatus(OrderStatus.REFUND_COMPLETED);
        orderRepository.save(order);
        paymentService.refundPayment(order);
    }

    public boolean isOrderOwnedByUser(Long orderId, Long id) {
        Order order = getOrder(orderId);
        return order.getUserId().equals(id);
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/service/PaymentService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.application.dto.PaymentRequest;
import com.zzimcong.order.application.dto.PaymentResponse;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

import java.util.Random;

@Slf4j(topic = "payment-service")
@Service
public class PaymentService {
    private final KafkaTemplate<String, KafkaMessage> kafkaTemplate;
    private final Random random = new Random();

    @Autowired
    public PaymentService(KafkaTemplate<String, KafkaMessage> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    @KafkaListener(topics = "payment-requests")
    public void processPayment(PaymentRequest request) {
        // 90% 확률로 결제 성공, 10% 확률로 결제 실패 시뮬레이션
        boolean isSuccess = random.nextInt(100) < 90;

        PaymentResult result = new PaymentResult(request.getOrderId(), isSuccess);

        if (isSuccess) {
            log.info("결제 성공: 주문 ID {}", request.getOrderId());
        } else {
            log.info("결제 실패: 주문 ID {}", request.getOrderId());
        }

        // 결제 결과를 Kafka로 전송
        kafkaTemplate.send("payment-results", result);
    }

    public void refundPayment(Order order) {
        // 실제 환불 처리 대신 로그만 남김
        log.info("환불 처리 완료: 주문 ID {}, 금액 {}", order.getId(), order.getPaymentAmount());

        // 환불 결과를 Kafka로 전송
        PaymentResult refundResult = new PaymentResult(order.getId(), true, "REFUNDED");
        kafkaTemplate.send("payment-results", refundResult);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/statemachine/OrderStateMachineFactory.java
--------
package com.zzimcong.order.infrastructure.statemachine;

import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.zzimconginventorycore.common.event.OrderEventType;
import org.springframework.statemachine.StateMachine;
import org.springframework.statemachine.config.StateMachineFactory;
import org.springframework.statemachine.support.DefaultStateMachineContext;
import org.springframework.stereotype.Component;

@Component
public class OrderStateMachineFactory {
    private final StateMachineFactory<OrderStatus, OrderEventType> stateMachineFactory;

    public OrderStateMachineFactory(StateMachineFactory<OrderStatus, OrderEventType> stateMachineFactory) {
        this.stateMachineFactory = stateMachineFactory;
    }

    public StateMachine<OrderStatus, OrderEventType> create(Order order) {
        StateMachine<OrderStatus, OrderEventType> sm = stateMachineFactory.getStateMachine(order.getId().toString());
        sm.stop();
        sm.getStateMachineAccessor().doWithAllRegions(sma -> {
            sma.resetStateMachine(new DefaultStateMachineContext<>(order.getStatus(), null, null, null));
        });
        sm.start();
        return sm;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/statemachine/OrderStateMachineConfig.java
--------
package com.zzimcong.order.infrastructure.statemachine;

import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.zzimconginventorycore.common.event.OrderEventType;
import org.springframework.context.annotation.Configuration;
import org.springframework.statemachine.config.EnableStateMachineFactory;
import org.springframework.statemachine.config.StateMachineConfigurerAdapter;
import org.springframework.statemachine.config.builders.StateMachineStateConfigurer;
import org.springframework.statemachine.config.builders.StateMachineTransitionConfigurer;

import java.util.EnumSet;

@Configuration
@EnableStateMachineFactory
public class OrderStateMachineConfig extends StateMachineConfigurerAdapter<OrderStatus, OrderEventType> {

    @Override
    public void configure(StateMachineStateConfigurer<OrderStatus, OrderEventType> states) throws Exception {
        states
                .withStates()
                .initial(OrderStatus.CREATED)
                .states(EnumSet.allOf(OrderStatus.class));
    }

    @Override
    public void configure(StateMachineTransitionConfigurer<OrderStatus, OrderEventType> transitions) throws Exception {
        transitions
                .withExternal()
                .source(OrderStatus.CREATED).target(OrderStatus.STOCK_RESERVED)
                .event(OrderEventType.INVENTORY_RESERVED)
                .and()
                .withExternal()
                .source(OrderStatus.STOCK_RESERVED).target(OrderStatus.PAYMENT_PROCESSED)
                .event(OrderEventType.PAYMENT_PROCESSED)
                .and()
                .withExternal()
                .source(OrderStatus.PAYMENT_PROCESSED).target(OrderStatus.ORDER_COMPLETED)
                .event(OrderEventType.ORDER_COMPLETED)
                .and()
                .withExternal()
                .source(OrderStatus.ORDER_COMPLETED).target(OrderStatus.PREPARING_FOR_SHIPMENT)
                .event(OrderEventType.SHIPMENT_PREPARING)
                .and()
                .withExternal()
                .source(OrderStatus.PREPARING_FOR_SHIPMENT).target(OrderStatus.SHIPPING)
                .event(OrderEventType.SHIPMENT_STARTED)
                .and()
                .withExternal()
                .source(OrderStatus.SHIPPING).target(OrderStatus.DELIVERED)
                .event(OrderEventType.SHIPMENT_DELIVERED);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/kafka/ShippingProducerListener.java
--------
package com.zzimcong.order.infrastructure.kafka;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.support.ProducerListener;

public class ShippingProducerListener implements ProducerListener<String, Object> {

    private static final Logger logger = LoggerFactory.getLogger(ShippingProducerListener.class);

    @Override
    public void onSuccess(ProducerRecord<String, Object> producerRecord, RecordMetadata recordMetadata) {
        logger.info("Message sent successfully to topic {} partition {} offset {}",
                recordMetadata.topic(), recordMetadata.partition(), recordMetadata.offset());
    }

    @Override
    public void onError(ProducerRecord<String, Object> producerRecord, RecordMetadata recordMetadata, Exception exception) {
        logger.error("Error sending message to topic {} partition {}",
                producerRecord.topic(), producerRecord.partition(), exception);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/kafka/KafkaProducer.java
--------
package com.zzimcong.order.infrastructure.kafka;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.stereotype.Component;

import java.util.concurrent.CompletableFuture;

@Component
public class KafkaProducer<T> {
    private static final Logger logger = LoggerFactory.getLogger(KafkaProducer.class);

    private final KafkaTemplate<String, T> kafkaTemplate;

    public KafkaProducer(KafkaTemplate<String, T> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    public void send(String topic, T payload) {
        logger.info("Sending Kafka message to topic: {} with payload: {}", topic, payload);
        CompletableFuture<SendResult<String, T>> future = kafkaTemplate.send(topic, payload);

        future.whenComplete((result, ex) -> {
            if (ex == null) {
                logger.info("Message sent successfully to topic: {}", topic);
            } else {
                logger.error("Failed to send message to topic: {}", topic, ex);
            }
        });
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/kafka/PaymentEvent.java
--------
package com.zzimcong.order.infrastructure.kafka;

import com.zzimcong.order.domain.entity.PaymentType;
import lombok.Data;
import lombok.Setter;

import java.math.BigDecimal;

@Data
@Setter
public class PaymentEvent {
    private Long orderId;
    private BigDecimal amount;
    private PaymentType payment;
    private boolean success;

    public PaymentEvent(Long orderId, BigDecimal amount, PaymentType payment) {
        this.orderId = orderId;
        this.amount = amount;
        this.payment = payment;
        this.success = false;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/repository/OrderRepository.java
--------
package com.zzimcong.order.domain.repository;

import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;

import java.time.LocalDateTime;
import java.util.List;

public interface OrderRepository extends JpaRepository<Order, Long> {
    List<Order> findByStatus(OrderStatus orderStatus);

    List<Order> findByStatusAndDeliveredAtBefore(OrderStatus orderStatus, LocalDateTime confirmationDate);

    List<Order> findByStatusAndCreatedAtBefore(OrderStatus orderStatus, LocalDateTime oneHourAgo);

    @EntityGraph(attributePaths = "orderItems")
    Page<Order> findByUserId(Long userId, Pageable pageable);
}


--------


File: ./order/src/main/java/com/zzimcong/order/domain/repository/OrderItemRepository.java
--------
package com.zzimcong.order.domain.repository;

import com.zzimcong.order.domain.entity.OrderItem;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface OrderItemRepository extends JpaRepository<OrderItem, Long> {
    List<OrderItem> findByOrderId(Long orderId);
}


--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/PaymentType.java
--------
package com.zzimcong.order.domain.entity;

public enum PaymentType {
    KB, KAKAO, NAVER, KEB, IBK, NH
}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/Order.java
--------
package com.zzimcong.order.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "orders") // 예약어 회피를 위해 복수형 사용
public class Order extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "order_id")
    private Long id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal orderAmount;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal paymentAmount;

    @Enumerated(EnumType.STRING)
    @Column(length = 20)
    private PaymentType payment;

    @Enumerated(EnumType.STRING)
    @Column(length = 30)
    @ColumnDefault("'CREATED'")
    private OrderStatus status = OrderStatus.CREATED;

    @Column(nullable = false)
    private boolean deleted = false;

    @Column(length = 255)
    private String reason;

    @Column(nullable = false, length = 64)
    private String name;

    @Column(nullable = false, length = 255)
    private String addr;

    @Column(nullable = false, length = 255)
    private String addrDetail;

    @Column(nullable = false, length = 10)
    private String zipcode;

    @Column(nullable = false, length = 20)
    private String phone;

    @Column(length = 255)
    private String message;

    private LocalDateTime deliveredAt;

    private LocalDateTime refundRequestedAt;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItem> orderItems = new ArrayList<>();
}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/OrderItem.java
--------
package com.zzimcong.order.domain.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.zzimcong.order.application.dto.OrderItemRequest;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "order_items") // 복수형 사용
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "order_item_id")
    private Long id;

    @Column(name = "product_id", nullable = false)
    private Long productId;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(nullable = false)
    private Integer quantity;

    @JsonIgnore
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    private OrderItem(Order order, OrderItemRequest orderItemRequest) {
        this.productId = orderItemRequest.getProductId();
        this.price = orderItemRequest.getPrice();
        this.quantity = orderItemRequest.getQuantity();
        this.order = order;
    }

    //factory method
    public static OrderItem createOrderItem(Order order, OrderItemRequest orderItemRequest) {
        return new OrderItem(order, orderItemRequest);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/OrderStatus.java
--------
package com.zzimcong.order.domain.entity;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum OrderStatus {
    CREATED("주문 생성됨"),
    STOCK_RESERVED("재고 확보 완료"),
    PAYMENT_PROCESSED("결제 완료"),
    SAGA_FAILED("주문 처리 실패"),
    ORDER_COMPLETED("주문 완료"),
    PREPARING_FOR_SHIPMENT("배송 준비 중"),
    SHIPPING("배송 중"),
    DELIVERED("배송 완료"),
    ORDER_CONFIRMED("주문 확정"),
    CANCELED("취소됨"),
    REFUND_REQUESTED("환불 신청됨"),
    REFUND_COMPLETED("환불 완료됨");

    private final String description;
}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/BaseEntity.java
--------
package com.zzimcong.order.domain.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@Setter
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
public abstract class BaseEntity {

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

}

--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/model/KafkaMessage.java
--------
package com.zzimcong.zzimconginventorycore.common.model;

public interface KafkaMessage {
}


--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/OrderEvent.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@JsonSerialize
@JsonDeserialize
public class OrderEvent implements KafkaMessage {
    private Long orderId;
    private OrderEventType eventType;
    private String errorMessage;

    public OrderEvent(Long orderId, OrderEventType eventType) {
        this.orderId = orderId;
        this.eventType = eventType;
    }
}

--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/InventoryEventType.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

public enum InventoryEventType {
    CHECK, RESERVE, CONFIRM, CANCEL, RESTORE
}

--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/ShippingEvent.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

public class ShippingEvent {
    private Long orderId;
    private ShippingEventType eventType;

    public ShippingEvent(Long orderId, ShippingEventType eventType) {
        this.orderId = orderId;
        this.eventType = eventType;
    }

    public Long getOrderId() {
        return orderId;
    }

    public ShippingEventType getEventType() {
        return eventType;
    }

    public void setOrderId(Long orderId) {
        this.orderId = orderId;
    }

    public void setEventType(ShippingEventType eventType) {
        this.eventType = eventType;
    }
}

--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/InventoryEvent.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

import com.zzimcong.zzimconginventorycore.common.event.InventoryEventType;

import java.util.Objects;

public class InventoryEvent {
    private Long productId;
    private InventoryEventType eventType;
    private int quantity;

    public InventoryEvent() {
    }

    public InventoryEvent(Long productId, InventoryEventType eventType, int quantity) {
        this.productId = productId;
        this.eventType = eventType;
        this.quantity = quantity;
    }

    public Long getProductId() {
        return productId;
    }

    public void setProductId(Long productId) {
        this.productId = productId;
    }

    public InventoryEventType getEventType() {
        return eventType;
    }

    public void setEventType(InventoryEventType eventType) {
        this.eventType = eventType;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        InventoryEvent that = (InventoryEvent) o;
        return quantity == that.quantity &&
                Objects.equals(productId, that.productId) &&
                eventType == that.eventType;
    }

    @Override
    public int hashCode() {
        return Objects.hash(productId, eventType, quantity);
    }

    @Override
    public String toString() {
        return "com.zzimcong.InventoryEvent{" +
                "productId=" + productId +
                ", eventType=" + eventType +
                ", quantity=" + quantity +
                '}';
    }
}

--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/OrderEventType.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

public enum OrderEventType {
    ORDER_CREATED("주문 생성"),
    INVENTORY_RESERVED("재고 예약"),
    PAYMENT_PROCESSED("결제 완료"),
    SHIPMENT_PREPARING("배송 준비 시작"),
    SHIPMENT_STARTED("배송 출발"),
    SHIPMENT_DELIVERED("배송 도착"),
    ORDER_COMPLETED("주문 완료"),
    SAGA_FAILED("주문 실패");

    private final String description;

    OrderEventType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}

--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/ShippingEventType.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

public enum ShippingEventType {
    PREPARING("배송 준비 중"),
    SHIPPING("배송 중"),
    DELIVERED("배송 완료");

    private String description;

    ShippingEventType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}

--------


File: ./api-gateway/src/test/java/com/zzimcong/apigateway/ApiGatewayApplicationTests.java
--------
package com.zzimcong.apigateway;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApiGatewayApplicationTests {

    @Test
    void contextLoads() {
    }

}


--------


File: ./api-gateway/src/main/java/com/zzimcong/apigateway/dto/Response.java
--------
package com.zzimcong.apigateway.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Builder;
import org.springframework.http.HttpStatus;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public record Response<T>(
        Integer code,
        String message,
        T data
) {
    public Response {
        if (code == null) {
            code = HttpStatus.OK.value();
        }
        if (message == null) {
            message = HttpStatus.OK.getReasonPhrase();
        }
    }
}

--------


File: ./api-gateway/src/main/java/com/zzimcong/apigateway/util/JwtUtil.java
--------
package com.zzimcong.apigateway.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.security.Key;

@Component
public class JwtUtil {

    private final Key key;

    public JwtUtil(@Value("${jwt.secret}") String secret) {
        this.key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * JWT 토큰의 유효성을 검사합니다.
     *
     * @param token 검사할 JWT 토큰
     * @return 토큰이 유효하면 true, 그렇지 않으면 false
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            // 토큰 검증 실패 시 로그 출력
            // log.error("Invalid JWT token: {}", e.getMessage());
            return false;
        }
    }

    /**
     * JWT 토큰에서 userId를 추출합니다.
     *
     * @param token JWT 토큰
     * @return 추출된 userId
     */
    public String extractUserId(String token) {
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
        return claims.getSubject();
    }
}

--------


File: ./api-gateway/src/main/java/com/zzimcong/apigateway/ApiGatewayApplication.java
--------
package com.zzimcong.apigateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}


--------


File: ./api-gateway/src/main/java/com/zzimcong/apigateway/filter/JwtAuthFilter.java
--------
package com.zzimcong.apigateway.filter;

import com.zzimcong.apigateway.util.JwtUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Slf4j(topic = "JwtAuthFilter")
@Component
public class JwtAuthFilter extends AbstractGatewayFilterFactory<JwtAuthFilter.Config> {

    private final JwtUtil jwtUtil;

    public JwtAuthFilter(JwtUtil jwtUtil) {
        super(Config.class);
        this.jwtUtil = jwtUtil;
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            String token = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);

            // JWT 토큰이 없거나 "Bearer " 접두사가 없는 경우
            if (token == null || !token.startsWith("Bearer ")) {
                return onError(exchange, "인증 토큰이 없거나 잘못되었습니다.", HttpStatus.UNAUTHORIZED);
            }

            // "Bearer " 접두사 제거
            token = token.substring(7);

            // 토큰 유효성 검사
            if (!jwtUtil.validateToken(token)) {
                return onError(exchange, "유효하지 않은 JWT 토큰입니다.", HttpStatus.UNAUTHORIZED);
            }

            // userId 추출 및 요청 속성에 저장
            String userId = jwtUtil.extractUserId(token);
            ServerWebExchange modifiedExchange = exchange.mutate()
                    .request(exchange.getRequest().mutate()
                            .header("X-Auth-User-ID", userId)
                            .build())
                    .build();

            return chain.filter(modifiedExchange);
        };
    }

    private Mono<Void> onError(ServerWebExchange exchange, String err, HttpStatus httpStatus) {
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(httpStatus);
        response.getHeaders().add("Content-Type", "application/json;charset=UTF-8");
        String responseBody = String.format("{\"error\": \"%s\"}", err);
        log.error("Authentication error: {}", err);
        return response.writeWith(Mono.just(response.bufferFactory().wrap(responseBody.getBytes())));
    }

    public static class Config {
        // 필요한 경우 설정 속성을 추가할 수 있습니다.
    }
}

--------


File: ./eureka-server/src/test/java/com/zzimcong/eurekaserver/EurekaServerApplicationTests.java
--------
package com.zzimcong.eurekaserver;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class EurekaServerApplicationTests {

    @Test
    void contextLoads() {
    }

}


--------


File: ./eureka-server/src/main/java/com/zzimcong/eurekaserver/EurekaServerApplication.java
--------
package com.zzimcong.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}


--------


File: ./auth/src/test/java/com/zzimcong/user/UserApplicationTests.java
--------
package com.zzimcong.user;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class UserApplicationTests {

    @Test
    void contextLoads() {
    }

}


--------


File: ./auth/src/test/java/com/zzimcong/user/EmailSenderTest.java
--------
package com.zzimcong.user;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.mail.MailException;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;

@SpringBootTest
public class EmailSenderTest {

    @Autowired
    private JavaMailSender mailSender;

    @Test
    public void testSendEmail() {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom("zzimcong99@gmail.com");
        message.setTo("recipient@example.com");
        message.setSubject("Test Subject");
        message.setText("Test Body");

        try {
            mailSender.send(message);
            System.out.println("Test email sent successfully");
        } catch (MailException e) {
            System.err.println("Failed to send test email. Error: " + e.getMessage());
            e.printStackTrace();

            if (e.getCause() != null) {
                System.err.println("Root cause: " + e.getCause().getMessage());
                e.getCause().printStackTrace();
            }
        }
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/util/KeyManagementUtil.java
--------
package com.zzimcong.auth.common.util;

import lombok.Getter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

@Component
public class KeyManagementUtil {

    private final Environment environment;
    @Getter
    private String encryptionKey;

    @Autowired
    public KeyManagementUtil(Environment environment) {
        this.environment = environment;
        initEncryptionKey();
    }

    private void initEncryptionKey() {
        // 시스템 환경 변수에서 먼저 확인
        encryptionKey = System.getenv("ENCRYPTION_KEY");

        // 시스템 환경 변수에 없으면 스프링 Environment에서 확인
        if (encryptionKey == null || encryptionKey.isEmpty()) {
            encryptionKey = environment.getProperty("encryption.key");
        }

        // 둘 다 없으면 예외 발생
        if (encryptionKey == null || encryptionKey.isEmpty()) {
            throw new IllegalStateException("ENCRYPTION_KEY가 설정되지 않았습니다.");
        }
    }

}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/util/EmailVerificationToken.java
--------
package com.zzimcong.auth.common.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@AllArgsConstructor
public class EmailVerificationToken {
    private String token;
    private String email;
    private LocalDateTime expiryDate;
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/util/RedisUtil.java
--------
package com.zzimcong.auth.common.util;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Service
@RequiredArgsConstructor
public class RedisUtil {
    private final StringRedisTemplate redisTemplate;//Redis에 접근하기 위한 Spring의 Redis 템플릿 클래스

    public String getData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 가져오는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        return valueOperations.get(key);
    }

    public void setData(String key, String value) {//지정된 키(key)에 값을 저장하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        valueOperations.set(key, value);
    }

    public void setDataExpire(String key, String value, long duration) {//지정된 키(key)에 값을 저장하고, 지정된 시간(duration) 후에 데이터가 만료되도록 설정하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        Duration expireDuration = Duration.ofSeconds(duration);
        valueOperations.set(key, value, expireDuration);
    }

    public void deleteData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 삭제하는 메서드
        redisTemplate.delete(key);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/util/AESUtil.java
--------
package com.zzimcong.auth.common.util;

import com.zzimcong.auth.common.exception.ErrorCode;
import com.zzimcong.auth.common.exception.InternalServerError;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Slf4j(topic = "AESUtil")
@Component
public class AESUtil {
    private static final String ALGORITHM = "AES";
    private static final String CIPHER_INSTANCE = "AES/ECB/PKCS5Padding";  // 명시적으로 모드와 패딩 지정

    private final KeyManagementUtil keyManagementUtil;

    @Autowired
    public AESUtil(KeyManagementUtil keyManagementUtil) {
        this.keyManagementUtil = keyManagementUtil;
    }

    public String encrypt(String data) {
        try {
            Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE);
            cipher.init(Cipher.ENCRYPT_MODE, getKeySpec());
            byte[] encryptedData = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(encryptedData);
        } catch (Exception e) {
            log.error("Encryption failed", e);
            throw new InternalServerError(ErrorCode.ENCRYPTION_FAILED);
        }
    }

    public String decrypt(String encryptedData) {
        try {
            Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE);
            cipher.init(Cipher.DECRYPT_MODE, getKeySpec());
            byte[] decryptedData = cipher.doFinal(Base64.getDecoder().decode(encryptedData));
            return new String(decryptedData, StandardCharsets.UTF_8);
        } catch (Exception e) {
            log.error("Decryption failed", e);
            throw new InternalServerError(ErrorCode.DECRYPTION_FAILED);
        }
    }

    private SecretKeySpec getKeySpec() {
        String key = keyManagementUtil.getEncryptionKey();
        byte[] decodedKey = Base64.getDecoder().decode(key);
        return new SecretKeySpec(decodedKey, ALGORITHM);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/UserInfo.java
--------
package com.zzimcong.auth.common;

import lombok.Data;

@Data
public class UserInfo {
    private Long id;
    private String username;
    private String role;
    // 필요한 다른 필드들...
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/exception/ErrorCode.java
--------
package com.zzimcong.auth.common.exception;

import lombok.Getter;

@Getter
public enum ErrorCode {
    // BadRequestException (400)
    INVALID_INPUT("잘못된 입력입니다."),
    INVALID_VERIFICATION_CODE("잘못된 인증 코드입니다."),
    EMAIL_VERIFICATION_FAILED("이메일 인증에 실패했습니다."),

    // UnauthorizedException (401)
    INVALID_CREDENTIALS("잘못된 인증 정보입니다."),
    INVALID_TOKEN("유효하지 않은 토큰입니다."),
    EXPIRED_TOKEN("만료된 토큰입니다."),
    TOKEN_NOT_FOUND("토큰을 찾을 수 없습니다."),

    // NotFoundException (404)
    RESOURCE_NOT_FOUND("요청한 리소스를 찾을 수 없습니다."),
    USER_NOT_FOUND("사용자를 찾을 수 없습니다."),

    // MethodNotAllowedException (405)
    METHOD_NOT_ALLOWED("허용되지 않은 HTTP 메서드입니다."),

    // ConflictException (409)
    DUPLICATE_EMAIL("이미 존재하는 이메일입니다."),

    // InternalServerErrorException (500)
    ENCRYPTION_FAILED("암호화에 실패했습니다."),
    DECRYPTION_FAILED("복호화에 실패했습니다."),
    RESOURCE_LOAD_FAILED("내부 리소스 로딩에 실패했습니다."),
    EMAIL_SEND_FAILED("이메일 전송에 실패했습니다."),
    INTERNAL_SERVER_ERROR("서버 내부 오류가 발생했습니다.");

    private final String message;

    ErrorCode(String message) {
        this.message = message;
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/exception/ForbiddenException.java
--------
package com.zzimcong.auth.common.exception;

public class ForbiddenException extends BaseException {
    public ForbiddenException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ForbiddenException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/exception/UnauthorizedException.java
--------
package com.zzimcong.auth.common.exception;

public class UnauthorizedException extends BaseException {
    public UnauthorizedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public UnauthorizedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/exception/ConflictException.java
--------
package com.zzimcong.auth.common.exception;

public class ConflictException extends BaseException {
    public ConflictException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ConflictException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/exception/MethodNotAllowedException.java
--------
package com.zzimcong.auth.common.exception;

public class MethodNotAllowedException extends BaseException {
    public MethodNotAllowedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public MethodNotAllowedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/exception/GlobalExceptionHandler.java
--------
package com.zzimcong.auth.common.exception;

import com.zzimcong.auth.api.response.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j(topic = "GLOBAL_EXCEPTION_HANDLER")
@ControllerAdvice
public class GlobalExceptionHandler {
    // BadRequestException (400)
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    // UnauthorizedException (401)
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(UnauthorizedException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.UNAUTHORIZED, request.getRequestURI());
    }

    // ForbiddenException (403)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbiddenException(ForbiddenException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.FORBIDDEN, request.getRequestURI());
    }

    // NotFoundException (404)
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.NOT_FOUND, request.getRequestURI());
    }

    // MethodNotAllowedException (405)
    @ExceptionHandler(MethodNotAllowedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowedException(MethodNotAllowedException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.METHOD_NOT_ALLOWED, request.getRequestURI());
    }

    // ConflictException (409)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(ConflictException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.CONFLICT, request.getRequestURI());
    }

    // InternalServerErrorException (500)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllException(ConflictException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
    }

    // Create ErrorResponse
    private ResponseEntity<ErrorResponse> createErrorResponse(BaseException ex, HttpStatus status, String path) {
        logException(ex, status, path);
        ErrorResponse errorResponse = ErrorResponse.of(status, ex, path);
        return new ResponseEntity<>(errorResponse, status);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        log.error(
                "Exception occurred:: Error Code: {}, HTTP Status: {}, Message: {}, Path: {}",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage(),
                path,
                ex
        );
    }
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/common/exception/BadRequestException.java
--------
package com.zzimcong.auth.common.exception;

public class BadRequestException extends BaseException {
    public BadRequestException(ErrorCode errorCode) {
        super(errorCode);
    }

    public BadRequestException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/exception/InternalServerError.java
--------
package com.zzimcong.auth.common.exception;

public class InternalServerError extends BaseException {
    public InternalServerError(ErrorCode errorCode) {
        super(errorCode);
    }

    public InternalServerError(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/common/exception/BaseException.java
--------
package com.zzimcong.auth.common.exception;

public class BaseException extends RuntimeException {
    private final ErrorCode errorCode;
    private final String message;

    public BaseException(ErrorCode errorCode) {
        this(errorCode, errorCode.getMessage());
    }

    public BaseException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.message = message;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    @Override
    public String getMessage() {
        return message;
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/common/exception/NotFoundException.java
--------
package com.zzimcong.auth.common.exception;

public class NotFoundException extends BaseException {
    public NotFoundException(ErrorCode errorCode) {
        super(errorCode);
    }

    public NotFoundException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/AuthApplication.java
--------
package com.zzimcong.auth;

import com.zzimcong.auth.infrastructure.config.EmailProperties;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

@SpringBootApplication
@EnableConfigurationProperties(EmailProperties.class)
public class AuthApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthApplication.class, args);
    }
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/api/response/ApiResponse.java
--------
package com.zzimcong.auth.api.response;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/api/response/ErrorResponse.java
--------
package com.zzimcong.auth.api.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.zzimcong.auth.common.exception.BaseException;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {
    private int status;
    private String message;
    private String errorCode;
    private LocalDateTime timestamp;
    private String path;

    public static ErrorResponse of(HttpStatus status, BaseException ex, String path) {
        ErrorResponse response = new ErrorResponse();
        response.setStatus(status.value());
        response.setMessage(ex.getMessage());
        response.setErrorCode(ex.getErrorCode().name());
        response.setTimestamp(LocalDateTime.now());
        response.setPath(path);
        return response;
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/api/controller/EmailVerificationsController.java
--------
package com.zzimcong.auth.api.controller;

import com.zzimcong.auth.application.dto.EmailCheckDto;
import com.zzimcong.auth.application.dto.EmailRequestDto;
import com.zzimcong.auth.application.service.EmailVerificationService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j(topic = "EMAIL_VERIFICATIONS_CONTROLLER")
@RestController
@RequestMapping("/api/v1/email-verifications")
public class EmailVerificationsController {
    private final EmailVerificationService emailVerificationService;

    @Autowired
    public EmailVerificationsController(EmailVerificationService emailVerificationService) {
        this.emailVerificationService = emailVerificationService;
    }

    @PostMapping("/send")
    public ResponseEntity<String> sendVerificationEmail(@RequestBody @Valid EmailRequestDto emailDto) {
        log.info("인증 이메일 전송 요청: {}", emailDto.getEmail());
        emailVerificationService.sendVerificationEmail(emailDto.getEmail());
        return ResponseEntity.ok("인증 이메일이 성공적으로 전송되었습니다.");
    }

    @PostMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestBody @Valid EmailCheckDto emailCheckResponse) {
        log.info("이메일 인증 요청: {}", emailCheckResponse.getEmail());
        String token = emailVerificationService.verifyEmailAndGenerateToken(emailCheckResponse.getEmail(), emailCheckResponse.getAuthNum());
        return ResponseEntity.ok(token);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/api/controller/AuthController.java
--------
package com.zzimcong.auth.api.controller;

import com.zzimcong.auth.api.response.ApiResponse;
import com.zzimcong.auth.application.dto.*;
import com.zzimcong.auth.application.service.AuthService;
import com.zzimcong.auth.application.service.EmailVerificationService;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j(topic = "AUTH_CONTROLLER")
@RestController
@RequestMapping("/api/v1/auth")
public class AuthController {
    private final AuthService authService;
    private final EmailVerificationService emailVerificationService;

    @Autowired
    public AuthController(AuthService authService, EmailVerificationService emailVerificationService) {
        this.authService = authService;
        this.emailVerificationService = emailVerificationService;
    }

    // 이메일 중복 확인
    @PostMapping("/check-email")
    public ResponseEntity<?> checkEmailAvailability(@RequestBody EmailRequestDto emailRequest) {
        boolean isAvailable = emailVerificationService.isEmailAvailable(emailRequest.getEmail());
        String message = isAvailable ? "사용 가능한 이메일입니다." : "이미 사용 중인 이메일입니다.";
        return ResponseEntity.ok(ApiResponse.success(null, message));
    }

    @PostMapping("/signup")
    public ResponseEntity<?> signUp(@RequestBody @Valid SignupRequestDto signupRequest,
                                    @RequestParam String token) {
        authService.signUp(signupRequest, token);
        return ResponseEntity.ok(ApiResponse.success(null, "회원가입이 완료되었습니다."));
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequestDto loginRequest, HttpServletRequest request) {
        AuthResultDto authResponse = authService.login(loginRequest);
        return ResponseEntity.ok(ApiResponse.success(authResponse, "로그인에 성공했습니다."));
    }

    @PostMapping("/logout")
    public ResponseEntity<?> logout(@RequestBody LogoutRequest logoutRequest) {
        authService.logout(logoutRequest.getAccessToken());
        return ResponseEntity.ok(ApiResponse.success(null, "로그아웃되었습니다."));
    }

    // refreshToken을 이용한 accessToken 재발급
    @PostMapping("/refresh")
    public ResponseEntity<?> refreshToken(@RequestBody RefreshRequestDto refreshRequest) {
        String refreshToken = refreshRequest.getRefreshToken();
        String accessToken = authService.refreshToken(refreshToken);
        return ResponseEntity.ok(ApiResponse.success(accessToken, "토큰이 갱신되었습니다."));
    }

    private String extractRefreshTokenFromCookie(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("refreshToken".equals(cookie.getName())) {
                    return cookie.getValue();
                }
            }
        }
        return null;
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/api/controller/UserController.java
--------
package com.zzimcong.auth.api.controller;

import com.zzimcong.auth.application.dto.EmailRequestDto;
import com.zzimcong.auth.application.dto.UserModifyRequestDto;
import com.zzimcong.auth.application.dto.UserResponseDto;
import com.zzimcong.auth.application.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j(topic = "USER_CONTROLLER")
@RestController
@RequestMapping("/api/v1/users")
public class UserController {
    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }

    //회원정보
    @GetMapping
    public ResponseEntity<UserResponseDto> getUserByEmail(@RequestBody EmailRequestDto emailRequest) {
        UserResponseDto user = userService.getUserByEmail(emailRequest.getEmail());
        return ResponseEntity.ok(user);
    }

    //회원정보 수정
    @PutMapping
    public ResponseEntity<UserResponseDto> updateUser(@RequestBody UserModifyRequestDto userModifyRequest) {
        UserResponseDto updatedUser = userService.updateUser(userModifyRequest);
        return ResponseEntity.ok(updatedUser);
    }

    //회원탈퇴
    @PostMapping("/signout")
    public ResponseEntity<UserResponseDto> signoutUser(@RequestBody EmailRequestDto emailRequest) {
        UserResponseDto signoutUser = userService.signoutUser(emailRequest.getEmail());
        return ResponseEntity.ok(signoutUser);
    }
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/application/dto/AuthResultDto.java
--------
package com.zzimcong.auth.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class AuthResultDto {
    private String accessToken;
    private String refreshToken;
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/application/dto/UserResponseDto.java
--------
package com.zzimcong.auth.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class UserResponseDto {
    private Long id;
    private String email;
    private String username;
    private String phone;
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/application/dto/LogoutRequest.java
--------
package com.zzimcong.auth.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LogoutRequest {
    private String accessToken;
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/application/dto/LoginRequestDto.java
--------
package com.zzimcong.auth.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LoginRequestDto {
    private String email;
    private String password;
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/application/dto/EmailCheckDto.java
--------
package com.zzimcong.auth.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import lombok.Data;

@Data
public class EmailCheckDto {
    @Email
    @NotEmpty(message = "이메일을 입력해 주세요")
    private String email;

    @NotEmpty(message = "인증 번호를 입력해 주세요")
    private String authNum;

}

--------


File: ./auth/src/main/java/com/zzimcong/auth/application/dto/EmailRequestDto.java
--------
package com.zzimcong.auth.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class EmailRequestDto {
    //1. @기호를 포함해야 한다.
    //2. @기호를 기준으로 이메일 주소를 이루는 로컬호스트와 도메인 파트가 존재해야 한다.
    //3. 도메인 파트는 최소하나의 점과 그 뒤에 최소한 2개의 알파벳을 가진다
    @Email(message = "이메일 형식이 올바르지 않습니다.")
    @NotEmpty(message = "이메일을 입력해 주세요")
    private String email;
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/application/dto/UserModifyRequestDto.java
--------
package com.zzimcong.auth.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class UserModifyRequestDto {
    private String email;
    private String username;
    private String phone;
    private String password;
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/application/dto/SignupRequestDto.java
--------
package com.zzimcong.auth.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SignupRequestDto {
    @NotBlank(message = "이메일은 필수 입력 값입니다.")
    @Email(message = "이메일 형식이 아닙니다.")
    private String email;

    @NotBlank(message = "이름은 필수 입력 값입니다.")
    private String name;

    @NotBlank(message = "전화번호는 필수 입력 값입니다.")
    private String phone;

    @NotBlank(message = "비밀번호는 필수 입력 값입니다.")
    private String password;
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/application/dto/RefreshRequestDto.java
--------
package com.zzimcong.auth.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class RefreshRequestDto {
    private String refreshToken;
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/application/service/CookieService.java
--------
package com.zzimcong.auth.application.service;

import com.zzimcong.auth.infrastructure.config.RefreshTokenCookieProperties;
import jakarta.servlet.http.Cookie;
import org.springframework.stereotype.Service;

@Service
public class CookieService {

    private final RefreshTokenCookieProperties refreshTokenCookieProperties;

    public CookieService(RefreshTokenCookieProperties refreshTokenCookieProperties) {
        this.refreshTokenCookieProperties = refreshTokenCookieProperties;
    }

    public Cookie createRefreshTokenCookie(String refreshToken) {
        Cookie cookie = new Cookie(refreshTokenCookieProperties.getName(), refreshToken);
        cookie.setHttpOnly(refreshTokenCookieProperties.isHttpOnly());
        cookie.setSecure(refreshTokenCookieProperties.isSecure());
        cookie.setPath(refreshTokenCookieProperties.getPath());
        cookie.setMaxAge(refreshTokenCookieProperties.getMaxAge());
        return cookie;
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/application/service/UserService.java
--------
package com.zzimcong.auth.application.service;

import com.zzimcong.auth.application.dto.SignupRequestDto;
import com.zzimcong.auth.application.dto.UserModifyRequestDto;
import com.zzimcong.auth.application.dto.UserResponseDto;
import com.zzimcong.auth.common.exception.ConflictException;
import com.zzimcong.auth.common.exception.ErrorCode;
import com.zzimcong.auth.common.exception.NotFoundException;
import com.zzimcong.auth.common.util.AESUtil;
import com.zzimcong.auth.domain.entity.User;
import com.zzimcong.auth.domain.mapper.UserMapper;
import com.zzimcong.auth.domain.repository.UserRepository;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Slf4j(topic = "USER_SERVICE")
@Service
public class UserService {
    private final UserRepository userRepository;
    private final UserMapper userMapper;
    private final AESUtil aesUtil;

    @Autowired
    public UserService(UserRepository userRepository, UserMapper userMapper, AESUtil aesUtil) {
        this.userRepository = userRepository;
        this.userMapper = userMapper;
        this.aesUtil = aesUtil;
    }

    //이메일 중복 체크
    public boolean checkEmailAvailability(String email) {
        return !userRepository.existsByEmail(aesUtil.encrypt(email));
    }

    //유저 생성
    public User createUser(SignupRequestDto signupRequest) {
        if (userRepository.existsByEmail(aesUtil.encrypt(signupRequest.getEmail()))) {
            throw new ConflictException(ErrorCode.DUPLICATE_EMAIL);
        }
        User user = userMapper.toEntity(signupRequest);
        return userRepository.save(user);
    }

    //유저 조회
    public UserResponseDto getUserByEmail(String email) {
        User user = userRepository.findByEmail(aesUtil.encrypt(email))
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        return userMapper.toDto(user);
    }

    public UserResponseDto getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        return userMapper.toDto(user);
    }

    //유저 수정
    @Transactional
    public UserResponseDto updateUser(UserModifyRequestDto userModifyRequest) {
        User findUser = userRepository.findByEmail(aesUtil.encrypt(userModifyRequest.getEmail()))
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        findUser = userMapper.updateFromDto(findUser, userModifyRequest);
        User updatedUser = userRepository.save(findUser);
        return userMapper.toDto(updatedUser);
    }

    //유저 삭제
    public UserResponseDto signoutUser(String email) {
        User findUser = userRepository.findByEmail(aesUtil.encrypt(email))
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        findUser.setSignout(true);
        User signoutUser = userRepository.save(findUser);
        return userMapper.toDto(signoutUser);
    }
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/application/service/AuthService.java
--------
package com.zzimcong.auth.application.service;

import com.zzimcong.auth.application.dto.AuthResultDto;
import com.zzimcong.auth.application.dto.LoginRequestDto;
import com.zzimcong.auth.application.dto.SignupRequestDto;
import com.zzimcong.auth.common.exception.ErrorCode;
import com.zzimcong.auth.common.exception.UnauthorizedException;
import com.zzimcong.auth.infrastructure.security.jwt.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

@Slf4j(topic = "AUTH_SERVICE")
@Service
public class AuthService {
    private final TokenService tokenService;
    private final UserService userService;
    private final EmailVerificationService emailVerificationService;
    private final JwtUtil jwtUtil;
    private final AuthenticationManager authenticationManager;

    public AuthService(TokenService tokenService,
                       UserService userService,
                       EmailVerificationService emailVerificationService,
                       JwtUtil jwtUtil,
                       AuthenticationManager authenticationManager) {
        this.tokenService = tokenService;
        this.userService = userService;
        this.emailVerificationService = emailVerificationService;
        this.jwtUtil = jwtUtil;
        this.authenticationManager = authenticationManager;
    }

    public void signUp(SignupRequestDto signupRequest, String token) {
        emailVerificationService.validateTokenForRegistration(signupRequest.getEmail(), token);
        userService.createUser(signupRequest);
    }

    public AuthResultDto login(LoginRequestDto requestDto) {
        try {
            Authentication authentication = authenticateUser(requestDto);
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            Long id = Long.parseLong(userDetails.getUsername());
            return generateAuthResultDto(id);
        } catch (AuthenticationException e) {
            throw new UnauthorizedException(ErrorCode.INVALID_CREDENTIALS, "잘못된 이메일 또는 비밀번호입니다.");
        }
    }

    public void logout(String accessToken) {
        try {
            if (!jwtUtil.validateToken(accessToken)) {
                throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
            }
            Long id = jwtUtil.extractId(accessToken);
            tokenService.deleteRefreshToken(String.valueOf(id));
        } catch (ExpiredJwtException e) {
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }
    }

    public String refreshToken(String refreshToken) {
        if (refreshToken == null) {
            throw new UnauthorizedException(ErrorCode.TOKEN_NOT_FOUND);
        }
        try {
            if (!jwtUtil.validateToken(refreshToken)) {
                throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
            }
            Long id = jwtUtil.extractId(refreshToken);
            userService.getUserById(id);
            return jwtUtil.generateAccessToken(id);
        } catch (ExpiredJwtException e) {
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }
    }

    private Authentication authenticateUser(LoginRequestDto requestDto) {
        return authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(requestDto.getEmail(), requestDto.getPassword())
        );
    }

    private AuthResultDto generateAuthResultDto(Long id) {
        String accessToken = jwtUtil.generateAccessToken(id);
        String refreshToken = jwtUtil.generateRefreshToken(id);
        tokenService.storeRefreshToken(String.valueOf(id), refreshToken);
        return new AuthResultDto(accessToken, refreshToken);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/application/service/EmailVerificationService.java
--------
package com.zzimcong.auth.application.service;

import com.zzimcong.auth.common.exception.ConflictException;
import com.zzimcong.auth.common.exception.ErrorCode;
import com.zzimcong.auth.common.exception.UnauthorizedException;
import com.zzimcong.auth.common.util.EmailVerificationToken;
import com.zzimcong.auth.common.util.RedisUtil;
import com.zzimcong.auth.infrastructure.config.EmailProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j(topic = "EMAIL_VERIFICATION_SERVICE")
@Service
public class EmailVerificationService {
    private final Set<EmailVerificationToken> emailVerificationTokens =
            Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final EmailProperties emailProperties;
    private final EmailService emailService;
    private final UserService userService;
    private final RedisUtil redisUtil;

    public EmailVerificationService(EmailProperties emailProperties, EmailService emailService, UserService userService, RedisUtil redisUtil) {
        this.emailProperties = emailProperties;
        this.emailService = emailService;
        this.userService = userService;
        this.redisUtil = redisUtil;
    }

    public void sendVerificationEmail(String email) {
        if (!isEmailAvailable(email)) {
            log.warn("사용할 수 없는 이메일입니다: {}", email);
            throw new ConflictException(ErrorCode.DUPLICATE_EMAIL);
        }
        String verificationCode = emailService.generateVerificationCode();
        emailService.sendVerificationEmail(email, verificationCode);
        storeVerificationCode(verificationCode, email);
        log.info("인증 이메일 전송: {}", email);
    }

    public boolean isEmailAvailable(String email) {
        return userService.checkEmailAvailability(email);
    }

    private void storeVerificationCode(String code, String email) {
        redisUtil.setDataExpire(code, email,
                emailProperties.getVerification().getCode().getExpiry().getSeconds());
    }

    public String verifyEmailAndGenerateToken(String email, String verificationCode) {
        if (!verifyEmailCode(email, verificationCode)) {
            throw new UnauthorizedException(ErrorCode.INVALID_VERIFICATION_CODE);
        }
        String token = UUID.randomUUID().toString();
        EmailVerificationToken verificationToken =
                new EmailVerificationToken(token, email, LocalDateTime.now().plusMinutes(
                        emailProperties.getVerification().getToken().getExpiry().getMinutes()));
        emailVerificationTokens.add(verificationToken);
        log.info("이메일 인증 성공 및 토큰 생성: {}", email);
        return token;
    }

    private boolean verifyEmailCode(String email, String code) {
        String storedEmail = redisUtil.getData(code);
        return storedEmail != null && storedEmail.equals(email);
    }

    public void validateTokenForRegistration(String email, String token) {
        EmailVerificationToken verificationToken = emailVerificationTokens.stream()
                .filter(t -> t.getToken().trim().equalsIgnoreCase(token.trim())
                        && t.getEmail().trim().equalsIgnoreCase(email.trim()))
                .findFirst()
                .orElseThrow(() -> new UnauthorizedException(ErrorCode.INVALID_TOKEN));

        if (LocalDateTime.now().isAfter(verificationToken.getExpiryDate())) {
            emailVerificationTokens.remove(verificationToken);
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }

        emailVerificationTokens.remove(verificationToken);
    }

    @Scheduled(fixedRate = 60000) // 1분마다 실행
    public void cleanupExpiredTokens() {
        emailVerificationTokens.removeIf(token -> LocalDateTime.now().isAfter(token.getExpiryDate()));
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/application/service/EmailService.java
--------
package com.zzimcong.auth.application.service;

import com.zzimcong.auth.common.exception.ErrorCode;
import com.zzimcong.auth.common.exception.InternalServerError;
import com.zzimcong.auth.infrastructure.config.EmailProperties;
import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import org.springframework.util.StreamUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Random;

@Slf4j(topic = "EMAIL_SERVICE")
@Service
@RequiredArgsConstructor
public class EmailService {
    private final EmailProperties emailProperties;
    private final JavaMailSender mailSender;
    private final ResourceLoader resourceLoader;

    public String generateVerificationCode() {
        Random random = new Random();
        return String.format("%0" + emailProperties.getVerification().getCode().getLength() + "d",
                random.nextInt((int) Math.pow(10, emailProperties.getVerification().getCode().getLength())));
    }

    private String prepareEmailContent(String verificationCode) {
        try {
            String template = loadEmailTemplate();
            return template.replace("${verificationCode}", verificationCode);
        } catch (IOException e) {
            log.error("Failed to load email template", e);
            throw new InternalServerError(ErrorCode.RESOURCE_LOAD_FAILED,
                    "이메일 템플릿 로딩에 실패했습니다.");
        }
    }

    private String loadEmailTemplate() throws IOException {
        Resource resource = resourceLoader.getResource(emailProperties.getTemplate().getPath());
        return StreamUtils.copyToString(resource.getInputStream(), StandardCharsets.UTF_8);
    }

    public void sendVerificationEmail(String toEmail, String verificationCode) {
        try {
            String content = prepareEmailContent(verificationCode);
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8");

            helper.setFrom(emailProperties.getSender());
            helper.setTo(toEmail);
            helper.setSubject(emailProperties.getSubject());
            helper.setText(content, true);

            mailSender.send(message);
            log.info("인증 메일이 성공적으로 전송되었습니다: {}", toEmail);
        } catch (MessagingException e) {
            log.error("인증 메일 전송에 실패했습니다: {}", toEmail, e);
            throw new InternalServerError(ErrorCode.EMAIL_SEND_FAILED,
                    "인증 메일 전송에 실패했습니다.");
        }
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/application/service/TokenService.java
--------
package com.zzimcong.auth.application.service;

import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
public class TokenService {
    private final RedisTemplate<String, String> redisTemplate;

    public TokenService(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public void storeRefreshToken(String username, String refreshToken) {
        redisTemplate.opsForValue().set(username, refreshToken);
        redisTemplate.expire(username, 7, TimeUnit.DAYS);
    }

    public void deleteRefreshToken(String username) {
        redisTemplate.delete(username);
    }

    public String getRefreshToken(String username) {
        return redisTemplate.opsForValue().get(username);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/application/service/UserDetailsServiceImpl.java
--------
package com.zzimcong.auth.application.service;

import com.zzimcong.auth.common.exception.ErrorCode;
import com.zzimcong.auth.common.exception.NotFoundException;
import com.zzimcong.auth.common.util.AESUtil;
import com.zzimcong.auth.domain.entity.User;
import com.zzimcong.auth.domain.repository.UserRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;
    private final AESUtil aesUtil;

    public UserDetailsServiceImpl(UserRepository userRepository, AESUtil aesUtil) {
        this.userRepository = userRepository;
        this.aesUtil = aesUtil;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(aesUtil.encrypt(email))
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        return org.springframework.security.core.userdetails.User
                .withUsername(email)
                .password(user.getPassword())
                .roles("USER")
                .build();
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/config/EmailConfig.java
--------
package com.zzimcong.auth.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;

import java.util.Properties;

@Configuration
public class EmailConfig {

    private final EmailProperties emailProperties;

    public EmailConfig(EmailProperties emailProperties) {
        this.emailProperties = emailProperties;
    }

    @Bean
    public JavaMailSender mailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(emailProperties.getHost());
        mailSender.setPort(emailProperties.getPort());
        mailSender.setUsername(emailProperties.getUsername());
        mailSender.setPassword(emailProperties.getPassword());

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", String.valueOf(emailProperties.getProperties().getMail().getSmtp().isAuth()));
        props.put("mail.smtp.starttls.enable", String.valueOf(
                emailProperties.getProperties().getMail().getSmtp().getStarttls().isEnable()));

        // 개발 환경에서만 디버그 모드 활성화
        if (System.getProperty("spring.profiles.active", "").contains("dev")) {
            props.put("mail.debug", "true");
        }

        return mailSender;
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/config/RefreshTokenCookieProperties.java
--------
package com.zzimcong.auth.infrastructure.config;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;

@Component
@ConfigurationProperties(prefix = "auth.cookie.refresh-token")
@Validated
@Getter
@Setter
public class RefreshTokenCookieProperties {
    @NotBlank
    private String name;

    @Min(0)
    private int maxAge;

    private boolean httpOnly;
    private boolean secure;

    @NotBlank
    private String path;
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/config/RedisConfig.java
--------
package com.zzimcong.auth.infrastructure.config;

import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

@Configuration
@EnableCaching
public class RedisConfig {
    @Bean
    public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, String> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new StringRedisSerializer());
        return template;
    }

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(cacheConfig)
                .build();
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/config/WebConfig.java
--------
package com.zzimcong.auth.infrastructure.config;

import com.zzimcong.auth.infrastructure.config.interceptor.TokenInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    private final TokenInterceptor tokenInterceptor;

    public WebConfig(TokenInterceptor tokenInterceptor) {
        this.tokenInterceptor = tokenInterceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(tokenInterceptor).addPathPatterns("/api/**");
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/config/SwaggerConfig.java
--------
package com.zzimcong.auth.infrastructure.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("찜콩 API")
                        .version("1.0")
                        .description("선착순 구매 기능이 있는 이커머스 서비스 API 문서"));
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/config/EmailProperties.java
--------
package com.zzimcong.auth.infrastructure.config;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

@ConfigurationProperties(prefix = "email")
@Validated
@Data
public class EmailProperties {
    @NotBlank
    private String host;

    @Min(1)
    @Max(65535)
    private int port;

    @NotBlank
    private String username;

    @NotBlank
    private String password;

    private Properties properties = new Properties();

    @Data
    public static class Properties {
        private Mail mail = new Mail();

        @Data
        public static class Mail {
            private Smtp smtp = new Smtp();

            @Data
            public static class Smtp {
                private boolean auth;
                private Starttls starttls = new Starttls();

                @Data
                public static class Starttls {
                    private boolean enable;
                }
            }
        }
    }

    @NotBlank
    private String sender;

    @NotBlank
    private String subject;

    private Template template = new Template();
    private Verification verification = new Verification();

    @Data
    public static class Template {
        @NotBlank
        private String path;
    }

    @Data
    public static class Verification {
        private Code code = new Code();
        private Token token = new Token();

        @Data
        public static class Code {
            @Min(4)
            @Max(10)
            private int length = 6;

            private Expiry expiry = new Expiry();

            @Data
            public static class Expiry {
                @Min(60)
                @Max(600)
                private long seconds = 300;
            }
        }

        @Data
        public static class Token {
            private Expiry expiry = new Expiry();

            @Data
            public static class Expiry {
                @Min(5)
                @Max(60)
                private long minutes = 30;
            }
        }
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/config/JpaConfig.java
--------
package com.zzimcong.auth.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
@EnableJpaAuditing
public class JpaConfig {
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/config/interceptor/TokenInterceptor.java
--------
package com.zzimcong.auth.infrastructure.config.interceptor;

import com.zzimcong.auth.application.service.CookieService;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

@Component
public class TokenInterceptor implements HandlerInterceptor {

    private final CookieService cookieService;

    public TokenInterceptor(CookieService cookieService) {
        this.cookieService = cookieService;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {
        String refreshToken = (String) request.getAttribute("refreshToken");
        if (refreshToken != null) {
            Cookie refreshTokenCookie = cookieService.createRefreshTokenCookie(refreshToken);
            response.addCookie(refreshTokenCookie);
        }
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/config/CorsConfig.java
--------
package com.zzimcong.auth.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("http://localhost:3000"); // React 앱의 주소
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        source.registerCorsConfiguration("/api/**", config);
        return new CorsFilter(source);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/security/jwt/JwtUtil.java
--------
package com.zzimcong.auth.infrastructure.security.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;
import java.util.function.Function;

@Slf4j
@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.access-token.expiration}")
    private long accessTokenExpiration;

    @Value("${jwt.refresh-token.expiration}")
    private long refreshTokenExpiration;

    private Key getSigningKey() {
        byte[] keyBytes = secret.getBytes();
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateAccessToken(Long id) {
        return generateToken(id, accessTokenExpiration);
    }


    public String generateRefreshToken(Long id) {
        return generateToken(id, refreshTokenExpiration);
    }

    private String generateToken(Long id, long expiration) {
        Date now = new Date(System.currentTimeMillis());
        Date expiryDate = new Date(now.getTime() + expiration * 1000);
        log.info("Generating token for subject: {}, expiration: {}", id, expiryDate);
        return Jwts.builder()
                .setSubject(String.valueOf(id))
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(expiryDate)
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public Long extractId(String token) {
        return Long.parseLong(extractClaim(token, Claims::getSubject));
    }

    public Boolean validateToken(String token, Long id) {
        final Long tokenId = extractId(token);
        return (tokenId.equals(id) && !isTokenExpired(token));
    }

    public Boolean validateToken(String token) {
        try {
            // 1. 토큰 파싱 및 서명 검증
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token);

            // 2. 추가적인 검증 (예: 만료 시간)
            Claims claims = extractAllClaims(token);
            return !isTokenExpired(claims);
        } catch (JwtException | IllegalArgumentException e) {
            log.error("Invalid JWT token", e);
            // 3. 예외 처리
            return false;
        }
    }

    private boolean isTokenExpired(Claims claims) {
        return claims.getExpiration().before(new Date());
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder().setSigningKey(getSigningKey()).build().parseClaimsJws(token).getBody();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/security/jwt/JwtRequestFilter.java
--------
package com.zzimcong.auth.infrastructure.security.jwt;

import com.zzimcong.auth.common.exception.ErrorCode;
import com.zzimcong.auth.common.exception.NotFoundException;
import com.zzimcong.auth.common.exception.UnauthorizedException;
import com.zzimcong.auth.domain.entity.User;
import com.zzimcong.auth.domain.repository.UserRepository;
import com.zzimcong.auth.infrastructure.security.UserDetailsImpl;
import io.jsonwebtoken.ExpiredJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Slf4j(topic = "JWT_REQUEST_FILTER")
@Component
public class JwtRequestFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final UserRepository userRepository;

    public JwtRequestFilter(JwtUtil jwtUtil, UserRepository userRepository) {
        this.jwtUtil = jwtUtil;
        this.userRepository = userRepository;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {

        final String authorizationHeader = request.getHeader("Authorization");

        Long id = null;
        String jwt = null;

        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7);
            try {
                id = jwtUtil.extractId(jwt);
            } catch (ExpiredJwtException e) {
                log.warn("JWT 토큰이 만료되었습니다", e);
                throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
            } catch (Exception e) {
                log.error("JWT 토큰에서 id를 추출하는 중 오류가 발생했습니다", e);
                throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
            }
        }

        if (id != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            User user = userRepository.findById(id)
                    .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

            if (jwtUtil.validateToken(jwt, user.getId())) {
                UserDetailsImpl userDetails = new UserDetailsImpl(user);

                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authToken);
            } else {
                log.warn("JWT 토큰 검증에 실패했습니다");
                throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
            }
        }

        chain.doFilter(request, response);
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/security/SecurityConfig.java
--------
package com.zzimcong.auth.infrastructure.security;

import com.zzimcong.auth.infrastructure.security.jwt.JwtRequestFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JwtRequestFilter jwtAuthFilter;

    public SecurityConfig(JwtRequestFilter jwtAuthFilter) {
        this.jwtAuthFilter = jwtAuthFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/v1/auth/**").permitAll()
                        .requestMatchers("/api/v1/email-verifications/**").permitAll()
                        .requestMatchers("/api/v1/categories/**").permitAll()
                        .requestMatchers("/api/v1/products/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/infrastructure/security/UserDetailsImpl.java
--------
package com.zzimcong.auth.infrastructure.security;

import com.zzimcong.auth.domain.entity.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;

public class UserDetailsImpl implements UserDetails {
    private final User user;

    public UserDetailsImpl(User user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority(user.getRole()));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return String.valueOf(user.getId());
    }
}

--------


File: ./auth/src/main/java/com/zzimcong/auth/domain/repository/UserRepository.java
--------
package com.zzimcong.auth.domain.repository;

import com.zzimcong.auth.domain.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Boolean existsByEmail(String email);

    Optional<User> findByEmail(String email);
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/domain/entity/BaseEntity.java
--------
package com.zzimcong.auth.domain.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@Setter
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
public abstract class BaseEntity {

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

}

--------


File: ./auth/src/main/java/com/zzimcong/auth/domain/entity/User.java
--------
package com.zzimcong.auth.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Getter
@Setter
@Table(name = "user")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long id;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String phone;

    @Column(nullable = false)
    private boolean abuser = false;

    @Column(nullable = false)
    private boolean signout = false;

    @Column(nullable = false)
    private String role = "USER";
}


--------


File: ./auth/src/main/java/com/zzimcong/auth/domain/mapper/UserMapper.java
--------
package com.zzimcong.auth.domain.mapper;

import com.zzimcong.auth.application.dto.SignupRequestDto;
import com.zzimcong.auth.application.dto.UserModifyRequestDto;
import com.zzimcong.auth.application.dto.UserResponseDto;
import com.zzimcong.auth.common.exception.InternalServerError;
import com.zzimcong.auth.common.util.AESUtil;
import com.zzimcong.auth.domain.entity.User;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

@Component
public class UserMapper {
    private static final Logger logger = LoggerFactory.getLogger(UserMapper.class);
    private final AESUtil aesUtil;
    private final PasswordEncoder passwordEncoder;

    public UserMapper(PasswordEncoder passwordEncoder, AESUtil aesUtil) {
        this.aesUtil = aesUtil;
        this.passwordEncoder = passwordEncoder;
    }

    //Dto -> Entity 변환
    public User toEntity(SignupRequestDto dto) {
        if (dto == null) {
            return null;
        }
        User user = new User();
        try {
            user.setName(aesUtil.encrypt(dto.getName()));
            user.setEmail(aesUtil.encrypt(dto.getEmail()));
            user.setPhone(aesUtil.encrypt(dto.getPhone()));
            user.setPassword(passwordEncoder.encode(dto.getPassword()));
        } catch (InternalServerError e) {
            logger.error("Error encrypting user data: {}", e.getMessage());
            throw e;
        }

        return user;
    }

    //Entity -> Dto 변환
    public UserResponseDto toDto(User user) {
        if (user == null) {
            return null;
        }
        UserResponseDto dto = new UserResponseDto();
        try {
            dto.setId(user.getId());
            dto.setEmail(aesUtil.decrypt(user.getEmail()));
            dto.setUsername(aesUtil.decrypt(user.getName()));
            dto.setPhone(aesUtil.decrypt(user.getPhone()));
        } catch (InternalServerError e) {
            logger.error("Error decrypting user data: {}", e.getMessage());
            throw e;
        }

        return dto;
    }

    //Dto를 이용해 Entity 업데이트
    public User updateFromDto(User user, UserModifyRequestDto dto) {
        if (user == null || dto == null) {
            return null;
        }
        user.setName(aesUtil.encrypt(dto.getUsername()));
        user.setPhone(aesUtil.encrypt(dto.getPhone()));
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        return user;
    }
}


--------


File: ./user/src/test/java/com/zzimcong/user/UserApplicationTests.java
--------
package com.zzimcong.user;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class UserApplicationTests {

    @Test
    void contextLoads() {
    }

}


--------


File: ./user/src/test/java/com/zzimcong/user/EmailSenderTest.java
--------
package com.zzimcong.user;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.mail.MailException;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;

@SpringBootTest
public class EmailSenderTest {

    @Autowired
    private JavaMailSender mailSender;

    @Test
    public void testSendEmail() {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom("zzimcong99@gmail.com");
        message.setTo("recipient@example.com");
        message.setSubject("Test Subject");
        message.setText("Test Body");

        try {
            mailSender.send(message);
            System.out.println("Test email sent successfully");
        } catch (MailException e) {
            System.err.println("Failed to send test email. Error: " + e.getMessage());
            e.printStackTrace();

            if (e.getCause() != null) {
                System.err.println("Root cause: " + e.getCause().getMessage());
                e.getCause().printStackTrace();
            }
        }
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/util/SecurityUtil.java
--------
package com.zzimcong.user.common.util;

import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.UnauthorizedException;
import com.zzimcong.user.infrastructure.security.UserDetailsImpl;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

public class SecurityUtil {
    public static Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !(authentication.getPrincipal() instanceof UserDetailsImpl)) {
            throw new UnauthorizedException(ErrorCode.USER_NOT_AUTHENTICATED);
        }
        return Long.parseLong(((UserDetailsImpl) authentication.getPrincipal()).getUsername());
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/util/KeyManagementUtil.java
--------
package com.zzimcong.user.common.util;

import lombok.Getter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

@Component
public class KeyManagementUtil {

    private final Environment environment;
    @Getter
    private String encryptionKey;

    @Autowired
    public KeyManagementUtil(Environment environment) {
        this.environment = environment;
        initEncryptionKey();
    }

    private void initEncryptionKey() {
        // 시스템 환경 변수에서 먼저 확인
        encryptionKey = System.getenv("ENCRYPTION_KEY");

        // 시스템 환경 변수에 없으면 스프링 Environment에서 확인
        if (encryptionKey == null || encryptionKey.isEmpty()) {
            encryptionKey = environment.getProperty("encryption.key");
        }

        // 둘 다 없으면 예외 발생
        if (encryptionKey == null || encryptionKey.isEmpty()) {
            throw new IllegalStateException("ENCRYPTION_KEY가 설정되지 않았습니다.");
        }
    }

}

--------


File: ./user/src/main/java/com/zzimcong/user/common/util/EmailVerificationToken.java
--------
package com.zzimcong.user.common.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@AllArgsConstructor
public class EmailVerificationToken {
    private String token;
    private String email;
    private LocalDateTime expiryDate;
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/util/RedisUtil.java
--------
package com.zzimcong.user.common.util;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Service
@RequiredArgsConstructor
public class RedisUtil {
    private final StringRedisTemplate redisTemplate;//Redis에 접근하기 위한 Spring의 Redis 템플릿 클래스

    public String getData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 가져오는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        return valueOperations.get(key);
    }

    public void setData(String key, String value) {//지정된 키(key)에 값을 저장하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        valueOperations.set(key, value);
    }

    public void setDataExpire(String key, String value, long duration) {//지정된 키(key)에 값을 저장하고, 지정된 시간(duration) 후에 데이터가 만료되도록 설정하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        Duration expireDuration = Duration.ofSeconds(duration);
        valueOperations.set(key, value, expireDuration);
    }

    public void deleteData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 삭제하는 메서드
        redisTemplate.delete(key);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/util/AESUtil.java
--------
package com.zzimcong.user.common.util;

import com.zzimcong.user.common.exception.BadRequestException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.InternalServerErrorException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Slf4j(topic = "AESUtil")
@Component
public class AESUtil {
    private static final String ALGORITHM = "AES";
    private static final String CIPHER_INSTANCE = "AES/ECB/PKCS5Padding";  // 명시적으로 모드와 패딩 지정

    private final KeyManagementUtil keyManagementUtil;

    @Autowired
    public AESUtil(KeyManagementUtil keyManagementUtil) {
        this.keyManagementUtil = keyManagementUtil;
    }

    public String encrypt(String data) {
        if(data == null) throw new BadRequestException(ErrorCode.INVALID_EMAIL);
        try {
            Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE);
            cipher.init(Cipher.ENCRYPT_MODE, getKeySpec());
            byte[] encryptedData = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(encryptedData);
        } catch (Exception e) {
            log.error("Encryption failed", e);
            throw new InternalServerErrorException(ErrorCode.ENCRYPTION_FAILED);
        }
    }

    public String decrypt(String encryptedData) {
        try {
            Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE);
            cipher.init(Cipher.DECRYPT_MODE, getKeySpec());
            byte[] decryptedData = cipher.doFinal(Base64.getDecoder().decode(encryptedData));
            return new String(decryptedData, StandardCharsets.UTF_8);
        } catch (Exception e) {
            log.error("Decryption failed", e);
            throw new InternalServerErrorException(ErrorCode.DECRYPTION_FAILED);
        }
    }

    private SecretKeySpec getKeySpec() {
        String key = keyManagementUtil.getEncryptionKey();
        byte[] decodedKey = Base64.getDecoder().decode(key);
        return new SecretKeySpec(decodedKey, ALGORITHM);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/UserInfo.java
--------
package com.zzimcong.user.common;

import lombok.Data;

@Data
public class UserInfo {
    private Long id;
    private String username;
    private String role;
    // 필요한 다른 필드들...
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/ErrorCode.java
--------
package com.zzimcong.user.common.exception;

import lombok.Getter;

@Getter
public enum ErrorCode {
    // BadRequestException (400)
    INVALID_INPUT("잘못된 입력입니다."),
    INVALID_EMAIL("잘못된 이메일 형식입니다."),
    INVALID_PASSWORD("잘못된 비밀번호 형식입니다."),
    INVALID_VERIFICATION_CODE("잘못된 인증 코드입니다."),
    EMAIL_VERIFICATION_FAILED("이메일 인증에 실패했습니다."),
    MISSING_REQUEST_BODY("요청 바디가 없습니다."),

    // UnauthorizedException (401)
    INVALID_CREDENTIALS("잘못된 인증 정보입니다."),
    INVALID_TOKEN("유효하지 않은 토큰입니다."),
    EXPIRED_TOKEN("만료된 토큰입니다."),
    TOKEN_NOT_FOUND("토큰을 찾을 수 없습니다."),
    USER_NOT_AUTHENTICATED("사용자가 인증되지 않았습니다."),

    // ForbiddenException (403)
    ACCESS_DENIED("접근 권한이 없습니다."),

    // NotFoundException (404)
    RESOURCE_NOT_FOUND("요청한 리소스를 찾을 수 없습니다."),
    USER_NOT_FOUND("사용자를 찾을 수 없습니다."),

    // MethodNotAllowedException (405)
    METHOD_NOT_ALLOWED("허용되지 않은 HTTP 메서드입니다."),

    // ConflictException (409)
    DUPLICATE_EMAIL("이미 존재하는 이메일입니다."),

    // InternalServerErrorException (500)
    ENCRYPTION_FAILED("사용자 정보 암호화에 실패했습니다."),
    DECRYPTION_FAILED("사용자 정보 복호화에 실패했습니다."),
    RESOURCE_LOAD_FAILED("내부 리소스 로딩에 실패했습니다."),
    EMAIL_SEND_FAILED("이메일 전송에 실패했습니다."),
    INTERNAL_SERVER_ERROR("서버 내부 오류가 발생했습니다."),
    UNKNOWN_ERROR("알 수 없는 오류가 발생했습니다.");

    private final String message;

    ErrorCode(String message) {
        this.message = message;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/ForbiddenException.java
--------
package com.zzimcong.user.common.exception;

public class ForbiddenException extends BaseException {
    public ForbiddenException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ForbiddenException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/UnauthorizedException.java
--------
package com.zzimcong.user.common.exception;

public class UnauthorizedException extends BaseException {
    public UnauthorizedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public UnauthorizedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/ConflictException.java
--------
package com.zzimcong.user.common.exception;

public class ConflictException extends BaseException {
    public ConflictException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ConflictException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/MethodNotAllowedException.java
--------
package com.zzimcong.user.common.exception;

public class MethodNotAllowedException extends BaseException {
    public MethodNotAllowedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public MethodNotAllowedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/InternalServerErrorException.java
--------
package com.zzimcong.user.common.exception;

public class InternalServerErrorException extends BaseException {
    public InternalServerErrorException(ErrorCode errorCode) {
        super(errorCode);
    }

    public InternalServerErrorException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}


--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/GlobalExceptionHandler.java
--------
package com.zzimcong.user.common.exception;

import com.zzimcong.user.api.response.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.protocol.HTTP;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j(topic = "GLOBAL_EXCEPTION_HANDLER")
@ControllerAdvice
public class GlobalExceptionHandler {
    // BadRequestException (400)
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorResponse> httpMessageNotReadableException(HttpServletRequest request) {
        BadRequestException ex = new BadRequestException(ErrorCode.MISSING_REQUEST_BODY);
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    // UnauthorizedException (401)
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(UnauthorizedException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.UNAUTHORIZED, request.getRequestURI());
    }

    // ForbiddenException (403)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbiddenException(ForbiddenException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.FORBIDDEN, request.getRequestURI());
    }

    // NotFoundException (404)
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.NOT_FOUND, request.getRequestURI());
    }

    // MethodNotAllowedException (405)
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowedException(HttpServletRequest request) {
        MethodNotAllowedException ex = new MethodNotAllowedException(ErrorCode.METHOD_NOT_ALLOWED);
        return createErrorResponse(ex, HttpStatus.METHOD_NOT_ALLOWED, request.getRequestURI());
    }

    // ConflictException (409)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(ConflictException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.CONFLICT, request.getRequestURI());
    }

    // InternalServerErrorException (500)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllException(Exception ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
    }

    // Create ErrorResponse
    private ResponseEntity<ErrorResponse> createErrorResponse(Exception ex, HttpStatus status, String path) {
        logException(ex, status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.INTERNAL_SERVER_ERROR);
        ErrorResponse errorResponse = ErrorResponse.of(baseException, status, path);
        return new ResponseEntity<>(errorResponse, status);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        // 스택 트레이스를 분석하여 예외 발생 위치 추출
        StackTraceElement[] stackTraceElements = ex.getStackTrace();
        String errorLocation = "Unknown";
        if (stackTraceElements.length > 0) {
            StackTraceElement element = stackTraceElements[0];
            errorLocation = String.format("%s.%s (Line: %d)",
                    element.getClassName(),
                    element.getMethodName(),
                    element.getLineNumber());
        }
        log.error(
                "Exception occurred:: {}, Path: {}",
                errorLocation,
                path
        );
        log.error("Error Code: {}, HTTP Status: {}, Message: {}",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage());
    }
}


--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/BadRequestException.java
--------
package com.zzimcong.user.common.exception;

public class BadRequestException extends BaseException {
    public BadRequestException(ErrorCode errorCode) {
        super(errorCode);
    }

    public BadRequestException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/BaseException.java
--------
package com.zzimcong.user.common.exception;

public class BaseException extends RuntimeException {
    private final ErrorCode errorCode;
    private final String message;

    public BaseException(ErrorCode errorCode) {
        this(errorCode, errorCode.getMessage());
    }

    public BaseException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.message = message;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    @Override
    public String getMessage() {
        return message;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/NotFoundException.java
--------
package com.zzimcong.user.common.exception;

public class NotFoundException extends BaseException {
    public NotFoundException(ErrorCode errorCode) {
        super(errorCode);
    }

    public NotFoundException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/UserApplication.java
--------
package com.zzimcong.user;

import com.zzimcong.user.infrastructure.config.EmailProperties;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
@EnableConfigurationProperties(EmailProperties.class)
public class UserApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }
}


--------


File: ./user/src/main/java/com/zzimcong/user/api/response/ApiResponse.java
--------
package com.zzimcong.user.api.response;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }
}


--------


File: ./user/src/main/java/com/zzimcong/user/api/response/ErrorResponse.java
--------
package com.zzimcong.user.api.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.zzimcong.user.common.exception.BaseException;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {
    private int status;
    private String message;
    private String errorCode;
    private LocalDateTime timestamp;
    private String path;

    public static ErrorResponse of(BaseException ex, HttpStatus status, String path) {
        ErrorResponse response = new ErrorResponse();
        response.setStatus(status.value());
        response.setMessage(ex.getMessage());
        response.setErrorCode(ex.getErrorCode().name());
        response.setTimestamp(LocalDateTime.now());
        response.setPath(path);
        return response;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/api/controller/EmailVerificationsController.java
--------
package com.zzimcong.user.api.controller;

import com.zzimcong.user.application.dto.EmailCheckResponse;
import com.zzimcong.user.application.dto.EmailRequest;
import com.zzimcong.user.application.service.EmailVerificationService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j(topic = "EMAIL_VERIFICATIONS_CONTROLLER")
@RestController
@RequestMapping("/api/v1/email-verifications")
public class EmailVerificationsController {
    private final EmailVerificationService emailVerificationService;

    @Autowired
    public EmailVerificationsController(EmailVerificationService emailVerificationService) {
        this.emailVerificationService = emailVerificationService;
    }

    @PostMapping("/send")
    public ResponseEntity<String> sendVerificationEmail(@RequestBody @Valid EmailRequestDto emailDto) {
        log.info("인증 이메일 전송 요청: {}", emailDto.getEmail());
        emailVerificationService.sendVerificationEmail(emailDto.getEmail());
        return ResponseEntity.ok("인증 이메일이 성공적으로 전송되었습니다.");
    }

    @PostMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestBody @Valid EmailCheckDto emailCheckResponse) {
        log.info("이메일 인증 요청: {}", emailCheckResponse.getEmail());
        String token = emailVerificationService.verifyEmailAndGenerateToken(emailCheckResponse.getEmail(), emailCheckResponse.getAuthNum());
        return ResponseEntity.ok(token);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/api/controller/CustomErrorController.java
--------
package com.zzimcong.user.api.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.zzimcong.user.api.response.ErrorResponse;
import com.zzimcong.user.common.exception.BaseException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.InternalServerErrorException;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import jakarta.servlet.http.HttpServletRequest;

@Slf4j(topic = "CUSTOM_ERROR_CONTROLLER")
@RestController
public class CustomErrorController implements ErrorController {
    private final ObjectMapper objectMapper;

    public CustomErrorController(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @RequestMapping("/error")
    public void handleError(HttpServletRequest request, HttpServletResponse response) throws Exception {
        Integer status = (Integer) request.getAttribute("status");
        Exception ex = (Exception) request.getAttribute("exception");
        String path = (String) request.getAttribute("path");

        if (status == null) {
            status = HttpStatus.INTERNAL_SERVER_ERROR.value();
        }

        log.info("Error occurred: status={}, path={}", status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.UNKNOWN_ERROR);

        ErrorResponse errorResponse = ErrorResponse.of(baseException, HttpStatus.valueOf(status), path);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(status);
        response.getWriter().write(objectMapper.writeValueAsString(errorResponse));
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/api/controller/AuthController.java
--------
package com.zzimcong.user.api.controller;

import com.zzimcong.user.api.response.ApiResponse;
import com.zzimcong.user.application.dto.*;
import com.zzimcong.user.application.service.AuthService;
import com.zzimcong.user.application.service.EmailVerificationService;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j(topic = "AUTH_CONTROLLER")
@RestController
@RequestMapping("/api/v1/auth")
public class AuthController {
    private final AuthService authService;
    private final EmailVerificationService emailVerificationService;

    @Autowired
    public AuthController(AuthService authService, EmailVerificationService emailVerificationService) {
        this.authService = authService;
        this.emailVerificationService = emailVerificationService;
    }

    @GetMapping("/info")
    public String getUserInfo(HttpServletRequest request) {
        return "User Info";
    }

    // 이메일 중복 확인
    @PostMapping("/check-email")
    public ResponseEntity<?> checkEmailAvailability(@RequestBody EmailRequestDto emailRequest) {
        boolean isAvailable = emailVerificationService.isEmailAvailable(emailRequest.getEmail());
        String message = isAvailable ? "사용 가능한 이메일입니다." : "이미 사용 중인 이메일입니다.";
        return ResponseEntity.ok(ApiResponse.success(isAvailable, message));
    }

    @PostMapping("/signup")
    public ResponseEntity<?> signUp(@RequestBody @Valid SignupRequestDto signupRequest,
                                    @RequestParam String token) {
        authService.signUp(signupRequest, token);
        return ResponseEntity.ok(ApiResponse.success(null, "회원가입이 완료되었습니다."));
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequestDto loginRequest, HttpServletRequest request) {
        AuthResultDto authResponse = authService.login(loginRequest);
        return ResponseEntity.ok(ApiResponse.success(authResponse, "로그인에 성공했습니다."));
    }

    @PostMapping("/logout")
    public ResponseEntity<?> logout() {
        authService.logout();
        return ResponseEntity.ok(ApiResponse.success(null, "로그아웃되었습니다."));
    }

    // refreshToken을 이용한 accessToken 재발급
    @PostMapping("/refresh")
    public ResponseEntity<?> refreshToken(@RequestBody RefreshRequestDto refreshRequest) {
        String refreshToken = refreshRequest.getRefreshToken();
        AuthResultDto authResponse = authService.refreshToken(refreshToken);
        return ResponseEntity.ok(ApiResponse.success(authResponse, "토큰이 갱신되었습니다."));
    }

    private String extractRefreshTokenFromCookie(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("refreshToken".equals(cookie.getName())) {
                    return cookie.getValue();
                }
            }
        }
        return null;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/api/controller/UserController.java
--------
package com.zzimcong.user.api.controller;

import com.zzimcong.user.application.dto.UserModifyRequest;
import com.zzimcong.user.application.dto.UserResponse;
import com.zzimcong.user.application.service.UserService;
import com.zzimcong.user.common.util.SecurityUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j(topic = "USER_CONTROLLER")
@RestController
@RequestMapping("/api/v1/users")
public class UserController {
    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }

    //회원정보 조회
    @GetMapping
    public ResponseEntity<UserResponseDto> getUserByEmail() {
        UserResponseDto user = userService.getUserById(SecurityUtil.getCurrentUserId());
        return ResponseEntity.ok(user);
    }

    //회원정보 수정
    @PutMapping
    public ResponseEntity<UserResponseDto> updateUser(@RequestBody UserModifyRequestDto userModifyRequest) {
        UserResponseDto updatedUser = userService.updateUser(SecurityUtil.getCurrentUserId(), userModifyRequest);
        return ResponseEntity.ok(updatedUser);
    }

    //회원탈퇴
    @DeleteMapping("/signout")
    public ResponseEntity<UserResponseDto> signoutUser() {
        UserResponseDto signoutUser = userService.signoutUser(SecurityUtil.getCurrentUserId());
        return ResponseEntity.ok(signoutUser);
    }
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/AuthResultDto.java
--------
package com.zzimcong.user.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class AuthResultDto {
    private String accessToken;
    private String refreshToken;
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/UserResponseDto.java
--------
package com.zzimcong.user.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class UserResponseDto {
    private Long id;
    private String email;
    private String username;
    private String phone;
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/LogoutRequest.java
--------
package com.zzimcong.user.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LogoutRequest {
    private String accessToken;
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/LoginRequestDto.java
--------
package com.zzimcong.user.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LoginRequestDto {
    private String email;
    private String password;
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/EmailCheckDto.java
--------
package com.zzimcong.user.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import lombok.Data;

@Data
public class EmailCheckDto {
    @Email
    @NotEmpty(message = "이메일을 입력해 주세요")
    private String email;

    @NotEmpty(message = "인증 번호를 입력해 주세요")
    private String authNum;

}

--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/EmailRequestDto.java
--------
package com.zzimcong.user.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class EmailRequestDto {
    //1. @기호를 포함해야 한다.
    //2. @기호를 기준으로 이메일 주소를 이루는 로컬호스트와 도메인 파트가 존재해야 한다.
    //3. 도메인 파트는 최소하나의 점과 그 뒤에 최소한 2개의 알파벳을 가진다
    @Email(message = "이메일 형식이 올바르지 않습니다.")
    @NotEmpty(message = "이메일을 입력해 주세요")
    private String email;
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/UserModifyRequestDto.java
--------
package com.zzimcong.user.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class UserModifyRequestDto {
    private String name;
    private String phone;
    private String password;
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/SignupRequestDto.java
--------
package com.zzimcong.user.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SignupRequestDto {
    @NotBlank(message = "이메일은 필수 입력 값입니다.")
    @Email(message = "이메일 형식이 아닙니다.")
    private String email;

    @NotBlank(message = "이름은 필수 입력 값입니다.")
    private String name;

    @NotBlank(message = "전화번호는 필수 입력 값입니다.")
    private String phone;

    @NotBlank(message = "비밀번호는 필수 입력 값입니다.")
    private String password;
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/RefreshRequestDto.java
--------
package com.zzimcong.user.application.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class RefreshRequestDto {
    private String refreshToken;
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/service/CookieService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.infrastructure.config.RefreshTokenCookieProperties;
import jakarta.servlet.http.Cookie;
import org.springframework.stereotype.Service;

@Service
public class CookieService {

    private final RefreshTokenCookieProperties refreshTokenCookieProperties;

    public CookieService(RefreshTokenCookieProperties refreshTokenCookieProperties) {
        this.refreshTokenCookieProperties = refreshTokenCookieProperties;
    }

    public Cookie createRefreshTokenCookie(String refreshToken) {
        Cookie cookie = new Cookie(refreshTokenCookieProperties.getName(), refreshToken);
        cookie.setHttpOnly(refreshTokenCookieProperties.isHttpOnly());
        cookie.setSecure(refreshTokenCookieProperties.isSecure());
        cookie.setPath(refreshTokenCookieProperties.getPath());
        cookie.setMaxAge(refreshTokenCookieProperties.getMaxAge());
        return cookie;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/UserService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.application.dto.SignupRequest;
import com.zzimcong.user.application.dto.UserModifyRequest;
import com.zzimcong.user.application.dto.UserResponse;
import com.zzimcong.user.common.exception.ConflictException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.NotFoundException;
import com.zzimcong.user.common.util.AESUtil;
import com.zzimcong.user.domain.entity.User;
import com.zzimcong.user.domain.mapper.UserMapper;
import com.zzimcong.user.domain.repository.UserRepository;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Slf4j(topic = "USER_SERVICE")
@Service
public class UserService {
    private final UserRepository userRepository;
    private final UserMapper userMapper;
    private final AESUtil aesUtil;

    @Autowired
    public UserService(UserRepository userRepository, UserMapper userMapper, AESUtil aesUtil) {
        this.userRepository = userRepository;
        this.userMapper = userMapper;
        this.aesUtil = aesUtil;
    }

    //이메일 중복 체크
    public boolean checkEmailAvailability(String email) {
        return !userRepository.existsByEmail(aesUtil.encrypt(email));
    }

    //유저 생성
    public User createUser(SignupRequestDto signupRequest) {
        if (userRepository.existsByEmail(aesUtil.encrypt(signupRequest.getEmail()))) {
            throw new ConflictException(ErrorCode.DUPLICATE_EMAIL);
        }
        User user = userMapper.toEntity(signupRequest);
        return userRepository.save(user);
    }

    //유저 조회
    public UserResponseDto getUserByEmail(String email) {
        User user = userRepository.findByEmail(aesUtil.encrypt(email))
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        return userMapper.toDto(user);
    }

    public UserResponseDto getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        return userMapper.toDto(user);
    }

    //유저 수정
    @Transactional
    public UserResponseDto updateUser(Long id, UserModifyRequestDto userModifyRequest) {
        User findUser = userRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        findUser = userMapper.updateFromDto(findUser, userModifyRequest);
        User updatedUser = userRepository.save(findUser);
        return userMapper.toDto(updatedUser);
    }

    //유저 삭제
    public UserResponseDto signoutUser(Long id) {
        User findUser = userRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        findUser.setSignout(true);
        User signoutUser = userRepository.save(findUser);
        return userMapper.toDto(signoutUser);
    }

}


--------


File: ./user/src/main/java/com/zzimcong/user/application/service/AuthService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.application.dto.AuthResponse;
import com.zzimcong.user.application.dto.LoginRequest;
import com.zzimcong.user.application.dto.SignupRequest;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.UnauthorizedException;
import com.zzimcong.user.common.util.SecurityUtil;
import com.zzimcong.user.infrastructure.security.jwt.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

@Slf4j(topic = "AUTH_SERVICE")
@Service
public class AuthService {
    private final TokenService tokenService;
    private final UserService userService;
    private final EmailVerificationService emailVerificationService;
    private final JwtUtil jwtUtil;
    private final AuthenticationManager authenticationManager;

    public AuthService(TokenService tokenService,
                       UserService userService,
                       EmailVerificationService emailVerificationService,
                       JwtUtil jwtUtil,
                       AuthenticationManager authenticationManager) {
        this.tokenService = tokenService;
        this.userService = userService;
        this.emailVerificationService = emailVerificationService;
        this.jwtUtil = jwtUtil;
        this.authenticationManager = authenticationManager;
    }

    public void signUp(SignupRequestDto signupRequest, String token) {
        emailVerificationService.validateTokenForRegistration(signupRequest.getEmail(), token);
        userService.createUser(signupRequest);
    }

    public AuthResultDto login(LoginRequestDto requestDto) {
        try {
            Authentication authentication = authenticateUser(requestDto);
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            Long id = Long.parseLong(userDetails.getUsername());
            return generateAuthResultDto(id);
        } catch (AuthenticationException e) {
            throw new UnauthorizedException(ErrorCode.INVALID_CREDENTIALS, "잘못된 이메일 또는 비밀번호입니다.");
        }
    }

    public void logout() {
        Long id = SecurityUtil.getCurrentUserId();
        try {
            tokenService.deleteRefreshToken(String.valueOf(id));
        } catch (ExpiredJwtException e) {
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }
        log.info("User {} logged out successfully", id);
    }

    public AuthResultDto refreshToken(String refreshToken) {
        if (refreshToken == null) {
            throw new UnauthorizedException(ErrorCode.TOKEN_NOT_FOUND);
        }
        try {
            if (!jwtUtil.validateToken(refreshToken)) {
                throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
            }
            Long id = jwtUtil.extractId(refreshToken);
            return generateAuthResultDto(id);
        } catch (ExpiredJwtException e) {
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }
    }

    private Authentication authenticateUser(LoginRequestDto requestDto) {
        return authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(requestDto.getEmail(), requestDto.getPassword())
        );
    }

    private AuthResultDto generateAuthResultDto(Long id) {
        String accessToken = jwtUtil.generateAccessToken(id);
        String refreshToken = jwtUtil.generateRefreshToken(id);
        tokenService.storeRefreshToken(String.valueOf(id), refreshToken);
        return new AuthResultDto(accessToken, refreshToken);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/EmailVerificationService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.common.util.EmailVerificationToken;
import com.zzimcong.user.common.util.RedisUtil;
import com.zzimcong.user.infrastructure.config.EmailProperties;
import com.zzimcong.user.common.exception.ConflictException;
import com.zzimcong.user.common.exception.UnauthorizedException;
import com.zzimcong.user.common.exception.ErrorCode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j(topic = "EMAIL_VERIFICATION_SERVICE")
@Service
public class EmailVerificationService {
    private final Set<EmailVerificationToken> emailVerificationTokens =
            Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final EmailProperties emailProperties;
    private final EmailService emailService;
    private final UserService userService;
    private final RedisUtil redisUtil;

    public EmailVerificationService(EmailProperties emailProperties, EmailService emailService, UserService userService, RedisUtil redisUtil) {
        this.emailProperties = emailProperties;
        this.emailService = emailService;
        this.userService = userService;
        this.redisUtil = redisUtil;
    }

    public void sendVerificationEmail(String email) {
        if (!isEmailAvailable(email)) {
            log.warn("사용할 수 없는 이메일입니다: {}", email);
            throw new ConflictException(ErrorCode.DUPLICATE_EMAIL);
        }
        String verificationCode = emailService.generateVerificationCode();
        emailService.sendVerificationEmail(email, verificationCode);
        storeVerificationCode(verificationCode, email);
        log.info("인증 이메일 전송: {}", email);
    }

    public boolean isEmailAvailable(String email) {
        return userService.checkEmailAvailability(email);
    }

    private void storeVerificationCode(String code, String email) {
        redisUtil.setDataExpire(code, email,
                emailProperties.getVerification().getCode().getExpiry().getSeconds());
    }

    public String verifyEmailAndGenerateToken(String email, String verificationCode) {
        if (!verifyEmailCode(email, verificationCode)) {
            throw new UnauthorizedException(ErrorCode.INVALID_VERIFICATION_CODE);
        }
        String token = UUID.randomUUID().toString();
        EmailVerificationToken verificationToken =
                new EmailVerificationToken(token, email, LocalDateTime.now().plusMinutes(
                        emailProperties.getVerification().getToken().getExpiry().getMinutes()));
        emailVerificationTokens.add(verificationToken);
        log.info("이메일 인증 성공 및 토큰 생성: {}", email);
        return token;
    }

    private boolean verifyEmailCode(String email, String code) {
        String storedEmail = redisUtil.getData(code);
        return storedEmail != null && storedEmail.equals(email);
    }

    public void validateTokenForRegistration(String email, String token) {
        EmailVerificationToken verificationToken = emailVerificationTokens.stream()
                .filter(t -> t.getToken().trim().equalsIgnoreCase(token.trim())
                        && t.getEmail().trim().equalsIgnoreCase(email.trim()))
                .findFirst()
                .orElseThrow(() -> new UnauthorizedException(ErrorCode.INVALID_TOKEN));

        if (LocalDateTime.now().isAfter(verificationToken.getExpiryDate())) {
            emailVerificationTokens.remove(verificationToken);
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }

        emailVerificationTokens.remove(verificationToken);
    }

    @Scheduled(fixedRate = 60000) // 1분마다 실행
    public void cleanupExpiredTokens() {
        emailVerificationTokens.removeIf(token -> LocalDateTime.now().isAfter(token.getExpiryDate()));
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/EmailService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.common.exception.InternalServerErrorException;
import com.zzimcong.user.infrastructure.config.EmailProperties;
import com.zzimcong.user.common.exception.ErrorCode;
import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import org.springframework.util.StreamUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Random;

@Slf4j(topic = "EMAIL_SERVICE")
@Service
@RequiredArgsConstructor
public class EmailService {
    private final EmailProperties emailProperties;
    private final JavaMailSender mailSender;
    private final ResourceLoader resourceLoader;

    public String generateVerificationCode() {
        Random random = new Random();
        return String.format("%0" + emailProperties.getVerification().getCode().getLength() + "d",
                random.nextInt((int) Math.pow(10, emailProperties.getVerification().getCode().getLength())));
    }

    private String prepareEmailContent(String verificationCode) {
        try {
            String template = loadEmailTemplate();
            return template.replace("${verificationCode}", verificationCode);
        } catch (IOException e) {
            log.error("Failed to load email template", e);
            throw new InternalServerErrorException(ErrorCode.RESOURCE_LOAD_FAILED,
                    "이메일 템플릿 로딩에 실패했습니다.");
        }
    }

    private String loadEmailTemplate() throws IOException {
        Resource resource = resourceLoader.getResource(emailProperties.getTemplate().getPath());
        return StreamUtils.copyToString(resource.getInputStream(), StandardCharsets.UTF_8);
    }

    public void sendVerificationEmail(String toEmail, String verificationCode) {
        try {
            String content = prepareEmailContent(verificationCode);
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8");

            helper.setFrom(emailProperties.getSender());
            helper.setTo(toEmail);
            helper.setSubject(emailProperties.getSubject());
            helper.setText(content, true);

            mailSender.send(message);
            log.info("인증 메일이 성공적으로 전송되었습니다: {}", toEmail);
        } catch (MessagingException e) {
            log.error("인증 메일 전송에 실패했습니다: {}", toEmail, e);
            throw new InternalServerErrorException(ErrorCode.EMAIL_SEND_FAILED,
                    "인증 메일 전송에 실패했습니다.");
        }
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/TokenService.java
--------
package com.zzimcong.user.application.service;

import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
public class TokenService {
    private final RedisTemplate<String, String> redisTemplate;

    public TokenService(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public void storeRefreshToken(String username, String refreshToken) {
        redisTemplate.opsForValue().set(username, refreshToken);
        redisTemplate.expire(username, 7, TimeUnit.DAYS);
    }

    public void deleteRefreshToken(String username) {
        redisTemplate.delete(username);
    }

    public String getRefreshToken(String username) {
        return redisTemplate.opsForValue().get(username);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/UserDetailsServiceImpl.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.common.util.AESUtil;
import com.zzimcong.user.domain.entity.User;
import com.zzimcong.user.common.exception.NotFoundException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.domain.repository.UserRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;
    private final AESUtil aesUtil;

    public UserDetailsServiceImpl(UserRepository userRepository, AESUtil aesUtil) {
        this.userRepository = userRepository;
        this.aesUtil = aesUtil;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(aesUtil.encrypt(email))
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        return org.springframework.security.core.userdetails.User
                .withUsername(String.valueOf(user.getId()))
                .password(user.getPassword())
                .roles("USER")
                .build();
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/EmailConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;

import java.util.Properties;

@Configuration
public class EmailConfig {

    private final EmailProperties emailProperties;

    public EmailConfig(EmailProperties emailProperties) {
        this.emailProperties = emailProperties;
    }

    @Bean
    public JavaMailSender mailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(emailProperties.getHost());
        mailSender.setPort(emailProperties.getPort());
        mailSender.setUsername(emailProperties.getUsername());
        mailSender.setPassword(emailProperties.getPassword());

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", String.valueOf(emailProperties.getProperties().getMail().getSmtp().isAuth()));
        props.put("mail.smtp.starttls.enable", String.valueOf(
                emailProperties.getProperties().getMail().getSmtp().getStarttls().isEnable()));

        // 개발 환경에서만 디버그 모드 활성화
        if (System.getProperty("spring.profiles.active", "").contains("dev")) {
            props.put("mail.debug", "true");
        }

        return mailSender;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/RefreshTokenCookieProperties.java
--------
package com.zzimcong.user.infrastructure.config;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;

@Component
@ConfigurationProperties(prefix = "auth.cookie.refresh-token")
@Validated
@Getter
@Setter
public class RefreshTokenCookieProperties {
    @NotBlank
    private String name;

    @Min(0)
    private int maxAge;

    private boolean httpOnly;
    private boolean secure;

    @NotBlank
    private String path;
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/RedisConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

@Configuration
@EnableCaching
public class RedisConfig {
    @Bean
    public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, String> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new StringRedisSerializer());
        return template;
    }

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(cacheConfig)
                .build();
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/WebConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import com.zzimcong.user.infrastructure.config.interceptor.TokenInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    private final TokenInterceptor tokenInterceptor;

    public WebConfig(TokenInterceptor tokenInterceptor) {
        this.tokenInterceptor = tokenInterceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(tokenInterceptor).addPathPatterns("/api/**");
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/SwaggerConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("찜콩 API")
                        .version("1.0")
                        .description("선착순 구매 기능이 있는 이커머스 서비스 API 문서"));
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/EmailProperties.java
--------
package com.zzimcong.user.infrastructure.config;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

@ConfigurationProperties(prefix = "email")
@Validated
@Data
public class EmailProperties {
    @NotBlank
    private String host;

    @Min(1)
    @Max(65535)
    private int port;

    @NotBlank
    private String username;

    @NotBlank
    private String password;

    private Properties properties = new Properties();

    @Data
    public static class Properties {
        private Mail mail = new Mail();

        @Data
        public static class Mail {
            private Smtp smtp = new Smtp();

            @Data
            public static class Smtp {
                private boolean auth;
                private Starttls starttls = new Starttls();

                @Data
                public static class Starttls {
                    private boolean enable;
                }
            }
        }
    }

    @NotBlank
    private String sender;

    @NotBlank
    private String subject;

    private Template template = new Template();
    private Verification verification = new Verification();

    @Data
    public static class Template {
        @NotBlank
        private String path;
    }

    @Data
    public static class Verification {
        private Code code = new Code();
        private Token token = new Token();

        @Data
        public static class Code {
            @Min(4)
            @Max(10)
            private int length = 6;

            private Expiry expiry = new Expiry();

            @Data
            public static class Expiry {
                @Min(60)
                @Max(600)
                private long seconds = 300;
            }
        }

        @Data
        public static class Token {
            private Expiry expiry = new Expiry();

            @Data
            public static class Expiry {
                @Min(5)
                @Max(60)
                private long minutes = 30;
            }
        }
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/JpaConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
@EnableJpaAuditing
public class JpaConfig {
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/interceptor/TokenInterceptor.java
--------
package com.zzimcong.user.infrastructure.config.interceptor;

import com.zzimcong.user.application.service.CookieService;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

@Component
public class TokenInterceptor implements HandlerInterceptor {

    private final CookieService cookieService;

    public TokenInterceptor(CookieService cookieService) {
        this.cookieService = cookieService;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {
        String refreshToken = (String) request.getAttribute("refreshToken");
        if (refreshToken != null) {
            Cookie refreshTokenCookie = cookieService.createRefreshTokenCookie(refreshToken);
            response.addCookie(refreshTokenCookie);
        }
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/CorsConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("http://localhost:3000"); // React 앱의 주소
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        source.registerCorsConfiguration("/api/**", config);
        return new CorsFilter(source);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/security/jwt/JwtUtil.java
--------
package com.zzimcong.user.infrastructure.security.jwt;

import com.zzimcong.user.common.exception.BadRequestException;
import com.zzimcong.user.common.exception.ErrorCode;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;
import java.util.function.Function;

@Slf4j(topic = "JWT_UTIL")
@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.access-token.expiration}")
    private long accessTokenExpiration;

    @Value("${jwt.refresh-token.expiration}")
    private long refreshTokenExpiration;

    private Key getSigningKey() {
        byte[] keyBytes = secret.getBytes();
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateAccessToken(Long id) {
        return generateToken(id, accessTokenExpiration);
    }


    public String generateRefreshToken(Long id) {
        return generateToken(id, refreshTokenExpiration);
    }

    private String generateToken(Long id, long expiration) {
        Date now = new Date(System.currentTimeMillis());
        Date expiryDate = new Date(now.getTime() + expiration * 1000);
        log.info("Generating token for subject: {}, expiration: {}", id, expiryDate);
        return Jwts.builder()
                .setSubject(String.valueOf(id))
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(expiryDate)
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public Long extractId(String token) {
        return Long.parseLong(extractClaim(token, Claims::getSubject));
    }

    public Boolean validateToken(String token, Long id) {
        final Long tokenId = extractId(token);
        return (tokenId.equals(id) && !isTokenExpired(token));
    }

    public Boolean validateToken(String token) {
        try {
            // 1. 토큰 파싱 및 서명 검증
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token);

            // 2. 추가적인 검증 (예: 만료 시간)
            Claims claims = extractAllClaims(token);
            return !isTokenExpired(claims);
        } catch (JwtException | IllegalArgumentException e) {
            log.error("Invalid JWT token", e);
            // 3. 예외 처리
            return false;
        }
    }

    private boolean isTokenExpired(Claims claims) {
        return claims.getExpiration().before(new Date());
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        try {
            return Jwts.parserBuilder().setSigningKey(getSigningKey()).build().parseClaimsJws(token).getBody();
        } catch (Exception ex) {
            log.error("Invalid JWT token", ex);
            throw new BadRequestException(ErrorCode.INVALID_TOKEN);
        }
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String extractJwtFromRequest(HttpServletRequest request) {
        String authorizationHeader = request.getHeader("Authorization");
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            return authorizationHeader.substring(7);
        }
        return null;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/security/jwt/JwtRequestFilter.java
--------
package com.zzimcong.user.infrastructure.security.jwt;

import com.zzimcong.user.api.response.ErrorResponse;
import com.zzimcong.user.common.exception.*;
import com.zzimcong.user.domain.entity.User;
import com.zzimcong.user.domain.repository.UserRepository;
import com.zzimcong.user.infrastructure.security.UserDetailsImpl;
import io.jsonwebtoken.ExpiredJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Slf4j(topic = "JWT_REQUEST_FILTER")
@Component
public class JwtRequestFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final UserRepository userRepository;

    public JwtRequestFilter(JwtUtil jwtUtil, UserRepository userRepository) {
        this.jwtUtil = jwtUtil;
        this.userRepository = userRepository;
    }
    
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/api/v1/auth/") || path.startsWith("/api/v1/email-verifications/");
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        try {
            Long id = null;
            String jwt = jwtUtil.extractJwtFromRequest(request);
            try {
                id = jwtUtil.extractId(jwt);
            } catch (ExpiredJwtException e) {
                log.warn("JWT 토큰이 만료되었습니다", e);
                throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
            } catch (Exception e) {
                log.error("JWT 토큰에서 id를 추출하는 중 오류가 발생했습니다", e);
                throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
            }

            if (id != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                User user = userRepository.findById(id)
                        .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

                if (jwtUtil.validateToken(jwt, user.getId())) {
                    UserDetailsImpl userDetails = new UserDetailsImpl(user);

                    UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                            userDetails, null, userDetails.getAuthorities());
                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                    SecurityContextHolder.getContext().setAuthentication(authToken);
                } else {
                    log.warn("JWT 토큰 검증에 실패했습니다");
                    throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
                }
            }

            chain.doFilter(request, response);
        } catch (Exception e) {
            log.error("JWT 토큰 검증 중 오류가 발생했습니다", e);
            ErrorResponse errorResponse = createErrorResponse(e, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
            response.getWriter().write(errorResponse.toString());
        }
    }

    // Create ErrorResponse
    private ErrorResponse createErrorResponse(Exception ex, HttpStatus status, String path) {
        logException(ex, status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.INTERNAL_SERVER_ERROR);
        return ErrorResponse.of(baseException, status, path);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        log.error(
                "\n\nException occurred:: Error Code: {}, HTTP Status: {}, Message: {}, Path: {}\n",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage(),
                path,
                ex
        );
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/security/SecurityConfig.java
--------
package com.zzimcong.user.infrastructure.security;

import com.zzimcong.user.infrastructure.security.jwt.JwtRequestFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JwtRequestFilter jwtRequestFilter;

    public SecurityConfig(JwtRequestFilter jwtRequestFilter) {
        this.jwtRequestFilter = jwtRequestFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().permitAll()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/security/UserDetailsImpl.java
--------
package com.zzimcong.user.infrastructure.security;

import com.zzimcong.user.domain.entity.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;

public class UserDetailsImpl implements UserDetails {
    private final User user;

    public UserDetailsImpl(User user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name()));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return String.valueOf(user.getId());
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/domain/repository/UserRepository.java
--------
package com.zzimcong.user.domain.repository;

import com.zzimcong.user.domain.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Boolean existsByEmail(String email);

    Optional<User> findByEmail(String email);
}


--------


File: ./user/src/main/java/com/zzimcong/user/domain/entity/UserRole.java
--------
package com.zzimcong.user.domain.entity;

public enum UserRole {
    USER, ADMIN, SELLER
}

--------


File: ./user/src/main/java/com/zzimcong/user/domain/entity/BaseEntity.java
--------
package com.zzimcong.user.domain.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@Setter
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
public abstract class BaseEntity {

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

}

--------


File: ./user/src/main/java/com/zzimcong/user/domain/entity/User.java
--------
package com.zzimcong.user.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;

@Entity
@Getter
@Setter
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long id;

    @Column(nullable = false, unique = true, length = 64)
    private String email;

    @Column(nullable = false, length = 64)
    private String name;

    @Column(nullable = false, length = 255)
    private String password;

    @Column(nullable = false, length = 64)
    private String phone;

    @Column(nullable = false)
    @ColumnDefault("false")
    private Boolean abuser = false;

    @Column(nullable = false)
    @ColumnDefault("false")
    private Boolean signout = false;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @ColumnDefault("'USER'")
    private UserRole role = UserRole.USER;
}


--------


File: ./user/src/main/java/com/zzimcong/user/domain/mapper/UserMapper.java
--------
package com.zzimcong.user.domain.mapper;

import com.zzimcong.user.application.dto.SignupRequest;
import com.zzimcong.user.application.dto.UserModifyRequest;
import com.zzimcong.user.application.dto.UserResponse;
import com.zzimcong.user.common.exception.InternalServerErrorException;
import com.zzimcong.user.common.util.AESUtil;
import com.zzimcong.user.domain.entity.User;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

@Component
public class UserMapper {
    private static final Logger logger = LoggerFactory.getLogger(UserMapper.class);
    private final AESUtil aesUtil;
    private final PasswordEncoder passwordEncoder;

    public UserMapper(PasswordEncoder passwordEncoder, AESUtil aesUtil) {
        this.aesUtil = aesUtil;
        this.passwordEncoder = passwordEncoder;
    }

    //Dto -> Entity 변환
    public User toEntity(SignupRequestDto dto) {
        if (dto == null) {
            return null;
        }
        User user = new User();
        try {
            user.setName(aesUtil.encrypt(dto.getName()));
            user.setEmail(aesUtil.encrypt(dto.getEmail()));
            user.setPhone(aesUtil.encrypt(dto.getPhone()));
            user.setPassword(passwordEncoder.encode(dto.getPassword()));
        } catch (InternalServerErrorException e) {
            logger.error("Error encrypting user data: {}", e.getMessage());
            throw e;
        }

        return user;
    }

    //Entity -> Dto 변환
    public UserResponseDto toDto(User user) {
        if (user == null) {
            return null;
        }
        UserResponseDto dto = new UserResponseDto();
        try {
            dto.setId(user.getId());
            dto.setEmail(aesUtil.decrypt(user.getEmail()));
            dto.setUsername(aesUtil.decrypt(user.getName()));
            dto.setPhone(aesUtil.decrypt(user.getPhone()));
        } catch (InternalServerErrorException e) {
            logger.error("Error decrypting user data: {}", e.getMessage());
            throw e;
        }

        return dto;
    }

    //Dto를 이용해 Entity 업데이트
    public User updateFromDto(User user, UserModifyRequestDto dto) {
        if (user == null || dto == null) {
            return null;
        }
        user.setName(aesUtil.encrypt(dto.getName()));
        user.setPhone(aesUtil.encrypt(dto.getPhone()));
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        return user;
    }
}


--------


File: ./product/src/test/java/com/zzimcong/product/ProductApplicationTests.java
--------
package com.zzimcong.product;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ProductApplicationTests {

    @Test
    void contextLoads() {
    }

}


--------


File: ./product/src/main/java/com/zzimcong/product/common/util/RedisUtil.java
--------
package com.zzimcong.product.common.util;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Service
@RequiredArgsConstructor
public class RedisUtil {
    private final StringRedisTemplate redisTemplate;//Redis에 접근하기 위한 Spring의 Redis 템플릿 클래스

    public String getData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 가져오는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        return valueOperations.get(key);
    }

    public void setData(String key, String value) {//지정된 키(key)에 값을 저장하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        valueOperations.set(key, value);
    }

    public void setDataExpire(String key, String value, long duration) {//지정된 키(key)에 값을 저장하고, 지정된 시간(duration) 후에 데이터가 만료되도록 설정하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        Duration expireDuration = Duration.ofSeconds(duration);
        valueOperations.set(key, value, expireDuration);
    }

    public void deleteData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 삭제하는 메서드
        redisTemplate.delete(key);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/UserInfo.java
--------
package com.zzimcong.product.common;

import lombok.Data;

@Data
public class UserInfo {
    private Long id;
    private String username;
    private String role;
    // 필요한 다른 필드들...
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/ErrorCode.java
--------
package com.zzimcong.product.common.exception;

import lombok.Getter;

@Getter
public enum ErrorCode {
    // BadRequestException (400)
    INVALID_INPUT("잘못된 입력입니다."),
    INVALID_QUANTITY("상품 수량은 1 이상이어야 합니다."),
    MISSING_REQUEST_BODY("요청 바디가 존재하지 않습니다."),

    // UnauthorizedException (401)

    // NotFoundException (404)
    RESOURCE_NOT_FOUND("요청한 리소스를 찾을 수 없습니다."),
    PRODUCT_NOT_FOUND("상품을 찾을 수 없습니다."),
    CART_PRODUCT_NOT_FOUND("장바구니 상품을 찾을 수 없습니다."),
    CATEGORY_NOT_FOUND("카테고리를 찾을 수 없습니다."),

    // MethodNotAllowedException (405)
    METHOD_NOT_ALLOWED("허용되지 않은 HTTP 메서드입니다."),

    // ConflictException (409)
    INSUFFICIENT_STOCK("상품의 재고가 부족합니다."),

    // InternalServerErrorException (500)
    RESOURCE_LOAD_FAILED("내부 리소스 로딩에 실패했습니다."),
    INTERNAL_SERVER_ERROR("서버 내부 오류가 발생했습니다.");

    private final String message;

    ErrorCode(String message) {
        this.message = message;
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/ForbiddenException.java
--------
package com.zzimcong.product.common.exception;

public class ForbiddenException extends BaseException {
    public ForbiddenException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ForbiddenException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/UnauthorizedException.java
--------
package com.zzimcong.product.common.exception;

public class UnauthorizedException extends BaseException {
    public UnauthorizedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public UnauthorizedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/ConflictException.java
--------
package com.zzimcong.product.common.exception;

public class ConflictException extends BaseException {
    public ConflictException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ConflictException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/MethodNotAllowedException.java
--------
package com.zzimcong.product.common.exception;

public class MethodNotAllowedException extends BaseException {
    public MethodNotAllowedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public MethodNotAllowedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/InternalServerErrorException.java
--------
package com.zzimcong.product.common.exception;

public class InternalServerErrorException extends BaseException {
    public InternalServerErrorException(ErrorCode errorCode) {
        super(errorCode);
    }

    public InternalServerErrorException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/GlobalExceptionHandler.java
--------
package com.zzimcong.product.common.exception;

import com.zzimcong.product.api.response.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j(topic = "GLOBAL_EXCEPTION_HANDLER")
@ControllerAdvice
public class GlobalExceptionHandler {
    // BadRequestException (400)
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorResponse> httpMessageNotReadableException(HttpServletRequest request) {
        BadRequestException ex = new BadRequestException(ErrorCode.MISSING_REQUEST_BODY);
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    // UnauthorizedException (401)
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(UnauthorizedException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.UNAUTHORIZED, request.getRequestURI());
    }

    // ForbiddenException (403)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbiddenException(ForbiddenException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.FORBIDDEN, request.getRequestURI());
    }

    // NotFoundException (404)
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.NOT_FOUND, request.getRequestURI());
    }

    // MethodNotAllowedException (405)
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowedException(HttpServletRequest request) {
        MethodNotAllowedException ex = new MethodNotAllowedException(ErrorCode.METHOD_NOT_ALLOWED);
        return createErrorResponse(ex, HttpStatus.METHOD_NOT_ALLOWED, request.getRequestURI());
    }

    // ConflictException (409)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(ConflictException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.CONFLICT, request.getRequestURI());
    }

    // InternalServerErrorException (500)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllException(Exception ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
    }

    // Create ErrorResponse
    private ResponseEntity<ErrorResponse> createErrorResponse(Exception ex, HttpStatus status, String path) {
        logException(ex, status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.INTERNAL_SERVER_ERROR);
        ErrorResponse errorResponse = ErrorResponse.of(baseException, status, path);
        return new ResponseEntity<>(errorResponse, status);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        // 스택 트레이스를 분석하여 예외 발생 위치 추출
        StackTraceElement[] stackTraceElements = ex.getStackTrace();
        String errorLocation = "Unknown";
        if (stackTraceElements.length > 0) {
            StackTraceElement element = stackTraceElements[0];
            errorLocation = String.format("%s.%s (Line: %d)",
                    element.getClassName(),
                    element.getMethodName(),
                    element.getLineNumber());
        }
        log.error(
                "Exception occurred:: {}, Path: {}",
                errorLocation,
                path
        );
        log.error("Error Code: {}, HTTP Status: {}, Message: {}",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage());
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/BadRequestException.java
--------
package com.zzimcong.product.common.exception;

public class BadRequestException extends BaseException {
    public BadRequestException(ErrorCode errorCode) {
        super(errorCode);
    }

    public BadRequestException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/BaseException.java
--------
package com.zzimcong.product.common.exception;

public class BaseException extends RuntimeException {
    private final ErrorCode errorCode;
    private final String message;

    public BaseException(ErrorCode errorCode) {
        this(errorCode, errorCode.getMessage());
    }

    public BaseException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.message = message;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    @Override
    public String getMessage() {
        return message;
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/NotFoundException.java
--------
package com.zzimcong.product.common.exception;

public class NotFoundException extends BaseException {
    public NotFoundException(ErrorCode errorCode) {
        super(errorCode);
    }

    public NotFoundException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/ProductApplication.java
--------
package com.zzimcong.product;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class ProductApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProductApplication.class, args);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/api/response/ApiResponse.java
--------
package com.zzimcong.product.api.response;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/api/response/ErrorResponse.java
--------
package com.zzimcong.product.api.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.zzimcong.product.common.exception.BaseException;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {
    private int status;
    private String message;
    private String errorCode;
    private LocalDateTime timestamp;
    private String path;

    public static ErrorResponse of(BaseException ex, HttpStatus status, String path) {
        ErrorResponse response = new ErrorResponse();
        response.setStatus(status.value());
        response.setMessage(ex.getMessage());
        response.setErrorCode(ex.getErrorCode().name());
        response.setTimestamp(LocalDateTime.now());
        response.setPath(path);
        return response;
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/api/controller/ProductController.java
--------
package com.zzimcong.product.api.controller;

import com.zzimcong.product.application.dto.*;
import com.zzimcong.product.application.service.ProductService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j(topic = "product-controller")
@RestController
@RequestMapping("/api/v1/products")
public class ProductController {
    private final ProductService productService;

    @Autowired
    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    //상품 목록 조회
    @GetMapping
    public ResponseEntity<List<ProductResponseDto>> getProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String search,
            @RequestParam(required = false) Long categoryId) {
        List<ProductResponseDto> products = productService.getProducts(page, size, search, categoryId);
        return ResponseEntity.ok(products);
    }

    //상품 등록
    @PostMapping
    public ResponseEntity<ProductResponseDto> createProduct(@RequestBody ProductRequestDto productRequestDto) {
        ProductResponseDto productResponseDto = productService.createProduct(productRequestDto);
        return ResponseEntity.ok(productResponseDto);
    }

    //상품 정보 조회
    @GetMapping("/{id}")
    public ResponseEntity<ProductResponseDto> getProductById(@PathVariable Long id) {
        ProductResponseDto productResponseDto = productService.getProductById(id);
        if (productResponseDto != null) {
            return ResponseEntity.ok(productResponseDto);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    //상품 정보 수정
    @PutMapping("/{id}")
    public ResponseEntity<ProductResponseDto> updateProduct(@PathVariable Long id, @RequestBody ProductRequestDto productRequestDto) {
        ProductResponseDto updatedProduct = productService.updateProduct(id, productRequestDto);
        if (updatedProduct != null) {
            return ResponseEntity.ok(updatedProduct);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    //상품 삭제
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> updateProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
        return ResponseEntity.ok().build();
    }


    @PostMapping("/{productId}/reserve")
    public ResponseEntity<ReserveInventoryResponse> reserveInventory(@PathVariable("productId") Long productId,
                                                                     @RequestBody ReserveInventoryRequest request) {
        ReserveInventoryResponse response = productService.reserveInventory(productId, request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/{productId}/release")
    public ResponseEntity<Void> releaseInventory(@PathVariable("productId") Long productId,
                                                 @RequestBody ReleaseInventoryRequest request) {
        productService.releaseInventory(productId, request);
        return ResponseEntity.noContent().build();
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/api/controller/CartController.java
--------
package com.zzimcong.product.api.controller;

import com.zzimcong.product.application.dto.CartItemDto;
import com.zzimcong.product.application.service.CartService;
import jakarta.validation.constraints.Min;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/cart")
public class CartController {
    private final CartService cartService;

    public CartController(CartService cartService) {
        this.cartService = cartService;
    }

    @GetMapping
    public ResponseEntity<List<CartItemDto>> getMyCart(@RequestHeader("X-Auth-User-ID") Long userId) {
        List<CartItemDto> cart = cartService.getCartItemsForUser(userId);
        return ResponseEntity.ok(cart);
    }

    @PostMapping("/{productId}")
    public ResponseEntity<String> addProductToCart(
            @RequestHeader("X-Auth-User-ID") Long userId,
            @PathVariable Long productId,
            @RequestParam @Min(value = 1, message = "수량은 1 이상이어야 합니다.") int count) {
        cartService.addProductToCart(userId, productId, count);
        return ResponseEntity.status(HttpStatus.CREATED).body("장바구니 추가 완료");
    }

    @PatchMapping("/{productId}")
    public ResponseEntity<String> updateProductCount(
            @RequestHeader("X-Auth-User-ID") Long userId,
            @PathVariable Long productId,
            @RequestParam @Min(value = 1, message = "수량은 1 이상이어야 합니다.") int count) {
        cartService.updateProductCount(userId, productId, count);
        return ResponseEntity.ok("수량 업데이트 완료");
    }

    @DeleteMapping("/{productId}")
    public ResponseEntity<Void> deleteProductFromCart(
            @RequestHeader("X-Auth-User-ID") Long userId,
            @PathVariable Long productId) {
        cartService.deleteProductFromCart(userId, productId);
        return ResponseEntity.noContent().build();
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/api/controller/CategoryController.java
--------
package com.zzimcong.product.api.controller;

import com.zzimcong.product.application.dto.CategoryCreateRequestDto;
import com.zzimcong.product.application.dto.CategoryDto;
import com.zzimcong.product.application.service.CategoryService;
import com.zzimcong.product.domain.entity.Category;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/categories")
public class CategoryController {
    private final CategoryService categoryService;

    @Autowired
    public CategoryController(CategoryService categoryService) {
        this.categoryService = categoryService;
    }

    //카테고리 목록 조회
    @GetMapping
    public List<CategoryDto> getCategories() {
        return categoryService.getAllCategories();
    }

    //카테고리 추가
    @PostMapping
    public ResponseEntity<Category> createCategory(@RequestBody CategoryCreateRequestDto request) {
        Category category = categoryService.createCategory(request.getName(), request.getParentCategoryId());
        return ResponseEntity.ok(category);
    }

    //카테고리 수정
    @PutMapping("/{id}")
    public CategoryDto updateCategory(@PathVariable Long id, @RequestBody CategoryDto categoryDto) {
        return categoryService.updateCategory(id, categoryDto);
    }

    //카테고리 삭제
    @DeleteMapping("/{id}")
    public void deleteCategory(@PathVariable Long id) {
        categoryService.deleteCategory(id);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/api/client/UserClient.java
--------
package com.zzimcong.product.api.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

@FeignClient(name = "user-service")
public interface UserClient {
    @GetMapping("/api/v1/auth/info")
    String getUserInfo();
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/ProductResponseDto.java
--------
package com.zzimcong.product.application.dto;

import com.zzimcong.product.domain.entity.Product;
import lombok.Data;

@Data
public class ProductResponseDto {
    private Long productId;
    private Long categoryId;
    private String name;
    private int price;
    private int sale;
    private String content;
    private String image;
    private int availableQuantity;
    private int reservedQuantity;
    private String createdAt;
    private boolean deleted;

    public ProductResponseDto(Product product) {
        this.productId = product.getId();
        this.categoryId = product.getCategory().getId();
        this.name = product.getName();
        this.price = product.getPrice();
        this.sale = product.getSale();
        this.content = product.getContent();
        this.image = product.getImage();
        this.availableQuantity = product.getAvailableQuantity();
        this.reservedQuantity = product.getReservedQuantity();
        this.createdAt = product.getCreatedAt().toString();
        this.deleted = product.isDeleted();
    }

    public static ProductResponseDto of(Product product) {
        return new ProductResponseDto(product);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/CategoryDto.java
--------
package com.zzimcong.product.application.dto;

import com.zzimcong.product.domain.entity.Category;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Getter
@Setter
@NoArgsConstructor
public class CategoryDto {
    private Long id;
    private String name;
    private Long parentCategoryId;
    private List<CategoryDto> childCategories;

    public CategoryDto(Category category) {
        this.id = category.getId();
        this.name = category.getName();
        this.parentCategoryId = category.getParentCategory() != null ? category.getParentCategory().getId() : null;
        this.childCategories = category.getChildCategories().stream()
                .map(CategoryDto::new)
                .collect(Collectors.toList());
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CategoryDto that = (CategoryDto) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    public static CategoryDto of(Category category) {
        return new CategoryDto(category);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/AddToCartRequestDto.java
--------
package com.zzimcong.product.application.dto;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class AddToCartRequestDto {
    private Long productId;
    private int count;
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/ProductRequestDto.java
--------
package com.zzimcong.product.application.dto;

import lombok.Data;

@Data
public class ProductRequestDto {
    private Long categoryId;
    private String name;
    private int price;
    private int sale;
    private String content;
    private String image;
    private int availableQuantity;
    private int reservedQuantity;
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/CategoryCreateRequestDto.java
--------
package com.zzimcong.product.application.dto;

import lombok.Data;

@Data
public class CategoryCreateRequestDto {
    private String name;
    private Long parentCategoryId;
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/ReleaseInventoryRequest.java
--------
package com.zzimcong.product.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ReleaseInventoryRequest {
    private int quantity;
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/CartItemDto.java
--------
package com.zzimcong.product.application.dto;

import com.zzimcong.product.domain.entity.CartItem;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class CartItemDto {
    private ProductResponseDto productResponseDto;
    private int count;

    //생성자
    public CartItemDto(CartItem cartItem) {
        this.productResponseDto = ProductResponseDto.of(cartItem.getProduct());
        this.count = cartItem.getCount();
    }

    //factory method
    public static CartItemDto of(CartItem cartItem) {
        return new CartItemDto(cartItem);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/ReserveInventoryResponse.java
--------
package com.zzimcong.product.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ReserveInventoryResponse {
    private boolean success;
    private String message;
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/ReserveInventoryRequest.java
--------
package com.zzimcong.product.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ReserveInventoryRequest {
    private int quantity;
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/service/CartService.java
--------
package com.zzimcong.product.application.service;

import com.zzimcong.product.application.dto.CartItemDto;
import com.zzimcong.product.common.exception.BadRequestException;
import com.zzimcong.product.common.exception.ConflictException;
import com.zzimcong.product.common.exception.ErrorCode;
import com.zzimcong.product.common.exception.NotFoundException;
import com.zzimcong.product.domain.entity.CartItem;
import com.zzimcong.product.domain.entity.Product;
import com.zzimcong.product.domain.repository.CartRepository;
import com.zzimcong.product.domain.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Slf4j(topic = "CartService")
@Service
@RequiredArgsConstructor
public class CartService {
    private final CartRepository cartRepository;
    private final ProductRepository productRepository;

    @Transactional(readOnly = true)
    public List<CartItemDto> getCartItemsForUser(Long userId) {
        List<CartItem> cartItems = cartRepository.findByUserId(userId);
        log.info("Retrieved {} cart products for user ID: {}", cartItems.size(), userId);
        return cartItems.stream()
                .map(CartItemDto::of)
                .toList();
    }

    @Transactional
    public void addProductToCart(Long userId, Long productId, int count) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.PRODUCT_NOT_FOUND));

        if (count <= 0) {
            throw new BadRequestException(ErrorCode.INVALID_QUANTITY);
        }

        if (product.getAvailableQuantity() < count) {
            throw new ConflictException(ErrorCode.INSUFFICIENT_STOCK);
        }

        Optional<CartItem> existingCartProduct = cartRepository.findByUserIdAndProductId(userId, productId);

        if (existingCartProduct.isPresent()) {
            CartItem cartItem = existingCartProduct.get();
            cartItem.setCount(cartItem.getCount() + count);
            cartRepository.save(cartItem);
            log.debug("Updated cart product quantity for user ID: {}, product ID: {}", userId, productId);
        } else {
            CartItem newCartItem = new CartItem(userId, product, count);
            cartRepository.save(newCartItem);
            log.debug("Added new product to cart for user ID: {}, product ID: {}", userId, productId);
        }

        productRepository.save(product);
    }

    @Transactional
    public void updateProductCount(Long userId, Long productId, int count) {
        CartItem cartItem = cartRepository.findByUserIdAndProductId(userId, productId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CART_PRODUCT_NOT_FOUND));

        if (count <= 0) {
            throw new BadRequestException(ErrorCode.INVALID_QUANTITY);
        }

        Product product = cartItem.getProduct();
        int stockDifference = count - cartItem.getCount();

        if (product.getAvailableQuantity() < stockDifference) {
            throw new ConflictException(ErrorCode.INSUFFICIENT_STOCK);
        }

        cartItem.setCount(count);
        cartRepository.save(cartItem);

        log.info("Updated cart product quantity for user ID: {}, product ID: {}, new quantity: {}", userId, productId, count);
    }

    @Transactional
    public void deleteProductFromCart(Long userId, Long productId) {
        CartItem cartItem = cartRepository.findByUserIdAndProductId(userId, productId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CART_PRODUCT_NOT_FOUND));

        cartRepository.delete(cartItem);
        log.info("Deleted product from cart for user ID: {}, product ID: {}", userId, productId);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/service/ProductService.java
--------
package com.zzimcong.product.application.service;

import com.zzimcong.product.application.dto.*;
import com.zzimcong.product.domain.entity.Category;
import com.zzimcong.product.domain.entity.Product;
import com.zzimcong.product.domain.repository.ProductRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;

@Slf4j(topic = "product-service")
@Service
public class ProductService {
    private final ProductRepository productRepository;
    private final CategoryService categoryService;

    @Autowired
    public ProductService(ProductRepository productRepository, CategoryService categoryService) {
        this.productRepository = productRepository;
        this.categoryService = categoryService;
    }

    //상품 등록
    public ProductResponseDto createProduct(ProductRequestDto productRequestDto) {
        Category category = categoryService.getCategoryById(productRequestDto.getCategoryId());
        Product product = new Product(productRequestDto, category);
        Product createdProduct = productRepository.save(product);
        return new ProductResponseDto(createdProduct);
    }

    //상품 조회
    public ProductResponseDto getProductById(Long id) {
        Product product = productRepository.findById(id).orElse(null);
        if (product != null) {
            return new ProductResponseDto(product);
        } else {
            return null;
        }
    }

    //상품 수정
    public ProductResponseDto updateProduct(Long id, ProductRequestDto productRequestDto) {
        Product updateProduct = productRepository.findById(id).orElse(null);
        if (updateProduct != null) {
            updateProduct.setName(productRequestDto.getName());
            updateProduct.setPrice(productRequestDto.getPrice());
            updateProduct.setSale(productRequestDto.getSale());
            updateProduct.setContent(productRequestDto.getContent());
            updateProduct.setImage(productRequestDto.getImage());
            updateProduct.setAvailableQuantity(productRequestDto.getAvailableQuantity());
            Category category = categoryService.getCategoryById(productRequestDto.getCategoryId());
            updateProduct.setCategory(category);
            Product updatedProduct = productRepository.save(updateProduct);
            return new ProductResponseDto(updatedProduct);
        } else {
            return null;
        }
    }

    public List<ProductResponseDto> getProducts(int page, int size, String search, Long categoryId) {
        List<Long> categoryIds = categoryId != null ?
                categoryService.findAllSubCategoryIds(categoryId) : null;

        Pageable pageable = PageRequest.of(page, size);
        Page<Product> productPage = productRepository.findAllWithFilters(search, categoryIds, pageable);

        if (productPage.isEmpty()) {
            log.warn("No products found for page: {}, size: {}, search: {}, categoryId: {}", page, size, search, categoryId);
            return Collections.emptyList();
        }

        return productPage.map(ProductResponseDto::of).getContent();
    }

    public void deleteProduct(Long id) {
        Product product = productRepository.findById(id).orElse(null);
        if (product != null) {
            product.setDeleted(true);
            productRepository.save(product);
        }
    }

    @Transactional
    public ReserveInventoryResponse reserveInventory(Long productId, ReserveInventoryRequest request) {
        try {
            // 상품 조회
            Product product = productRepository.findById(productId)
                    .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));

            int requestedQuantity = request.getQuantity();

            // 가용 재고 확인
            if (product.getAvailableQuantity() < requestedQuantity) {
                throw new IllegalStateException("가용 재고가 부족합니다.");
            }

            // 재고 예약
            product.setAvailableQuantity(product.getAvailableQuantity() - requestedQuantity);
            product.setReservedQuantity(product.getReservedQuantity() + requestedQuantity);
            productRepository.save(product);

            log.info("Reserved inventory for product {}: {} units", productId, requestedQuantity);

            return new ReserveInventoryResponse(true, "재고 예약 성공");
        } catch (IllegalArgumentException | IllegalStateException e) {
            log.error("Failed to reserve inventory for product {}: {}", productId, e.getMessage());
            return new ReserveInventoryResponse(false, e.getMessage());
        }
    }

    @Transactional
    public void releaseInventory(Long productId, ReleaseInventoryRequest request) {
        try {
            // 상품 조회
            Product product = productRepository.findById(productId)
                    .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));

            int releasedQuantity = request.getQuantity();

            // 예약된 재고 확인
            if (product.getReservedQuantity() < releasedQuantity) {
                throw new IllegalStateException("해제할 수 있는 예약 재고가 부족합니다.");
            }

            // 재고 해제
            product.setReservedQuantity(product.getReservedQuantity() - releasedQuantity);
            product.setAvailableQuantity(product.getAvailableQuantity() + releasedQuantity);
            productRepository.save(product);

            log.info("Released inventory for product {}: {} units", productId, releasedQuantity);
        } catch (IllegalArgumentException | IllegalStateException e) {
            log.error("Failed to release inventory for product {}: {}", productId, e.getMessage());
            throw e;
        }
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/service/InventoryService.java
--------
package com.zzimcong.product.application.service;

import com.zzimcong.product.domain.entity.InventoryEvent;
import com.zzimcong.product.domain.entity.InventoryEventType;
import com.zzimcong.product.domain.entity.Product;
import com.zzimcong.product.domain.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class InventoryService {
    private final ProductRepository productRepository;
    private final KafkaTemplate<String, InventoryEvent> kafkaTemplate;

    @Transactional
    public boolean reserveStock(Long productId, int quantity) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("제품을 찾을 수 없습니다."));

        if (product.getAvailableQuantity() >= quantity) {
            product.setReservedQuantity(product.getReservedQuantity() + quantity);
            product.setAvailableQuantity(product.getAvailableQuantity() - quantity);
            productRepository.save(product);

            kafkaTemplate.send("inventory-events", new InventoryEvent(productId, InventoryEventType.RESERVED, quantity));
            return true;
        }
        return false;
    }

    @Transactional
    public void confirmStockReduction(Long productId, int quantity) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("제품을 찾을 수 없습니다."));

        product.setReservedQuantity(product.getReservedQuantity() - quantity);
        productRepository.save(product);

        kafkaTemplate.send("inventory-events", new InventoryEvent(productId, InventoryEventType.CONFIRMED, quantity));
    }

    @Transactional
    public void cancelStockReservation(Long productId, int quantity) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("제품을 찾을 수 없습니다."));

        product.setReservedQuantity(product.getReservedQuantity() - quantity);
        product.setAvailableQuantity(product.getAvailableQuantity() + quantity);
        productRepository.save(product);

        kafkaTemplate.send("inventory-events", new InventoryEvent(productId, InventoryEventType.CANCELLED, quantity));
    }

    @Transactional
    public void restoreStock(Long productId, int quantity) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("제품을 찾을 수 없습니다."));

        product.setAvailableQuantity(product.getAvailableQuantity() + quantity);
        productRepository.save(product);

        kafkaTemplate.send("inventory-events", new InventoryEvent(productId, InventoryEventType.RESTORED, quantity));
    }

    public int getAvailableStock(Long productId) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("제품을 찾을 수 없습니다."));
        return product.getAvailableQuantity();
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/service/CategoryService.java
--------
package com.zzimcong.product.application.service;

import com.zzimcong.product.application.dto.CategoryDto;
import com.zzimcong.product.common.exception.ErrorCode;
import com.zzimcong.product.common.exception.NotFoundException;
import com.zzimcong.product.domain.entity.Category;
import com.zzimcong.product.domain.repository.CategoryRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Service
public class CategoryService {
    private final CategoryRepository categoryRepository;

    @Autowired
    public CategoryService(CategoryRepository categoryRepository) {
        this.categoryRepository = categoryRepository;
    }

    public List<CategoryDto> getAllCategories() {
        List<Category> allCategories = categoryRepository.findAllWithParent();
        log.debug("전체 카테고리 {}개를 조회했습니다.", allCategories.size());

        Map<Long, CategoryDto> categoryDtoMap = new HashMap<>();

        // 모든 카테고리를 DTO로 변환
        for (Category category : allCategories) {
            categoryDtoMap.put(category.getId(), CategoryDto.of(category));
        }

        // 부모-자식 관계 설정 (중복 검사 추가)
        for (Category category : allCategories) {
            if (category.getParentCategory() != null) {
                CategoryDto childDto = categoryDtoMap.get(category.getId());
                CategoryDto parentDto = categoryDtoMap.get(category.getParentCategory().getId());
                if (!parentDto.getChildCategories().contains(childDto)) {
                    parentDto.getChildCategories().add(childDto);
                }
            }
        }

        // 루트 카테고리만 필터링
        List<CategoryDto> rootCategories = categoryDtoMap.values().stream()
                .filter(dto -> dto.getParentCategoryId() == null)
                .collect(Collectors.toList());

        log.debug("최종적으로 {}개의 루트 카테고리를 반환합니다.", rootCategories.size());
        return rootCategories;
    }

    //카테고리 추가
    public Category createCategory(String name, Long parentId) {
        Category category = new Category();
        category.setName(name);

        if (parentId != null) {
            Category parentCategory = categoryRepository.findById(parentId)
                    .orElseThrow(() -> new NotFoundException(ErrorCode.CATEGORY_NOT_FOUND));
            category.setParentCategory(parentCategory);
            category.setPath(parentCategory.getPath() + parentCategory.getId() + "/");
        }

        return categoryRepository.save(category);
    }

    //카테고리 수정
    public CategoryDto updateCategory(Long id, CategoryDto categoryDto) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CATEGORY_NOT_FOUND));

        category.setName(categoryDto.getName());
        categoryRepository.save(category);

        return CategoryDto.of(category);
    }

    //카테고리 삭제
    public void deleteCategory(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CATEGORY_NOT_FOUND));

        categoryRepository.delete(category);
    }


    //서브 카테고리 조회
    public List<Long> findAllSubCategoryIds(Long categoryId) {
        Category category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CATEGORY_NOT_FOUND));

        List<Long> subCategoryIds = new ArrayList<>();
        subCategoryIds.add(categoryId);

        if (category.getPath() != null) {
            List<Category> subCategories = categoryRepository.findByPathStartingWith(category.getPath());
            subCategoryIds.addAll(subCategories.stream().map(Category::getId).toList());
        }

        return subCategoryIds;
    }


    public Category getCategoryById(Long categoryId) {
        return categoryRepository.findById(categoryId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CATEGORY_NOT_FOUND));
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/config/SecurityConfig.java
--------
package com.zzimcong.product.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .anyRequest().permitAll()
                )
                .httpBasic(Customizer.withDefaults());

        return http.build();
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/config/KafkaConfig.java
--------
package com.zzimcong.product.infrastructure.config;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.support.serializer.JsonSerializer;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Bean
    public <T> ProducerFactory<String, T> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public <T> KafkaTemplate<String, T> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/config/SwaggerConfig.java
--------
package com.zzimcong.product.infrastructure.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("찜콩 Product API")
                        .version("1.0")
                        .description("선착순 구매 기능이 있는 이커머스 서비스 API 문서"));
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/config/JpaConfig.java
--------
package com.zzimcong.product.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
@EnableJpaAuditing
public class JpaConfig {
}

--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/config/CorsConfig.java
--------
package com.zzimcong.product.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CorsConfig {

    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("http://localhost:3000"); // React 앱의 주소
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        source.registerCorsConfiguration("/api/**", config);
        return new CorsFilter(source);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/KafkaProducer.java
--------
package com.zzimcong.product.infrastructure;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.stereotype.Component;

import java.util.concurrent.CompletableFuture;

@Component
public class KafkaProducer<T> {
    private static final Logger logger = LoggerFactory.getLogger(KafkaProducer.class);

    private final KafkaTemplate<String, T> kafkaTemplate;

    public KafkaProducer(KafkaTemplate<String, T> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    public void send(String topic, T payload) {
        logger.info("Sending Kafka message to topic: {} with payload: {}", topic, payload);
        CompletableFuture<SendResult<String, T>> future = kafkaTemplate.send(topic, payload);

        future.whenComplete((result, ex) -> {
            if (ex == null) {
                logger.info("Message sent successfully to topic: {}", topic);
            } else {
                logger.error("Failed to send message to topic: {}", topic, ex);
            }
        });
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/repository/ProductRepository.java
--------
package com.zzimcong.product.domain.repository;

import com.zzimcong.product.domain.entity.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Query("SELECT p FROM Product p LEFT JOIN FETCH p.category WHERE (:search IS NULL OR p.name LIKE %:search%) AND p.category.id IN :categoryIds")
    Page<Product> findAllWithFilters(
            @Param("search") String search,
            @Param("categoryIds") List<Long> categoryIds,
            Pageable pageable
    );
}


--------


File: ./product/src/main/java/com/zzimcong/product/domain/repository/CartRepository.java
--------
package com.zzimcong.product.domain.repository;

import com.zzimcong.product.domain.entity.CartItem;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface CartRepository extends JpaRepository<CartItem, Long> {
    List<CartItem> findByUserId(Long userId);

    Optional<CartItem> findByUserIdAndProductId(Long userId, Long productId);

    void deleteByUserIdAndProductId(Long userId, Long productId);
}


--------


File: ./product/src/main/java/com/zzimcong/product/domain/repository/CategoryRepository.java
--------
package com.zzimcong.product.domain.repository;

import com.zzimcong.product.domain.entity.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.util.List;

public interface CategoryRepository extends JpaRepository<Category, Long> {
    @Query("SELECT DISTINCT c FROM Category c LEFT JOIN FETCH c.parentCategory")
    List<Category> findAllWithParent();

    List<Category> findByPathStartingWith(String path);
}


--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/Product.java
--------
package com.zzimcong.product.domain.entity;

import com.zzimcong.product.application.dto.ProductRequestDto;
import jakarta.persistence.*;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@Entity
@Table(name = "products")  // 복수형 사용
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "product_id")
    private Long id;

    @NotBlank
    @Size(max = 255)
    @Column(nullable = false)
    private String name;

    @Min(0)
    @Column(nullable = false)
    private int price;

    @Min(0)
    @Column(nullable = false)
    private int sale;

    @Column(columnDefinition = "TEXT")
    private String content;

    @Size(max = 255)
    private String image;

    @Column(nullable = false)
    private int availableQuantity;

    @Column(nullable = false)
    private int reservedQuantity;

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(nullable = false)
    private boolean deleted = false;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    private Category category;

    protected Product() {
    }

    public Product(ProductRequestDto productRequestDto, Category category) {
        this.name = productRequestDto.getName();
        this.price = productRequestDto.getPrice();
        this.sale = productRequestDto.getSale();
        this.content = productRequestDto.getContent();
        this.image = productRequestDto.getImage();
        this.availableQuantity = productRequestDto.getAvailableQuantity();
        this.reservedQuantity = productRequestDto.getReservedQuantity();
        this.category = category;
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/Category.java
--------
package com.zzimcong.product.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@Entity
@Table(name = "categories")
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "category_id")
    private Long id;

    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_category_id")
    private Category parentCategory;

    @OneToMany(mappedBy = "parentCategory")
    private List<Category> childCategories = new ArrayList<>();

    private int depth;
    private String path;
}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/BaseEntity.java
--------
package com.zzimcong.product.domain.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@Setter
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
public abstract class BaseEntity {

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/CartItem.java
--------
package com.zzimcong.product.domain.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Min;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "cart_items")  // 복수형 사용
public class CartItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "cart_item_id")
    private Long id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Min(1)
    @Column(nullable = false)
    private int count;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    public CartItem(Long userId, Product product, int count) {
        this.userId = userId;
        this.product = product;
        this.count = count;
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/InventoryEventType.java
--------
package com.zzimcong.product.domain.entity;

public enum InventoryEventType {
    RESERVED, CONFIRMED, CANCELLED, RESTORED
}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/InventoryEvent.java
--------
package com.zzimcong.product.domain.entity;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class InventoryEvent {
    private Long productId;
    private InventoryEventType eventType;
    private int quantity;
}

--------


