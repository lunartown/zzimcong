File: ./order/bin/generated-sources/annotations/com/zzimcong/order/application/mapper/OrderMapperImpl.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderAddressResponse;
import com.zzimcong.order.application.dto.OrderItemResponse;
import com.zzimcong.order.application.dto.OrderResponse;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderAddress;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.entity.PaymentType;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-23T23:27:36+0900",
    comments = "version: 1.5.3.Final, compiler: Eclipse JDT (IDE) 3.39.0.v20240725-1906, environment: Java 17.0.11 (Eclipse Adoptium)"
)
@Component
public class OrderMapperImpl implements OrderMapper {

    @Autowired
    private OrderItemMapper orderItemMapper;

    @Override
    public OrderResponse orderToOrderResponse(Order order) {
        if ( order == null ) {
            return null;
        }

        List<OrderItemResponse> items = null;
        Long id = null;
        Long userId = null;
        BigDecimal orderAmount = null;
        BigDecimal paymentAmount = null;
        OrderStatus status = null;
        boolean deleted = false;
        OrderAddressResponse orderAddress = null;

        items = orderItemListToOrderItemResponseList( order.getOrderItems() );
        id = order.getId();
        userId = order.getUserId();
        orderAmount = order.getOrderAmount();
        paymentAmount = order.getPaymentAmount();
        status = order.getStatus();
        deleted = order.isDeleted();
        orderAddress = orderAddressToOrderAddressResponse( order.getOrderAddress() );

        PaymentType payment = null;
        String reason = null;

        OrderResponse orderResponse = new OrderResponse( id, userId, orderAmount, paymentAmount, payment, status, deleted, reason, orderAddress, items );

        return orderResponse;
    }

    protected List<OrderItemResponse> orderItemListToOrderItemResponseList(List<OrderItem> list) {
        if ( list == null ) {
            return null;
        }

        List<OrderItemResponse> list1 = new ArrayList<OrderItemResponse>( list.size() );
        for ( OrderItem orderItem : list ) {
            list1.add( orderItemMapper.orderItemToOrderItemResponse( orderItem ) );
        }

        return list1;
    }

    protected OrderAddressResponse orderAddressToOrderAddressResponse(OrderAddress orderAddress) {
        if ( orderAddress == null ) {
            return null;
        }

        String name = null;
        String streetAddress = null;
        String addressDetail = null;
        String zipcode = null;
        String phone = null;
        String message = null;

        name = orderAddress.getName();
        streetAddress = orderAddress.getStreetAddress();
        addressDetail = orderAddress.getAddressDetail();
        zipcode = orderAddress.getZipcode();
        phone = orderAddress.getPhone();
        message = orderAddress.getMessage();

        OrderAddressResponse orderAddressResponse = new OrderAddressResponse( name, streetAddress, addressDetail, zipcode, phone, message );

        return orderAddressResponse;
    }
}


--------


File: ./order/bin/generated-sources/annotations/com/zzimcong/order/application/mapper/OrderRequestMapperImpl.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderAddressRequest;
import com.zzimcong.order.application.dto.OrderCreationRequest;
import com.zzimcong.order.application.dto.OrderItemRequest;
import com.zzimcong.order.application.dto.OrderPreparationRequest;
import com.zzimcong.order.application.dto.PaymentDetailsRequest;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderAddress;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.entity.PaymentDetails;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-23T23:27:37+0900",
    comments = "version: 1.5.3.Final, compiler: Eclipse JDT (IDE) 3.39.0.v20240725-1906, environment: Java 17.0.11 (Eclipse Adoptium)"
)
@Component
public class OrderRequestMapperImpl implements OrderRequestMapper {

    @Override
    public Order orderPreperationRequestToOrder(OrderPreparationRequest orderPreparationRequest) {
        if ( orderPreparationRequest == null ) {
            return null;
        }

        Order order = new Order();

        order.setOrderItems( orderItemRequestListToOrderItemList( orderPreparationRequest.items() ) );
        order.setOrderAmount( orderPreparationRequest.orderAmount() );
        order.setPaymentAmount( orderPreparationRequest.paymentAmount() );

        order.setStatus( OrderStatus.TEMP );
        order.setDeleted( false );

        linkOrderItems( order );

        return order;
    }

    @Override
    public OrderItem orderItemRequestToOrderItem(OrderItemRequest orderItemRequest) {
        if ( orderItemRequest == null ) {
            return null;
        }

        OrderItem orderItem = new OrderItem();

        orderItem.setPrice( orderItemRequest.price() );
        orderItem.setProductId( orderItemRequest.productId() );
        orderItem.setQuantity( orderItemRequest.quantity() );

        return orderItem;
    }

    @Override
    public void updateOrderFromRequest(OrderCreationRequest orderCreationRequest, Order order) {
        if ( orderCreationRequest == null ) {
            return;
        }

        if ( orderCreationRequest.orderAddressRequest() != null ) {
            order.setOrderAddress( orderAddressRequestToOrderAddress( orderCreationRequest.orderAddressRequest() ) );
        }
        if ( orderCreationRequest.paymentDetailsRequest() != null ) {
            order.setPaymentDetails( paymentDetailsRequestToPaymentDetails( orderCreationRequest.paymentDetailsRequest() ) );
        }

        linkOrderItems( order );
        logMappingResult( orderCreationRequest, order );
    }

    @Override
    public OrderAddress orderAddressRequestToOrderAddress(OrderAddressRequest orderAddressRequest) {
        if ( orderAddressRequest == null ) {
            return null;
        }

        OrderAddress orderAddress = new OrderAddress();

        orderAddress.setAddressDetail( orderAddressRequest.addressDetail() );
        orderAddress.setMessage( orderAddressRequest.message() );
        orderAddress.setName( orderAddressRequest.name() );
        orderAddress.setPhone( orderAddressRequest.phone() );
        orderAddress.setStreetAddress( orderAddressRequest.streetAddress() );
        orderAddress.setZipcode( orderAddressRequest.zipcode() );

        return orderAddress;
    }

    @Override
    public PaymentDetails paymentDetailsRequestToPaymentDetails(PaymentDetailsRequest paymentDetailsRequest) {
        if ( paymentDetailsRequest == null ) {
            return null;
        }

        PaymentDetails paymentDetails = new PaymentDetails();

        paymentDetails.setCardHolderName( paymentDetailsRequest.cardHolderName() );
        paymentDetails.setCardNumber( paymentDetailsRequest.cardNumber() );
        paymentDetails.setCvv( paymentDetailsRequest.cvv() );
        paymentDetails.setExpirationDate( paymentDetailsRequest.expirationDate() );
        paymentDetails.setPaymentMethod( paymentDetailsRequest.paymentMethod() );

        return paymentDetails;
    }

    protected List<OrderItem> orderItemRequestListToOrderItemList(List<OrderItemRequest> list) {
        if ( list == null ) {
            return null;
        }

        List<OrderItem> list1 = new ArrayList<OrderItem>( list.size() );
        for ( OrderItemRequest orderItemRequest : list ) {
            list1.add( orderItemRequestToOrderItem( orderItemRequest ) );
        }

        return list1;
    }
}


--------


File: ./order/bin/generated-sources/annotations/com/zzimcong/order/application/mapper/OrderItemMapperImpl.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderItemResponse;
import com.zzimcong.order.domain.entity.OrderItem;
import java.math.BigDecimal;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-23T23:27:34+0900",
    comments = "version: 1.5.3.Final, compiler: Eclipse JDT (IDE) 3.39.0.v20240725-1906, environment: Java 17.0.11 (Eclipse Adoptium)"
)
@Component
public class OrderItemMapperImpl implements OrderItemMapper {

    @Override
    public OrderItemResponse orderItemToOrderItemResponse(OrderItem orderItem) {
        if ( orderItem == null ) {
            return null;
        }

        Long id = null;
        Long productId = null;
        BigDecimal price = null;
        Integer quantity = null;

        id = orderItem.getId();
        productId = orderItem.getProductId();
        price = orderItem.getPrice();
        quantity = orderItem.getQuantity();

        OrderItemResponse orderItemResponse = new OrderItemResponse( id, productId, price, quantity );

        return orderItemResponse;
    }

    @Override
    public OrderItem orderItemResponseToOrderItem(OrderItemResponse orderItemResponse) {
        if ( orderItemResponse == null ) {
            return null;
        }

        OrderItem orderItem = new OrderItem();

        orderItem.setId( orderItemResponse.id() );
        orderItem.setPrice( orderItemResponse.price() );
        orderItem.setProductId( orderItemResponse.productId() );
        orderItem.setQuantity( orderItemResponse.quantity() );

        return orderItem;
    }

    @Override
    public void updateOrderItemFromResponse(OrderItemResponse orderItemResponse, OrderItem orderItem) {
        if ( orderItemResponse == null ) {
            return;
        }

        if ( orderItemResponse.id() != null ) {
            orderItem.setId( orderItemResponse.id() );
        }
        if ( orderItemResponse.price() != null ) {
            orderItem.setPrice( orderItemResponse.price() );
        }
        if ( orderItemResponse.productId() != null ) {
            orderItem.setProductId( orderItemResponse.productId() );
        }
        if ( orderItemResponse.quantity() != null ) {
            orderItem.setQuantity( orderItemResponse.quantity() );
        }
    }
}


--------


File: ./order/build/generated/sources/annotationProcessor/java/main/com/zzimcong/order/application/mapper/OrderMapperImpl.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderAddressResponse;
import com.zzimcong.order.application.dto.OrderItemResponse;
import com.zzimcong.order.application.dto.OrderResponse;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderAddress;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.entity.PaymentType;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-23T11:25:28+0900",
    comments = "version: 1.5.3.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.8.jar, environment: Java 22.0.1 (Eclipse Adoptium)"
)
@Component
public class OrderMapperImpl implements OrderMapper {

    @Autowired
    private OrderItemMapper orderItemMapper;

    @Override
    public OrderResponse orderToOrderResponse(Order order) {
        if ( order == null ) {
            return null;
        }

        List<OrderItemResponse> items = null;
        Long id = null;
        Long userId = null;
        BigDecimal orderAmount = null;
        BigDecimal paymentAmount = null;
        OrderStatus status = null;
        boolean deleted = false;
        OrderAddressResponse orderAddress = null;

        items = orderItemListToOrderItemResponseList( order.getOrderItems() );
        id = order.getId();
        userId = order.getUserId();
        orderAmount = order.getOrderAmount();
        paymentAmount = order.getPaymentAmount();
        status = order.getStatus();
        deleted = order.isDeleted();
        orderAddress = orderAddressToOrderAddressResponse( order.getOrderAddress() );

        PaymentType payment = null;
        String reason = null;

        OrderResponse orderResponse = new OrderResponse( id, userId, orderAmount, paymentAmount, payment, status, deleted, reason, orderAddress, items );

        return orderResponse;
    }

    protected List<OrderItemResponse> orderItemListToOrderItemResponseList(List<OrderItem> list) {
        if ( list == null ) {
            return null;
        }

        List<OrderItemResponse> list1 = new ArrayList<OrderItemResponse>( list.size() );
        for ( OrderItem orderItem : list ) {
            list1.add( orderItemMapper.orderItemToOrderItemResponse( orderItem ) );
        }

        return list1;
    }

    protected OrderAddressResponse orderAddressToOrderAddressResponse(OrderAddress orderAddress) {
        if ( orderAddress == null ) {
            return null;
        }

        String name = null;
        String streetAddress = null;
        String addressDetail = null;
        String zipcode = null;
        String phone = null;
        String message = null;

        name = orderAddress.getName();
        streetAddress = orderAddress.getStreetAddress();
        addressDetail = orderAddress.getAddressDetail();
        zipcode = orderAddress.getZipcode();
        phone = orderAddress.getPhone();
        message = orderAddress.getMessage();

        OrderAddressResponse orderAddressResponse = new OrderAddressResponse( name, streetAddress, addressDetail, zipcode, phone, message );

        return orderAddressResponse;
    }
}


--------


File: ./order/build/generated/sources/annotationProcessor/java/main/com/zzimcong/order/application/mapper/OrderRequestMapperImpl.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderAddressRequest;
import com.zzimcong.order.application.dto.OrderCreationRequest;
import com.zzimcong.order.application.dto.OrderItemRequest;
import com.zzimcong.order.application.dto.OrderPreparationRequest;
import com.zzimcong.order.application.dto.PaymentDetailsRequest;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderAddress;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.entity.PaymentDetails;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-23T11:25:28+0900",
    comments = "version: 1.5.3.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.8.jar, environment: Java 22.0.1 (Eclipse Adoptium)"
)
@Component
public class OrderRequestMapperImpl implements OrderRequestMapper {

    @Override
    public Order orderPreperationRequestToOrder(OrderPreparationRequest orderPreparationRequest) {
        if ( orderPreparationRequest == null ) {
            return null;
        }

        Order order = new Order();

        order.setOrderItems( orderItemRequestListToOrderItemList( orderPreparationRequest.items() ) );
        order.setOrderAmount( orderPreparationRequest.orderAmount() );
        order.setPaymentAmount( orderPreparationRequest.paymentAmount() );

        order.setStatus( OrderStatus.TEMP );
        order.setDeleted( false );

        linkOrderItems( order );

        return order;
    }

    @Override
    public OrderItem orderItemRequestToOrderItem(OrderItemRequest orderItemRequest) {
        if ( orderItemRequest == null ) {
            return null;
        }

        OrderItem orderItem = new OrderItem();

        orderItem.setProductId( orderItemRequest.productId() );
        orderItem.setPrice( orderItemRequest.price() );
        orderItem.setQuantity( orderItemRequest.quantity() );

        return orderItem;
    }

    @Override
    public void updateOrderFromRequest(OrderCreationRequest orderCreationRequest, Order order) {
        if ( orderCreationRequest == null ) {
            return;
        }

        if ( orderCreationRequest.orderAddressRequest() != null ) {
            order.setOrderAddress( orderAddressRequestToOrderAddress( orderCreationRequest.orderAddressRequest() ) );
        }
        if ( orderCreationRequest.paymentDetailsRequest() != null ) {
            order.setPaymentDetails( paymentDetailsRequestToPaymentDetails( orderCreationRequest.paymentDetailsRequest() ) );
        }

        linkOrderItems( order );
        logMappingResult( orderCreationRequest, order );
    }

    @Override
    public OrderAddress orderAddressRequestToOrderAddress(OrderAddressRequest orderAddressRequest) {
        if ( orderAddressRequest == null ) {
            return null;
        }

        OrderAddress orderAddress = new OrderAddress();

        orderAddress.setName( orderAddressRequest.name() );
        orderAddress.setStreetAddress( orderAddressRequest.streetAddress() );
        orderAddress.setAddressDetail( orderAddressRequest.addressDetail() );
        orderAddress.setZipcode( orderAddressRequest.zipcode() );
        orderAddress.setPhone( orderAddressRequest.phone() );
        orderAddress.setMessage( orderAddressRequest.message() );

        return orderAddress;
    }

    @Override
    public PaymentDetails paymentDetailsRequestToPaymentDetails(PaymentDetailsRequest paymentDetailsRequest) {
        if ( paymentDetailsRequest == null ) {
            return null;
        }

        PaymentDetails paymentDetails = new PaymentDetails();

        paymentDetails.setPaymentMethod( paymentDetailsRequest.paymentMethod() );
        paymentDetails.setCardNumber( paymentDetailsRequest.cardNumber() );
        paymentDetails.setCardHolderName( paymentDetailsRequest.cardHolderName() );
        paymentDetails.setExpirationDate( paymentDetailsRequest.expirationDate() );
        paymentDetails.setCvv( paymentDetailsRequest.cvv() );

        return paymentDetails;
    }

    protected List<OrderItem> orderItemRequestListToOrderItemList(List<OrderItemRequest> list) {
        if ( list == null ) {
            return null;
        }

        List<OrderItem> list1 = new ArrayList<OrderItem>( list.size() );
        for ( OrderItemRequest orderItemRequest : list ) {
            list1.add( orderItemRequestToOrderItem( orderItemRequest ) );
        }

        return list1;
    }
}


--------


File: ./order/build/generated/sources/annotationProcessor/java/main/com/zzimcong/order/application/mapper/OrderItemMapperImpl.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderItemResponse;
import com.zzimcong.order.domain.entity.OrderItem;
import java.math.BigDecimal;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-23T11:25:28+0900",
    comments = "version: 1.5.3.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.8.jar, environment: Java 22.0.1 (Eclipse Adoptium)"
)
@Component
public class OrderItemMapperImpl implements OrderItemMapper {

    @Override
    public OrderItemResponse orderItemToOrderItemResponse(OrderItem orderItem) {
        if ( orderItem == null ) {
            return null;
        }

        Long id = null;
        Long productId = null;
        BigDecimal price = null;
        Integer quantity = null;

        id = orderItem.getId();
        productId = orderItem.getProductId();
        price = orderItem.getPrice();
        quantity = orderItem.getQuantity();

        OrderItemResponse orderItemResponse = new OrderItemResponse( id, productId, price, quantity );

        return orderItemResponse;
    }

    @Override
    public OrderItem orderItemResponseToOrderItem(OrderItemResponse orderItemResponse) {
        if ( orderItemResponse == null ) {
            return null;
        }

        OrderItem orderItem = new OrderItem();

        orderItem.setId( orderItemResponse.id() );
        orderItem.setProductId( orderItemResponse.productId() );
        orderItem.setPrice( orderItemResponse.price() );
        orderItem.setQuantity( orderItemResponse.quantity() );

        return orderItem;
    }

    @Override
    public void updateOrderItemFromResponse(OrderItemResponse orderItemResponse, OrderItem orderItem) {
        if ( orderItemResponse == null ) {
            return;
        }

        if ( orderItemResponse.id() != null ) {
            orderItem.setId( orderItemResponse.id() );
        }
        if ( orderItemResponse.productId() != null ) {
            orderItem.setProductId( orderItemResponse.productId() );
        }
        if ( orderItemResponse.price() != null ) {
            orderItem.setPrice( orderItemResponse.price() );
        }
        if ( orderItemResponse.quantity() != null ) {
            orderItem.setQuantity( orderItemResponse.quantity() );
        }
    }
}


--------


File: ./order/src/test/java/com/zzimcong/order/application/saga/OrderSagaTest.java
--------
//package com.zzimcong.order.application.saga;
//
//import com.fasterxml.jackson.databind.ObjectMapper;
//import com.zzimcong.order.application.dto.*;
//import com.zzimcong.order.application.mapper.OrderRequestMapper;
//import com.zzimcong.order.application.service.ProductService;
//import com.zzimcong.order.common.exception.InternalServerErrorException;
//import com.zzimcong.order.domain.entity.Order;
//import com.zzimcong.order.domain.entity.OrderStatus;
//import com.zzimcong.order.domain.repository.OrderRepository;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.mockito.InjectMocks;
//import org.mockito.Mock;
//import org.mockito.MockitoAnnotations;
//import org.springframework.data.redis.core.RedisTemplate;
//import org.springframework.data.redis.core.ValueOperations;
//import org.springframework.kafka.core.KafkaTemplate;
//
//import java.math.BigDecimal;
//import java.util.Collections;
//import java.util.concurrent.CompletableFuture;
//
//import static org.junit.jupiter.api.Assertions.*;
//import static org.mockito.ArgumentMatchers.*;
//import static org.mockito.Mockito.*;
//
//class OrderSagaTest {
//
//    @Mock
//    private ProductService productService;
//    @Mock
//    private OrderRequestMapper orderRequestMapper;
//    @Mock
//    private ObjectMapper objectMapper;
//    @Mock
//    private RedisTemplate<String, String> redisTemplate;
//    @Mock
//    private OrderRepository orderRepository;
//    @Mock
//    private KafkaTemplate<String, PaymentRequest> kafkaTemplate;
//    @Mock
//    private ValueOperations<String, String> valueOperations;
//
//    @InjectMocks
//    private OrderSaga orderSaga;
//
//    @BeforeEach
//    void setUp() {
//        MockitoAnnotations.openMocks(this);
//        when(redisTemplate.opsForValue()).thenReturn(valueOperations);
//    }
//
//    @Test
//    void testPrepareOrder() throws Exception {
//        OrderPreparationRequest request = new OrderPreparationRequest(
//                BigDecimal.TEN, BigDecimal.TEN,
//                Collections.singletonList(new OrderItemRequest(1L, BigDecimal.ONE, 1))
//        );
//
//        when(productService.reserveInventory(anyLong(), anyInt())).thenReturn(true);
//        when(orderRequestMapper.orderPreperationRequestToOrder(any())).thenReturn(new Order());
//        when(objectMapper.writeValueAsString(any())).thenReturn("{}");
//        when(valueOperations.setIfAbsent(anyString(), anyString(), any())).thenReturn(true);
//
//        OrderPreparationResponse response = orderSaga.prepareOrder(1L, request);
//
//        assertNotNull(response);
//        assertEquals(OrderPreparationStatus.SUCCESS, response.status());
//        verify(productService).reserveInventory(anyLong(), anyInt());
//        verify(orderRequestMapper).orderPreperationRequestToOrder(any());
//        verify(objectMapper).writeValueAsString(any());
//        verify(valueOperations).setIfAbsent(anyString(), anyString(), any());
//    }
//
//    @Test
//    void testCreateOrder() throws Exception {
//        OrderCreationRequest request = new OrderCreationRequest(
//                new OrderAddressRequest("name", "street", "detail", "12345", "1234567890", "message"),
//                new PaymentDetailsRequest(null, "1234", "John Doe", "12/24", "123")
//        );
//
//        Order order = new Order();
//        order.setPaymentAmount(BigDecimal.TEN);
//
//        when(valueOperations.get(anyString())).thenReturn("{}");
//        when(objectMapper.readValue(anyString(), eq(Order.class))).thenReturn(order);
//        when(kafkaTemplate.send(anyString(), any(PaymentRequest.class))).thenReturn(mock(CompletableFuture.class));
//
//        assertDoesNotThrow(() -> orderSaga.createOrder(1L, "uuid", request));
//
//        verify(valueOperations).get(anyString());
//        verify(objectMapper).readValue(anyString(), eq(Order.class));
//        verify(orderRequestMapper).updateOrderFromRequest(any(), any());
//        verify(kafkaTemplate).send(anyString(), any(PaymentRequest.class));
//    }
//
//    @Test
//    void testHandlePaymentResult() throws Exception {
//        PaymentResponse result = new PaymentResponse(1L, "uuid", true);
//        Order order = new Order();
//
//        when(valueOperations.get(anyString())).thenReturn("{}");
//        when(objectMapper.readValue(anyString(), eq(Order.class))).thenReturn(order);
//        when(orderRepository.save(any(Order.class))).thenReturn(order);
//
//        orderSaga.handlePaymentResult(result);
//
//        verify(valueOperations).get(anyString());
//        verify(objectMapper).readValue(anyString(), eq(Order.class));
//        verify(orderRepository).save(any(Order.class));
//        verify(redisTemplate).delete(anyString());
//    }
//
//    @Test
//    void testProcessSuccessfulPayment() {
//        Order order = new Order();
//        when(orderRepository.save(any(Order.class))).thenReturn(order);
//
//        assertDoesNotThrow(() -> orderSaga.processSuccessfulPayment(order));
//
//        assertEquals(OrderStatus.ORDER_COMPLETED, order.getStatus());
//        verify(orderRepository).save(order);
//    }
//
//    @Test
//    void testProcessSuccessfulPaymentFailed() {
//        Order order = new Order();
//        when(orderRepository.save(any(Order.class))).thenThrow(new RuntimeException("DB Error"));
//
//        assertThrows(InternalServerErrorException.class, () -> orderSaga.processSuccessfulPayment(order));
//    }
//}

--------


File: ./order/src/test/java/com/zzimcong/order/application/service/OrderServiceTest.java
--------
//package com.zzimcong.order.application.service;
//
//import com.zzimcong.order.application.dto.OrderResponse;
//import com.zzimcong.order.application.mapper.OrderMapper;
//import com.zzimcong.order.common.exception.NotFoundException;
//import com.zzimcong.order.domain.entity.Order;
//import com.zzimcong.order.domain.entity.OrderStatus;
//import com.zzimcong.order.domain.repository.OrderRepository;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.mockito.InjectMocks;
//import org.mockito.Mock;
//import org.mockito.MockitoAnnotations;
//import org.springframework.data.domain.Page;
//import org.springframework.data.domain.PageImpl;
//import org.springframework.data.domain.PageRequest;
//import org.springframework.kafka.core.KafkaTemplate;
//
//import java.util.Arrays;
//import java.util.List;
//import java.util.Optional;
//
//import static org.junit.jupiter.api.Assertions.*;
//import static org.mockito.ArgumentMatchers.any;
//import static org.mockito.ArgumentMatchers.eq;
//import static org.mockito.Mockito.*;
//
//class OrderServiceTest {
//
//    @Mock
//    private OrderRepository orderRepository;
//
//    @Mock
//    private OrderMapper orderMapper;
//
//    @Mock
//    private KafkaTemplate<String, Order> kafkaTemplate;
//
//    @InjectMocks
//    private OrderService orderService;
//
//    @BeforeEach
//    void setUp() {
//        MockitoAnnotations.openMocks(this);
//    }
//
//    @Test
//    void testGetOrder() {
//        Order order = new Order();
//        order.setId(1L);
//
//        when(orderRepository.findById(1L)).thenReturn(Optional.of(order));
//
//        Order result = orderService.getOrder(1L);
//
//        assertNotNull(result);
//        assertEquals(1L, result.getId());
//
//        verify(orderRepository, times(1)).findById(1L);
//    }
//
//    @Test
//    void testGetOrderNotFound() {
//        when(orderRepository.findById(1L)).thenReturn(Optional.empty());
//
//        assertThrows(NotFoundException.class, () -> orderService.getOrder(1L));
//
//        verify(orderRepository, times(1)).findById(1L);
//    }
//
//    @Test
//    void testGetOrderResponse() {
//        Order order = new Order();
//        order.setId(1L);
//
//        OrderResponse orderResponse = new OrderResponse(1L, 1L, null, null, null, null, false, null, null, null);
//
//        when(orderRepository.findById(1L)).thenReturn(Optional.of(order));
//        when(orderMapper.orderToOrderResponse(order)).thenReturn(orderResponse);
//
//        OrderResponse result = orderService.getOrderResponse(1L);
//
//        assertNotNull(result);
//        assertEquals(1L, result.id());
//
//        verify(orderRepository, times(1)).findById(1L);
//        verify(orderMapper, times(1)).orderToOrderResponse(order);
//    }
//
//    @Test
//    void testGetOrderList() {
//        Order order1 = new Order();
//        Order order2 = new Order();
//        List<Order> orders = Arrays.asList(order1, order2);
//        Page<Order> orderPage = new PageImpl<>(orders);
//
//        OrderResponse orderResponse1 = new OrderResponse(1L, 1L, null, null, null, null, false, null, null, null);
//        OrderResponse orderResponse2 = new OrderResponse(2L, 1L, null, null, null, null, false, null, null, null);
//
//        when(orderRepository.findAll(any(PageRequest.class))).thenReturn(orderPage);
//        when(orderMapper.orderToOrderResponse(order1)).thenReturn(orderResponse1);
//        when(orderMapper.orderToOrderResponse(order2)).thenReturn(orderResponse2);
//
//        Page<OrderResponse> result = orderService.getOrderList(PageRequest.of(0, 10));
//
//        assertNotNull(result);
//        assertEquals(2, result.getContent().size());
//
//        verify(orderRepository, times(1)).findAll(any(PageRequest.class));
//        verify(orderMapper, times(2)).orderToOrderResponse(any(Order.class));
//    }
//
//    @Test
//    void testGetUserOrders() {
//        Order order1 = new Order();
//        Order order2 = new Order();
//        List<Order> orders = Arrays.asList(order1, order2);
//        Page<Order> orderPage = new PageImpl<>(orders);
//
//        OrderResponse orderResponse1 = new OrderResponse(1L, 1L, null, null, null, null, false, null, null, null);
//        OrderResponse orderResponse2 = new OrderResponse(2L, 1L, null, null, null, null, false, null, null, null);
//
//        when(orderRepository.findByUserId(eq(1L), any(PageRequest.class))).thenReturn(orderPage);
//        when(orderMapper.orderToOrderResponse(order1)).thenReturn(orderResponse1);
//        when(orderMapper.orderToOrderResponse(order2)).thenReturn(orderResponse2);
//
//        Page<OrderResponse> result = orderService.getUserOrders(1L, PageRequest.of(0, 10));
//
//        assertNotNull(result);
//        assertEquals(2, result.getContent().size());
//
//        verify(orderRepository, times(1)).findByUserId(eq(1L), any(PageRequest.class));
//        verify(orderMapper, times(2)).orderToOrderResponse(any(Order.class));
//    }
//
//    @Test
//    void testUpdateOrderStatus() {
//        Order order = new Order();
//        order.setId(1L);
//        order.setStatus(OrderStatus.ORDER_COMPLETED);
//
//        when(orderRepository.save(any(Order.class))).thenReturn(order);
//
//        orderService.updateOrderStatus(order, OrderStatus.SHIPPING);
//
//        assertEquals(OrderStatus.SHIPPING, order.getStatus());
//
//        verify(orderRepository, times(1)).save(order);
//    }
//
//    @Test
//    void testCancelOrderByOrderId() {
//        Order order = new Order();
//        order.setId(1L);
//        order.setStatus(OrderStatus.ORDER_COMPLETED);
//
//        when(orderRepository.findById(1L)).thenReturn(Optional.of(order));
//
//        orderService.cancelOrderByOrderId(1L);
//
//        verify(orderRepository, times(1)).findById(1L);
//        verify(kafkaTemplate, times(1)).send(eq("refund-request"), eq(order));
//    }
//
//    @Test
//    void testRequestRefund() {
//        Order order = new Order();
//        order.setId(1L);
//        order.setStatus(OrderStatus.DELIVERED);
//
//        when(orderRepository.findById(1L)).thenReturn(Optional.of(order));
//
//        orderService.requestRefund(1L);
//
//        assertEquals(OrderStatus.REFUND_REQUESTED, order.getStatus());
//
//        verify(orderRepository, times(1)).findById(1L);
//        verify(orderRepository, times(1)).save(order);
//    }
//
//    @Test
//    void testIsOrderOwnedByUser() {
//        Order order = new Order();
//        order.setId(1L);
//        order.setUserId(1L);
//
//        when(orderRepository.findById(1L)).thenReturn(Optional.of(order));
//
//        boolean result = orderService.isOrderOwnedByUser(1L, 1L);
//
//        assertTrue(result);
//
//        verify(orderRepository, times(1)).findById(1L);
//    }
//}

--------


File: ./order/src/test/java/com/zzimcong/order/application/service/ShippingServiceTest.java
--------
//package com.zzimcong.order.application.service;
//
//import com.zzimcong.order.domain.entity.Order;
//import com.zzimcong.order.domain.entity.OrderStatus;
//import com.zzimcong.order.domain.repository.OrderRepository;
//import com.zzimcong.zzimconginventorycore.common.event.ShippingEvent;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.mockito.InjectMocks;
//import org.mockito.Mock;
//import org.mockito.MockitoAnnotations;
//import org.springframework.kafka.core.KafkaTemplate;
//
//import java.time.LocalDateTime;
//import java.util.Arrays;
//import java.util.List;
//
//import static org.mockito.Mockito.*;
//
//class ShippingServiceTest {
//
//    @Mock
//    private OrderRepository orderRepository;
//
//    @Mock
//    private KafkaTemplate<String, ShippingEvent> kafkaTemplate;
//
//    @InjectMocks
//    private ShippingService shippingService;
//
//    @BeforeEach
//    void setUp() {
//        MockitoAnnotations.openMocks(this);
//    }
//
//    @Test
//    void testUpdateOrdersToPreparing() {
//        Order order1 = new Order();
//        order1.setId(1L);
//        Order order2 = new Order();
//        order2.setId(2L);
//        List<Order> orders = Arrays.asList(order1, order2);
//
//        when(orderRepository.findByStatusAndCreatedAtBefore(eq(OrderStatus.ORDER_COMPLETED), any(LocalDateTime.class)))
//                .thenReturn(orders);
//
//        shippingService.updateOrdersToPreparing();
//
//        verify(kafkaTemplate, times(2)).send(eq("shipping-events"), any(ShippingEvent.class));
//    }
//
//    @Test
//    void testUpdateOrdersToShipping() {
//        Order order1 = new Order();
//        order1.setId(1L);
//        Order order2 = new Order();
//        order2.setId(2L);
//        List<Order> orders = Arrays.asList(order1, order2);
//
//        when(orderRepository.findByStatus(OrderStatus.PREPARING_FOR_SHIPMENT)).thenReturn(orders);
//
//        shippingService.updateOrdersToShipping();
//
//        verify(kafkaTemplate, times(2)).send(eq("shipping-events"), any(ShippingEvent.class));
//    }
//
//    @Test
//    void testUpdateOrdersToDelivered() {
//        Order order1 = new Order();
//        order1.setId(1L);
//        Order order2 = new Order();
//        order2.setId(2L);
//        List<Order> orders = Arrays.asList(order1, order2);
//
//        when(orderRepository.findByStatus(OrderStatus.SHIPPING)).thenReturn(orders);
//
//        shippingService.updateOrdersToDelivered();
//
//        verify(kafkaTemplate, times(2)).send(eq("shipping-events"), any(ShippingEvent.class));
//    }
//
//    @Test
//    void testAutoRefundOrders() {
//        Order order1 = new Order();
//        order1.setId(1L);
//        Order order2 = new Order();
//        order2.setId(2L);
//        List<Order> orders = Arrays.asList(order1, order2);
//
//        when(orderRepository.findByStatusAndDeliveredAtBefore(eq(OrderStatus.REFUND_REQUESTED), any(LocalDateTime.class)))
//                .thenReturn(orders);
//
//        shippingService.autoRefundOrders();
//
//        verify(kafkaTemplate, times(2)).send(eq("shipping-events"), any(ShippingEvent.class));
//    }
//}

--------


File: ./order/src/test/java/com/zzimcong/order/application/service/ProductServiceTest.java
--------
//package com.zzimcong.order.application.service;
//
//import com.zzimcong.order.api.client.ProductServiceClient;
//import com.zzimcong.order.application.dto.ReleaseInventoryRequest;
//import com.zzimcong.order.application.dto.ReserveInventoryRequest;
//import com.zzimcong.order.application.dto.ReserveInventoryResponse;
//import feign.FeignException;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.mockito.InjectMocks;
//import org.mockito.Mock;
//import org.mockito.MockitoAnnotations;
//
//import static org.junit.jupiter.api.Assertions.*;
//import static org.mockito.ArgumentMatchers.*;
//import static org.mockito.Mockito.*;
//
//class ProductServiceTest {
//
//    @Mock
//    private ProductServiceClient productServiceClient;
//
//    @InjectMocks
//    private ProductService productService;
//
//    @BeforeEach
//    void setUp() {
//        MockitoAnnotations.openMocks(this);
//    }
//
//    @Test
//    void testReserveInventorySuccess() {
//        when(productServiceClient.reserveInventory(anyLong(), any(ReserveInventoryRequest.class)))
//                .thenReturn(new ReserveInventoryResponse(true, "Success"));
//
//        boolean result = productService.reserveInventory(1L, 5);
//
//        assertTrue(result);
//        verify(productServiceClient).reserveInventory(eq(1L), any(ReserveInventoryRequest.class));
//    }
//
//    @Test
//    void testReserveInventoryFailure() {
//        when(productServiceClient.reserveInventory(anyLong(), any(ReserveInventoryRequest.class)))
//                .thenReturn(new ReserveInventoryResponse(false, "Failed"));
//
//        boolean result = productService.reserveInventory(1L, 5);
//
//        assertFalse(result);
//        verify(productServiceClient).reserveInventory(eq(1L), any(ReserveInventoryRequest.class));
//    }
//
//    @Test
//    void testReserveInventoryException() {
//        when(productServiceClient.reserveInventory(anyLong(), any(ReserveInventoryRequest.class)))
//                .thenThrow(FeignException.class);
//
//        assertThrows(RuntimeException.class, () -> productService.reserveInventory(1L, 5));
//    }
//
//    @Test
//    void testReleaseInventory() {
//        doNothing().when(productServiceClient).releaseInventory(anyLong(), any(ReleaseInventoryRequest.class));
//
//        assertDoesNotThrow(() -> productService.releaseInventory(1L, 5));
//        verify(productServiceClient).releaseInventory(eq(1L), any(ReleaseInventoryRequest.class));
//    }
//}

--------


File: ./order/src/test/java/com/zzimcong/order/application/service/PaymentServiceTest.java
--------
//package com.zzimcong.order.application.service;
//
//import com.zzimcong.order.application.dto.PaymentRequest;
//import com.zzimcong.order.application.dto.PaymentResponse;
//import com.zzimcong.order.application.dto.RefundResponse;
//import com.zzimcong.order.domain.entity.Order;
//import com.zzimcong.order.domain.entity.OrderStatus;
//import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.mockito.InjectMocks;
//import org.mockito.Mock;
//import org.mockito.MockitoAnnotations;
//import org.springframework.kafka.core.KafkaTemplate;
//
//import java.math.BigDecimal;
//
//import static org.mockito.Mockito.*;
//
//class PaymentServiceTest {
//
//    @Mock
//    private KafkaTemplate<String, KafkaMessage> kafkaTemplate;
//
//    @InjectMocks
//    private PaymentService paymentService;
//
//    @BeforeEach
//    void setUp() {
//        MockitoAnnotations.openMocks(this);
//    }
//
//    @Test
//    void testProcessPayment() {
//        PaymentRequest request = new PaymentRequest(1L, "uuid", null, BigDecimal.TEN);
//
//        paymentService.processPayment(request);
//
//        verify(kafkaTemplate).send(eq("payment-results"), any(PaymentResponse.class));
//    }
//
//    @Test
//    void testRefundPayment() {
//        Order order = new Order();
//        order.setId(1L);
//        order.setUserId(1L);
//        order.setPaymentAmount(BigDecimal.TEN);
//        order.setStatus(OrderStatus.REFUND_REQUESTED);
//
//        paymentService.refundPayment(order);
//
//        verify(kafkaTemplate).send(eq("refund-results"), any(RefundResponse.class));
//    }
//}

--------


File: ./order/src/test/java/com/zzimcong/order/OrderApplicationTests.java
--------
//package com.zzimcong.order;
//
//import org.junit.jupiter.api.Test;
//import org.springframework.boot.test.context.SpringBootTest;
//
//@SpringBootTest
//class OrderApplicationTests {
//
//    @Test
//    void contextLoads() {
//    }
//
//}


--------


File: ./order/src/main/java/com/zzimcong/order/OrderApplication.java
--------
package com.zzimcong.order;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.statemachine.config.EnableStateMachine;

@SpringBootApplication
@EnableFeignClients
@EnableStateMachine
@EnableScheduling
public class OrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/common/util/RedisUtil.java
--------
package com.zzimcong.order.common.util;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Service
@RequiredArgsConstructor
public class RedisUtil {
    private final StringRedisTemplate redisTemplate;//Redis에 접근하기 위한 Spring의 Redis 템플릿 클래스

    public String getData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 가져오는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        return valueOperations.get(key);
    }

    public void setData(String key, String value) {//지정된 키(key)에 값을 저장하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        valueOperations.set(key, value);
    }

    public void setDataExpire(String key, String value, long duration) {//지정된 키(key)에 값을 저장하고, 지정된 시간(duration) 후에 데이터가 만료되도록 설정하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        Duration expireDuration = Duration.ofSeconds(duration);
        valueOperations.set(key, value, expireDuration);
    }

    public void deleteData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 삭제하는 메서드
        redisTemplate.delete(key);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/ErrorCode.java
--------
package com.zzimcong.order.common.exception;

import lombok.Getter;

@Getter
public enum ErrorCode {
    // BadRequestException (400)
    INVALID_INPUT("잘못된 입력입니다."),
    INVALID_ORDER_STATUS("유효하지 않은 주문 상태입니다."),
    MISSING_REQUEST_BODY("요청 바디가 없습니다."),
    PAYMENT_FAILED("결제에 실패했습니다."),

    // UnauthorizedException (401)

    // ForbiddenException (403)
    ACCESS_DENIED("접근이 거부되었습니다."),

    // NotFoundException (404)
    RESOURCE_NOT_FOUND("요청한 리소스를 찾을 수 없습니다."),
    TEMP_ORDER_NOT_FOUND("임시 주문을 찾을 수 없습니다."),
    ORDER_NOT_FOUND("주문을 찾을 수 없습니다."),

    // MethodNotAllowedException (405)
    METHOD_NOT_ALLOWED("허용되지 않은 HTTP 메서드입니다."),

    // ConflictException (409)
    INSUFFICIENT_STOCK("상품의 재고가 부족합니다."),
    CANNOT_CANCEL_ORDER("주문을 취소할 수 없습니다."),

    // InternalServerErrorException (500)
    ORDER_UPDATE_FAILED("주문 정보 업데이트 중 오류가 발생했습니다."),
    PAYMENT_RESULT_PROCESSING_FAILED("결제 결과 처리 중 오류가 발생했습니다."),
    PAYMENT_REQUEST_FAILED("결제 요청 전송 중 오류가 발생했습니다."),
    RESERVE_INVENTORY_FAILED("재고 예약 중 오류가 발생했습니다."),
    ORDER_SAVE_FAILED("주문 저장 중 오류가 발생했습니다."),
    RESOURCE_LOAD_FAILED("내부 리소스 로딩에 실패했습니다."),
    INTERNAL_SERVER_ERROR("서버 내부 오류가 발생했습니다."),
    UNKNOWN_ERROR("알 수 없는 오류가 발생했습니다.");

    private final String message;

    ErrorCode(String message) {
        this.message = message;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/ForbiddenException.java
--------
package com.zzimcong.order.common.exception;

public class ForbiddenException extends BaseException {
    public ForbiddenException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ForbiddenException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/UnauthorizedException.java
--------
package com.zzimcong.order.common.exception;

public class UnauthorizedException extends BaseException {
    public UnauthorizedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public UnauthorizedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/ConflictException.java
--------
package com.zzimcong.order.common.exception;

public class ConflictException extends BaseException {
    public ConflictException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ConflictException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/MethodNotAllowedException.java
--------
package com.zzimcong.order.common.exception;

public class MethodNotAllowedException extends BaseException {
    public MethodNotAllowedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public MethodNotAllowedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/InternalServerErrorException.java
--------
package com.zzimcong.order.common.exception;

public class InternalServerErrorException extends BaseException {
    public InternalServerErrorException(ErrorCode errorCode) {
        super(errorCode);
    }

    public InternalServerErrorException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/GlobalExceptionHandler.java
--------
package com.zzimcong.order.common.exception;

import com.zzimcong.order.api.response.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j(topic = "GLOBAL_EXCEPTION_HANDLER")
@ControllerAdvice
public class GlobalExceptionHandler {
    // BadRequestException (400)
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorResponse> httpMessageNotReadableException(HttpServletRequest request) {
        BadRequestException ex = new BadRequestException(ErrorCode.MISSING_REQUEST_BODY);
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    // UnauthorizedException (401)
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(UnauthorizedException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.UNAUTHORIZED, request.getRequestURI());
    }

    // ForbiddenException (403)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbiddenException(ForbiddenException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.FORBIDDEN, request.getRequestURI());
    }

    // NotFoundException (404)
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.NOT_FOUND, request.getRequestURI());
    }

    // MethodNotAllowedException (405)
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowedException(HttpServletRequest request) {
        MethodNotAllowedException ex = new MethodNotAllowedException(ErrorCode.METHOD_NOT_ALLOWED);
        return createErrorResponse(ex, HttpStatus.METHOD_NOT_ALLOWED, request.getRequestURI());
    }

    // ConflictException (409)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(ConflictException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.CONFLICT, request.getRequestURI());
    }

    // InternalServerErrorException (500)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllException(Exception ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
    }

    // Create ErrorResponse
    private ResponseEntity<ErrorResponse> createErrorResponse(Exception ex, HttpStatus status, String path) {
        logException(ex, status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.INTERNAL_SERVER_ERROR);
        ErrorResponse errorResponse = ErrorResponse.of(status, baseException, path);
        return new ResponseEntity<>(errorResponse, status);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        // 스택 트레이스를 분석하여 예외 발생 위치 추출
        StackTraceElement[] stackTraceElements = ex.getStackTrace();
        String errorLocation = "Unknown";
        if (stackTraceElements.length > 0) {
            StackTraceElement element = stackTraceElements[0];
            errorLocation = String.format("%s.%s (Line: %d)",
                    element.getClassName(),
                    element.getMethodName(),
                    element.getLineNumber());
        }
        log.error(
                "Exception occurred:: {}, Path: {}",
                errorLocation,
                path
        );
        log.error("Error Code: {}, HTTP Status: {}, Message: {}",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage());
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/BadRequestException.java
--------
package com.zzimcong.order.common.exception;

public class BadRequestException extends BaseException {
    public BadRequestException(ErrorCode errorCode) {
        super(errorCode);
    }

    public BadRequestException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/InventoryException.java
--------
package com.zzimcong.order.common.exception;

public class InventoryException extends BaseException {
    public InventoryException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/BaseException.java
--------
package com.zzimcong.order.common.exception;

public class BaseException extends RuntimeException {
    private final ErrorCode errorCode;
    private final String message;

    public BaseException(ErrorCode errorCode) {
        this(errorCode, errorCode.getMessage());
    }

    public BaseException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.message = message;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    @Override
    public String getMessage() {
        return message;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/common/exception/NotFoundException.java
--------
package com.zzimcong.order.common.exception;

public class NotFoundException extends BaseException {
    public NotFoundException(ErrorCode errorCode) {
        super(errorCode);
    }

    public NotFoundException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/api/response/ApiResponse.java
--------
package com.zzimcong.order.api.response;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }
}


--------


File: ./order/src/main/java/com/zzimcong/order/api/response/ErrorResponse.java
--------
package com.zzimcong.order.api.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.zzimcong.order.common.exception.BaseException;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {
    private int status;
    private String message;
    private String errorCode;
    private LocalDateTime timestamp;
    private String path;

    public static ErrorResponse of(HttpStatus status, BaseException ex, String path) {
        ErrorResponse response = new ErrorResponse();
        response.setStatus(status.value());
        response.setMessage(ex.getMessage());
        response.setErrorCode(ex.getErrorCode().name());
        response.setTimestamp(LocalDateTime.now());
        response.setPath(path);
        return response;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/api/controller/OrderController.java
--------
package com.zzimcong.order.api.controller;

import com.zzimcong.order.application.dto.OrderCreationRequest;
import com.zzimcong.order.application.dto.OrderPreparationRequest;
import com.zzimcong.order.application.dto.OrderPreparationResponse;
import com.zzimcong.order.application.dto.OrderResponse;
import com.zzimcong.order.application.saga.OrderSaga;
import com.zzimcong.order.application.service.OrderService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j(topic = "order-service")
@RestController
@RequestMapping("/api/v1/orders")
public class OrderController {
    private final OrderService orderService;
    private final OrderSaga orderSaga;

    @Autowired
    public OrderController(OrderService orderService, OrderSaga orderSaga) {
        this.orderService = orderService;
        this.orderSaga = orderSaga;
    }

    // 주문창 이동
    @PostMapping("/prepare")
    public ResponseEntity<OrderPreparationResponse> prepareOrder(@RequestHeader("X-Auth-User-ID") Long userId,
                                                                 @RequestBody OrderPreparationRequest request) {
        OrderPreparationResponse response = orderSaga.prepareOrder(userId, request);
        return ResponseEntity.ok(response);
    }

    // 사용자 정보 입력 완료, 결제 호출
    @PostMapping("/create/{uuid}")
    public ResponseEntity<Void> createOrder(@RequestHeader("X-Auth-User-ID") Long userId,
                                            @PathVariable String uuid,
                                            @RequestBody OrderCreationRequest request) {
        log.info("Confirming order ID: {} for user ID: {}", uuid, userId);
        orderSaga.createOrder(userId, uuid, request);
        return ResponseEntity.accepted().build();
    }

    @PostMapping("/{orderId}/cancel")
    public ResponseEntity<Void> cancelOrder(@RequestHeader("X-Auth-User-ID") Long userId,
                                            @PathVariable Long orderId) {
        orderService.cancelOrderByOrderId(orderId);
        return ResponseEntity.accepted().build();
    }

    @PostMapping("/{orderId}/refund")
    public ResponseEntity<Void> requestRefund(@PathVariable Long orderId) {
        orderService.requestRefund(orderId);
        return ResponseEntity.accepted().build();
    }

    @GetMapping("/{orderId}")
    public ResponseEntity<OrderResponse> getOrder(@RequestHeader("X-Auth-User-ID") Long userId,
                                                  @PathVariable Long orderId) {
        OrderResponse orderResponse = orderService.getOrderResponse(orderId);
        return ResponseEntity.ok(orderResponse);
    }

    @GetMapping
    public ResponseEntity<Page<OrderResponse>> getOrderList(@RequestParam(defaultValue = "0") int page,
                                                            @RequestParam(defaultValue = "10") int size) {
        PageRequest pageRequest = PageRequest.of(page, size);
        Page<OrderResponse> responsePages = orderService.getOrderList(pageRequest);
        return ResponseEntity.ok(responsePages);
    }

    @GetMapping("/user")
    public ResponseEntity<Page<OrderResponse>> getUserOrders(@RequestHeader("X-Auth-User-ID") Long userId,
                                                             @RequestParam(defaultValue = "0") int page,
                                                             @RequestParam(defaultValue = "10") int size) {
        PageRequest pageRequest = PageRequest.of(page, size);
        Page<OrderResponse> orderPage = orderService.getUserOrders(userId, pageRequest);
        return ResponseEntity.ok(orderPage);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/api/client/ProductServiceClient.java
--------
package com.zzimcong.order.api.client;

import com.zzimcong.order.application.dto.ReleaseInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "product-service")
public interface ProductServiceClient {
    @PostMapping("/api/v1/products/{productId}/reserve")
    ReserveInventoryResponse reserveInventory(@PathVariable("productId") Long productId,
                                              @RequestBody ReserveInventoryRequest request);

    @PostMapping("/api/v1/products/{productId}/release")
    void releaseInventory(@PathVariable("productId") Long productId,
                          @RequestBody ReleaseInventoryRequest request);
}

--------


File: ./order/src/main/java/com/zzimcong/order/api/client/UserServiceClient.java
--------
package com.zzimcong.order.api.client;

import org.springframework.cloud.openfeign.FeignClient;

@FeignClient(name = "user-service")  // URL 제거, 서비스 이름만 사용
public interface UserServiceClient {
//    @GetMapping("/users/{userId}")
//    UserDto getUserById(@PathVariable("userId") Long userId);
}

--------


File: ./order/src/main/java/com/zzimcong/order/aspect/OrderAuthorizationAspect.java
--------
//package com.zzimcong.order.aspect;
//
//import com.zzimcong.order.application.service.OrderService;
//import com.zzimcong.order.common.exception.ErrorCode;
//import com.zzimcong.order.common.exception.ForbiddenException;
//import jakarta.servlet.http.HttpServletRequest;
//import org.aspectj.lang.JoinPoint;
//import org.aspectj.lang.annotation.Aspect;
//import org.aspectj.lang.annotation.Before;
//import org.springframework.stereotype.Component;
//import org.springframework.web.context.request.RequestContextHolder;
//import org.springframework.web.context.request.ServletRequestAttributes;
//
//@Aspect
//@Component
//public class OrderAuthorizationAspect {
//
//    private final OrderService orderService;
//
//    public OrderAuthorizationAspect(OrderService orderService) {
//        this.orderService = orderService;
//    }
//
//    @Before("execution(* com.zzimcong.order.api.controller.OrderFulfillmentController.*(.., Long, ..))")
//    public void validateUserAuthorization(JoinPoint joinPoint) {
//        // HTTP 요청에서 사용자 ID 추출
//        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();
//        String userId = request.getHeader("X-Auth-User-ID");
//
//        // orderId 파라미터 찾기
//        Long orderId = null;
//        Object[] args = joinPoint.getArgs();
//        for (Object arg : args) {
//            if (arg instanceof Long) {
//                orderId = (Long) arg;
//                break;
//            }
//        }
//
//        if (orderId == null) {
//            throw new IllegalArgumentException("주문 ID를 찾을 수 없습니다.");
//        }
//
//        if (userId == null) {
//            throw new ForbiddenException(ErrorCode.ACCESS_DENIED, "사용자 인증 정보가 없습니다.");
//        }
//
//        if (!orderService.isOrderOwnedByUser(orderId, Long.parseLong(userId))) {
//            throw new ForbiddenException(ErrorCode.ACCESS_DENIED, "주문 접근 권한이 없습니다.");
//        }
//    }
//}

--------


File: ./order/src/main/java/com/zzimcong/order/aspect/LoggingAspect.java
--------
package com.zzimcong.order.aspect;

import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Slf4j
@Aspect
@Component
public class LoggingAspect {

    @Around("execution(* com.zzimcong.order.api.controller.*.*(..))")
    public Object logAroundMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();
        String userId = request.getHeader("X-Auth-User-ID");

        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();

        // 메서드 실행 전 로깅
        log.info("User ID: {}, Method execution start: {}.{}",
                userId != null ? userId : "Unknown", className, methodName);

        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long executionTime = System.currentTimeMillis() - start;

        // 메서드 실행 후 로깅
        log.info("User ID: {}, Method execution end: {}.{}, Execution time: {}ms",
                userId != null ? userId : "Unknown", className, methodName, executionTime);

        return result;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderStatusUpdateRequest.java
--------
package com.zzimcong.order.application.dto;

public record OrderStatusUpdateRequest(
        String status
) {
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/PaymentDetailsRequest.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.order.domain.entity.PaymentType;

public record PaymentDetailsRequest(
        PaymentType paymentMethod,
        String cardNumber,
        String cardHolderName,
        String expirationDate,
        String cvv
) {
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/ReleaseInventoryRequest.java
--------
package com.zzimcong.order.application.dto;

public record ReleaseInventoryRequest(
        int quantity
) {
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderPreparationRequest.java
--------
package com.zzimcong.order.application.dto;

import java.math.BigDecimal;
import java.util.List;

public record OrderPreparationRequest(
        BigDecimal orderAmount,
        BigDecimal paymentAmount,
        List<OrderItemRequest> items
) {
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderItemResponse.java
--------
package com.zzimcong.order.application.dto;

import java.math.BigDecimal;

public record OrderItemResponse(
        Long id,
        Long productId,
        BigDecimal price,
        Integer quantity
) {
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderPreparationResponse.java
--------
package com.zzimcong.order.application.dto;

public record OrderPreparationResponse(
        String orderId,
        OrderPreparationStatus status
) {
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/CartItem.java
--------
package com.zzimcong.order.application.dto;

public record CartItem(
        Long productId,
        Integer price,
        Integer quantity
) {
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderResponse.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.entity.PaymentType;

import java.math.BigDecimal;
import java.util.List;

public record OrderResponse(
        Long id,
        Long userId,
        BigDecimal orderAmount,
        BigDecimal paymentAmount,
        PaymentType payment,
        OrderStatus status,
        boolean deleted,
        String reason,
        OrderAddressResponse orderAddress,
        List<OrderItemResponse> items
) {
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderCancellationRequest.java
--------
package com.zzimcong.order.application.dto;

public record OrderCancellationRequest(
        String cancellationReason
) {
}



--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderPreparationStatus.java
--------
package com.zzimcong.order.application.dto;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum OrderPreparationStatus {
    SUCCESS("주문 성공"),
    INVENTORY_SHORTAGE("재고 부족"),
    FAILED("주문 실패");


    private final String message;
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/PaymentResponse.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class PaymentResponse implements KafkaMessage {
    private Long userId;
    private Long orderId;
    private String uuid;
    private boolean success;
    private String status;

    public PaymentResponse(Long userId, String uuid, boolean success) {
        this.userId = userId;
        this.uuid = uuid;
        this.success = success;
        this.status = success ? "PAID" : "FAILED";
    }

    public PaymentResponse(Long userId, Long orderId, boolean success, String status) {
        this.userId = userId;
        this.orderId = orderId;
        this.success = success;
        this.status = status;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderListResponse.java
--------
package com.zzimcong.order.application.dto;

import java.util.List;

public record OrderListResponse(
        List<OrderResponse> orders,
        int totalPages,
        long totalElements
) {
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderAddressRequest.java
--------
package com.zzimcong.order.application.dto;

public record OrderAddressRequest(
        String name,
        String streetAddress,
        String addressDetail,
        String zipcode,
        String phone,
        String message) {
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/ReserveInventoryResponse.java
--------
package com.zzimcong.order.application.dto;

public record ReserveInventoryResponse(
        boolean success,
        String message
) {
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/RefundResponse.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class RefundResponse implements KafkaMessage {
    private Long userId;
    private Long orderId;
    private boolean success;
    private OrderStatus status;

    public RefundResponse(Long userId, Long orderId, boolean success, OrderStatus status) {
        this.userId = userId;
        this.orderId = orderId;
        this.success = success;
        this.status = status;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderItemRequest.java
--------
package com.zzimcong.order.application.dto;

import java.math.BigDecimal;

public record OrderItemRequest(
        Long productId,
        BigDecimal price,
        Integer quantity
) {
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderAddressResponse.java
--------
package com.zzimcong.order.application.dto;

public record OrderAddressResponse(
        String name,
        String streetAddress,
        String addressDetail,
        String zipcode,
        String phone,
        String message) {
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/RefundRequest.java
--------
package com.zzimcong.order.application.dto;

public record RefundRequest(
        String refundReason
) {
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderCreationRequest.java
--------
package com.zzimcong.order.application.dto;

public record OrderCreationRequest(
        OrderAddressRequest orderAddressRequest,
        PaymentDetailsRequest paymentDetailsRequest
) {
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/OrderRequest.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.order.domain.entity.PaymentType;

import java.math.BigDecimal;
import java.util.List;

public record OrderRequest(
        BigDecimal orderAmount,
        BigDecimal paymentAmount,
        PaymentType payment,
        String name,
        String addr,
        String addrDetail,
        String zipcode,
        String phone,
        String message,
        List<OrderItemRequest> items
) {
}


--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/ReserveInventoryRequest.java
--------
package com.zzimcong.order.application.dto;

public record ReserveInventoryRequest(
//        Long productId,
        int quantity
) {
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/dto/PaymentRequest.java
--------
package com.zzimcong.order.application.dto;

import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class PaymentRequest implements KafkaMessage {
    private Long userId;
    private String uuid;
    private PaymentDetailsRequest paymentDetails;
    private BigDecimal amount;
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/mapper/OrderMapper.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderResponse;
import com.zzimcong.order.domain.entity.Order;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring", uses = {OrderItemMapper.class})
public interface OrderMapper {
    @Mapping(target = "items", source = "orderItems")
    OrderResponse orderToOrderResponse(Order order);
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/mapper/PaymentDetailsMapper.java
--------
//package com.zzimcong.order.application.mapper;
//
//import com.zzimcong.order.application.dto.PaymentDetailsRequest;
//import com.zzimcong.order.domain.entity.PaymentDetails;
//import org.mapstruct.BeanMapping;
//import org.mapstruct.Mapper;
//
//@Mapper(componentModel = "spring", uses = {PaymentDetailsMapper.class})
//public interface PaymentDetailsMapper {
//    @BeanMapping
//    PaymentDetails paymentDetailsRequestToPaymentDetails(PaymentDetailsRequest paymentDetailsRequest);
//}


--------


File: ./order/src/main/java/com/zzimcong/order/application/mapper/OrderItemMapper.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.OrderItemResponse;
import com.zzimcong.order.domain.entity.OrderItem;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface OrderItemMapper {

    OrderItemResponse orderItemToOrderItemResponse(OrderItem orderItem);

    @InheritInverseConfiguration
    OrderItem orderItemResponseToOrderItem(OrderItemResponse orderItemResponse);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    void updateOrderItemFromResponse(OrderItemResponse orderItemResponse, @MappingTarget OrderItem orderItem);
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/mapper/OrderRequestMapper.java
--------
package com.zzimcong.order.application.mapper;

import com.zzimcong.order.application.dto.*;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderAddress;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.PaymentDetails;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface OrderRequestMapper {

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "userId", ignore = true)
    @Mapping(target = "status", constant = "TEMP")
    @Mapping(target = "deleted", constant = "false")
    @Mapping(target = "orderItems", source = "items")
    Order orderPreperationRequestToOrder(OrderPreparationRequest orderPreparationRequest);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "order", ignore = true)
    OrderItem orderItemRequestToOrderItem(OrderItemRequest orderItemRequest);

    @AfterMapping
    default void linkOrderItems(@MappingTarget Order order) {
        if (order.getOrderItems() != null) {
            order.getOrderItems().forEach(item -> item.setOrder(order));
        }
    }

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(source = "orderAddressRequest", target = "orderAddress")
    @Mapping(source = "paymentDetailsRequest", target = "paymentDetails")
    void updateOrderFromRequest(OrderCreationRequest orderCreationRequest, @MappingTarget Order order);

    @Mapping(target = "id", ignore = true)
    OrderAddress orderAddressRequestToOrderAddress(OrderAddressRequest orderAddressRequest);

    @Mapping(target = "id", ignore = true)
    PaymentDetails paymentDetailsRequestToPaymentDetails(PaymentDetailsRequest paymentDetailsRequest);

    @AfterMapping
    default void logMappingResult(OrderCreationRequest request, @MappingTarget Order order) {
        System.out.println("OrderCreationRequest: " + request);
        System.out.println("Mapped Order: " + order);
        System.out.println("PaymentDetails: " + order.getPaymentDetails());
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/saga/OrderSaga.java
--------
package com.zzimcong.order.application.saga;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.zzimcong.order.application.dto.*;
import com.zzimcong.order.application.mapper.OrderRequestMapper;
import com.zzimcong.order.application.service.ProductService;
import com.zzimcong.order.common.exception.ErrorCode;
import com.zzimcong.order.common.exception.InternalServerErrorException;
import com.zzimcong.order.common.exception.InventoryException;
import com.zzimcong.order.common.exception.NotFoundException;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderItem;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.repository.OrderRepository;
import feign.FeignException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataAccessException;
import org.springframework.data.redis.core.RedisOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.SessionCallback;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;
import java.util.ConcurrentModificationException;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.ExecutionException;

@Service
@Slf4j(topic = "order-saga")
@RequiredArgsConstructor
public class OrderSaga {
    private final ProductService productService;
    private final OrderRequestMapper orderRequestMapper;
    private final ObjectMapper objectMapper;
    private final RedisTemplate<String, String> redisTemplate;
    private final OrderRepository orderRepository;
    private final KafkaTemplate<String, PaymentRequest> kafkaTemplate;


    /***************************************************************************
     주문 준비 프로세스(재고 예약, 임시 주문 생성, 임시 주문 정보 Redis에 저장)
     ***************************************************************************/

    // 주문 준비
    public OrderPreparationResponse prepareOrder(Long userId, OrderPreparationRequest request) {
        boolean allReserved = reserveInventory(request);
        if (allReserved) {
            Order tempOrder = createTempOrder(userId, request);
            String orderUuid = saveTempOrderToRedis(userId, tempOrder);
            return new OrderPreparationResponse(orderUuid, OrderPreparationStatus.SUCCESS);
        } else {
            return new OrderPreparationResponse(null, OrderPreparationStatus.INVENTORY_SHORTAGE);
        }
    }

    // 재고 예약
    @Transactional(rollbackFor = {InventoryException.class})
    @Retryable(value = {InventoryException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
    public boolean reserveInventory(OrderPreparationRequest request) {
        log.info("재고 예약 시작");
        return request.items().stream()
                .allMatch(item -> {
                    try {
                        return productService.reserveInventory(item.productId(), item.quantity());
                    } catch (FeignException e) {
                        log.error("재고 예약 실패. 상품 ID: {}, 수량: {}", item.productId(), item.quantity(), e);
                        throw new InventoryException(ErrorCode.RESERVE_INVENTORY_FAILED, e.getMessage());
                    }
                });
    }

    // 임시 주문 생성
    public Order createTempOrder(Long userId, OrderPreparationRequest request) {
        log.info("Creating temporary order for user ID: {}", userId);

        Order tempOrder = orderRequestMapper.orderPreperationRequestToOrder(request);
        tempOrder.setUserId(userId);

        return tempOrder;
    }

    // 임시 주문 정보 Redis에 저장
    private String saveTempOrderToRedis(Long userId, Order tempOrder) {
        String orderUuid = generateOrderUuid();
        String key = "temp_order:" + userId + ":" + orderUuid;

        try {
            String orderJson = objectMapper.writeValueAsString(tempOrder);
            Boolean setSuccess = redisTemplate.opsForValue()
                    .setIfAbsent(key, orderJson, Duration.ofMinutes(30));

            if (Boolean.FALSE.equals(setSuccess)) {
                throw new ConcurrentModificationException("동시에 같은 키로 주문 생성 시도");
            }

            log.info("Temporary order created with ID: {}", orderUuid);
        } catch (JsonProcessingException e) {
            log.error("Error creating temporary order", e);
            throw new RuntimeException("임시 주문 생성 중 오류가 발생했습니다.");
        }

        return orderUuid;
    }

    private String generateOrderUuid() {
        return UUID.randomUUID().toString();
    }

    /***************************************************************************
     주문 생성 프로세스(주문 정보 업데이트, 결제 요청)
     ***************************************************************************/

    // 주문 생성
    public void createOrder(Long userId, String uuid, OrderCreationRequest request) {
        log.info("주문 생성 시작. 사용자 ID: {}, UUID: {}", userId, uuid);
        Order order = updateOrderDetails(userId, uuid, request);
        processPayment(userId, uuid, request.paymentDetailsRequest(), order);
    }

    // 주문 정보 업데이트
    public Order updateOrderDetails(Long userId, String uuid, OrderCreationRequest orderCreationRequest) {
        String key = "temp_order:" + userId + ":" + uuid;

        return (Order) redisTemplate.execute(new SessionCallback<Object>() {
            @Override
            public Object execute(RedisOperations operations) throws DataAccessException {
                operations.watch(key);
                String orderJson = (String) operations.opsForValue().get(key);

                if (orderJson == null) {
                    throw new NotFoundException(ErrorCode.TEMP_ORDER_NOT_FOUND, "uuid : " + uuid);
                }

                try {
                    operations.multi();

                    Order order = objectMapper.readValue(orderJson, Order.class);
                    orderRequestMapper.updateOrderFromRequest(orderCreationRequest, order);

                    order.setStatus(OrderStatus.PAYMENT_REQUESTED);

                    String updatedOrderJson = objectMapper.writeValueAsString(order);
                    operations.opsForValue().set(key, updatedOrderJson);
                    operations.expire(key, Duration.ofMinutes(15));

                    List<Object> txResults = operations.exec();

                    if (txResults == null || txResults.isEmpty()) {
                        throw new ConcurrentModificationException("주문 정보가 동시에 수정되었습니다. 다시 시도해주세요.");
                    }

                    log.info("Order details updated successfully for order: {}", uuid);
                    return order;

                } catch (JsonProcessingException e) {
                    operations.discard();
                    log.error("Error updating temporary order", e);
                    throw new InternalServerErrorException(ErrorCode.ORDER_UPDATE_FAILED);
                }
            }
        });
    }

    // 결제 요청
    @Transactional
    public void processPayment(Long userId, String uuid, PaymentDetailsRequest request, Order order) {
        log.info("결제 처리 시작. 사용자 ID: {}, UUID: {}", userId, uuid);
        PaymentRequest paymentRequest = new PaymentRequest(userId, uuid, request, order.getPaymentAmount());
        try {
            kafkaTemplate.send("payment-requests", paymentRequest).get();
            log.info("결제 요청 전송 완료. UUID: {}", uuid);
        } catch (InterruptedException | ExecutionException e) {
            log.error("결제 요청 전송 실패. UUID: {}", uuid, e);
            throw new InternalServerErrorException(ErrorCode.PAYMENT_REQUEST_FAILED, e.getMessage());
        }
    }

    // 결제 결과 처리
    @KafkaListener(topics = "payment-results")
    public void handlePaymentResult(PaymentResponse result) {
        log.info("결제 결과 수신. UUID: {}, 사용자 ID: {}, 성공 여부: {}", result.getUuid(), result.getUserId(), result.isSuccess());

        String key = "temp_order:" + result.getUserId() + ":" + result.getUuid();
        String orderJson = redisTemplate.opsForValue().get(key);

        if (orderJson == null) {
            log.warn("존재하지 않는 주문에 대한 결제 결과 수신: {}", result.getUuid());
            return;
        }

        try {
            Order order = objectMapper.readValue(orderJson, Order.class);
            log.debug("Redis에서 불러온 주문 정보: {}", order);

            if (result.isSuccess()) {
                processSuccessfulPayment(order);
            } else {
                log.warn("결제 실패. 보상 트랜잭션 시작");
                compensatePaymentFailure(order);
            }

            boolean deleted = redisTemplate.delete(key);
            log.info("Redis에서 임시 주문 정보 삭제 {}: {}", (deleted ? "성공" : "실패"), key);

        } catch (JsonProcessingException e) {
            log.error("결제 결과 처리 중 JSON 파싱 오류 발생", e);
            throw new InternalServerErrorException(ErrorCode.PAYMENT_RESULT_PROCESSING_FAILED);
        } catch (Exception e) {
            log.error("주문 처리 중 예기치 못한 오류 발생", e);
            throw new InternalServerErrorException(ErrorCode.UNKNOWN_ERROR);
        }
    }

    // 결제 성공 처리
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void processSuccessfulPayment(Order order) {
        try {
            order.setStatus(OrderStatus.ORDER_COMPLETED);
            for (OrderItem item : order.getOrderItems()) {
                item.setOrder(order);
                log.debug("주문 아이템 설정: {}", item);
            }
            log.info("주문 정보: {}", order);
            Order savedOrder = orderRepository.save(order);
            log.info("주문 저장 완료. 주문 ID: {}", savedOrder.getId());
        } catch (DataAccessException e) {
            log.error("주문 저장 중 데이터베이스 오류 발생", e);
            throw new InternalServerErrorException(ErrorCode.ORDER_SAVE_FAILED);
        } catch (Exception e) {
            log.error("주문 처리 중 예기치 못한 오류 발생", e);
            throw new InternalServerErrorException(ErrorCode.UNKNOWN_ERROR);
        }
    }

    // 보상 트랜잭션: 결제 실패 시 재고 회수
    private void compensatePaymentFailure(Order order) {
        log.info("결제 실패에 대한 보상 트랜잭션 시작. 주문 ID: {}", order.getId());
        for (OrderItem item : order.getOrderItems()) {
            try {
                productService.releaseInventory(item.getProductId(), item.getQuantity());
                log.info("재고 해제 성공: 상품 ID: {}, 수량: {}", item.getProductId(), item.getQuantity());
            } catch (FeignException e) {
                log.error("재고 해제 실패: 상품 ID: {}, 수량: {}, 오류: {}",
                        item.getProductId(), item.getQuantity(), e.getMessage());
                // 추가적인 오류 처리 로직
                // 예: 관리자에게 알림, 수동 처리를 위한 큐에 추가 등
            }
        }
        log.info("보상 트랜잭션 완료");
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/service/ShippingService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.repository.OrderRepository;
import com.zzimcong.zzimconginventorycore.common.event.ShippingEvent;
import com.zzimcong.zzimconginventorycore.common.event.ShippingEventType;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

@Slf4j(topic = "shipping-service")
@Service
@EnableScheduling
@AllArgsConstructor
public class ShippingService {
    private final OrderRepository orderRepository;
    private final KafkaTemplate<String, ShippingEvent> kafkaTemplate;
//    private final JavaMailSender javaMailSender;

    // 주문 완료 -> 배송 준비로 상태 변경
    // 1시간 전에 주문 완료된 주문을 찾아 배송 준비로 변경
    @Scheduled(fixedDelay = 60000)
    @Transactional
    public void updateOrdersToPreparing() {
        LocalDateTime oneHourAgo = LocalDateTime.now().minusHours(1);
        List<Order> orders = orderRepository.findByStatusAndCreatedAtBefore(OrderStatus.ORDER_COMPLETED, oneHourAgo);

        for (Order order : orders) {
//            order.setStatus(OrderStatus.PREPARING_FOR_SHIPMENT);
//            orderRepository.save(order);
            kafkaTemplate.send("shipping-events", new ShippingEvent(order.getId(), ShippingEventType.PREPARING));
        }
    }

    // 배송 준비 -> 배송 중으로 상태 변경
    // 매일 오후 11시 실행
    @Scheduled(cron = "0 0 23 * * ?")
    @Transactional
    public void updateOrdersToShipping() {
        List<Order> orders = orderRepository.findByStatus(OrderStatus.PREPARING_FOR_SHIPMENT);

        for (Order order : orders) {
//            order.setStatus(OrderStatus.SHIPPING);
//            orderRepository.save(order);
            kafkaTemplate.send("shipping-events", new ShippingEvent(order.getId(), ShippingEventType.SHIPPING));
        }
    }

    // 배송 중 -> 배송 완료로 상태 변경
    // 매일 오전 11시 실행
    @Scheduled(cron = "0 0 11 * * ?")
    @Transactional
    public void updateOrdersToDelivered() {
        List<Order> orders = orderRepository.findByStatus(OrderStatus.SHIPPING);

        for (Order order : orders) {
//            order.setStatus(OrderStatus.DELIVERED);
//            orderRepository.save(order);
            kafkaTemplate.send("shipping-events", new ShippingEvent(order.getId(), ShippingEventType.DELIVERED));
//            sendMail(order);
        }
    }

    // 반품 요청 -> 환불 완료로 상태 변경
    @Scheduled(fixedDelay = 86400000)
    public void autoRefundOrders() {
        log.info("Starting auto-refund of orders");
        LocalDateTime refundDate = LocalDateTime.now().minusDays(1);
        List<Order> ordersToRefund =
                orderRepository.findByStatusAndDeliveredAtBefore(OrderStatus.REFUND_REQUESTED, refundDate);
        log.info("Found {} orders to auto-refund", ordersToRefund.size());

        for (Order order : ordersToRefund) {
//            order.setStatus(OrderStatus.REFUND_COMPLETED);
//            orderRepository.save(order);
            kafkaTemplate.send("shipping-events", new ShippingEvent(order.getId(), ShippingEventType.PICKUP_COMPLETED));
        }
    }

    // 메일 전송
//    private void sendMail(Order order) {
//        SimpleMailMessage message = new SimpleMailMessage();
//        message.setTo(order.getUserId().getEmail());
//        message.setSubject("배송이 완료되었습니다.");
//        message.setText("배송이 완료되었습니다. 주문 번호: " + order.getId());
//        javaMailSender.send(message);
//    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/service/ProductService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.api.client.ProductServiceClient;
import com.zzimcong.order.application.dto.ReleaseInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryRequest;
import com.zzimcong.order.application.dto.ReserveInventoryResponse;
import feign.FeignException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

@Service
public class ProductService {
    private final ProductServiceClient productServiceClient;

    @Autowired
    public ProductService(ProductServiceClient productServiceClient) {
        this.productServiceClient = productServiceClient;
    }

    public boolean reserveInventory(Long productId, int quantity) {
        try {
            ReserveInventoryResponse response = productServiceClient.reserveInventory(
                    productId, new ReserveInventoryRequest(quantity));
            return response.success();
        } catch (FeignException e) {
            if (e.status() == HttpStatus.BAD_REQUEST.value()) {
                // 재고 부족 등의 이유로 예약 실패
                return false;
            }
            throw new RuntimeException("재고 예약 중 오류 발생", e);
        }
    }

    public void releaseInventory(Long productId, int quantity) {
        productServiceClient.releaseInventory(productId, new ReleaseInventoryRequest(quantity));
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/service/OrderService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.application.dto.OrderResponse;
import com.zzimcong.order.application.dto.RefundResponse;
import com.zzimcong.order.application.mapper.OrderMapper;
import com.zzimcong.order.common.exception.ErrorCode;
import com.zzimcong.order.common.exception.NotFoundException;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.order.domain.repository.OrderRepository;
import com.zzimcong.zzimconginventorycore.common.event.ShippingEvent;
import com.zzimcong.zzimconginventorycore.common.event.ShippingEventType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

@Slf4j(topic = "order-service")
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderRepository orderRepository;
    private final OrderMapper orderMapper;
    private final KafkaTemplate<String, Order> kafkaTemplate;

    /**********************************************
     배송 준비 중, 배송 중, 배송완료, 회수완료 처리
     **********************************************/
    @Transactional
    @KafkaListener(topics = "shipping-events")
    public void handleShippingEvent(ShippingEvent event) {
        log.info("Received shipping event for order ID: {}, Event type: {}", event.getOrderId(), event.getEventType());
        Order order = getOrder(event.getOrderId());

        if (event.getEventType() == ShippingEventType.PICKUP_COMPLETED) {
            // PICKUP_COMPLETED 이벤트 별도 처리
            refundOrder(order);
            log.info("Processed PICKUP_COMPLETED event for Order ID: {}", order.getId());
        } else {
            // 다른 이벤트들에 대한 상태 업데이트
            updateOrderStatusForShippingEvent(order, event.getEventType());
        }
    }

    // 배송 이벤트에 따른 주문 상태 업데이트
    private void updateOrderStatusForShippingEvent(Order order, ShippingEventType eventType) {
        OrderStatus newStatus = switch (eventType) {
            case PREPARING -> OrderStatus.PREPARING_FOR_SHIPMENT;
            case SHIPPING -> OrderStatus.SHIPPING;
            case DELIVERED -> OrderStatus.DELIVERED;
            default -> throw new IllegalArgumentException("예상치 못한 배송 이벤트 타입: " + eventType);
        };
        updateOrderStatus(order, newStatus);
        log.info("Updated order status: {}, Order ID: {}", newStatus, order.getId());
    }

    // 주문 상태 업데이트
    @Transactional
    public void updateOrderStatus(Order order, OrderStatus status) {
        log.info("Updating order status. Order ID: {}, New status: {}", order.getId(), status);
        order.setStatus(status);
        orderRepository.save(order);
    }


    /**********************************************
     취소, 환불 처리
     **********************************************/
    // 주문 취소 요청
    @Transactional
    public void cancelOrderByOrderId(Long orderId) {
        log.info("Cancelling order with ID: {}", orderId);
        Order order = getOrder(orderId);
        tryCancelOrder(order);
        kafkaTemplate.send("refund-request", order);
    }

    // 주문 취소 가능 여부 확인
    @Transactional
    public void tryCancelOrder(Order order) {
        log.info("Setting order status to CANCELED. Order ID: {}", order.getId());
        if (order.getStatus() == OrderStatus.PREPARING_FOR_SHIPMENT) {
            throw new RuntimeException("배송 준비 중인 주문은 취소할 수 없습니다: " + order.getId());
        } else if (order.getStatus() == OrderStatus.SHIPPING) {
            throw new RuntimeException("배송 중인 주문은 취소할 수 없습니다: " + order.getId());
        } else if (order.getStatus() == OrderStatus.DELIVERED) {
            throw new RuntimeException("배송 완료된 주문은 취소할 수 없습니다: " + order.getId());
        } else if (order.getStatus() != OrderStatus.ORDER_COMPLETED) {
            throw new RuntimeException("취소할 수 없는 주문 상태입니다: " + order.getId());
        }
    }

    // 환불 요청 수신
    @Transactional
    public void requestRefund(Long orderId) {
        log.info("Requesting refund for order ID: {}", orderId);
        Order order = getOrder(orderId);
        if (order.getStatus() != OrderStatus.DELIVERED) {
            throw new RuntimeException("배송 완료된 주문만 환불할 수 있습니다: " + order.getId());
        } else {
            updateOrderStatus(order, OrderStatus.REFUND_REQUESTED);
        }
    }

    // 환불 완료 처리 요청
    @Transactional
    public void refundOrder(Order order) {
        log.info("Processing refund for order ID: {}", order.getId());
        kafkaTemplate.send("refund-request", order);
    }

    // 환불 결과 처리
    @Transactional
    @KafkaListener(topics = "refund-results")
    public void handleRefundResult(RefundResponse response) {
        log.info("Received refund result: {}", response);
        if (response.isSuccess()) {
            if (response.getStatus() == OrderStatus.REFUND_REQUESTED) {
                updateOrderStatus(getOrder(response.getOrderId()), OrderStatus.REFUND_COMPLETED);
            } else {
                updateOrderStatus(getOrder(response.getOrderId()), OrderStatus.CANCELED);
            }
        }
    }


    /**********************************************
     주문 조회
     **********************************************/
    public Order getOrder(Long orderId) {
        log.debug("Fetching order with ID: {}", orderId);
        return orderRepository.findById(orderId)
                .orElseThrow(() -> {
                    log.error("Order not found with ID: {}", orderId);
                    return new NotFoundException(ErrorCode.ORDER_NOT_FOUND);
                });
    }

    @Transactional(readOnly = true)
    public OrderResponse getOrderResponse(Long orderId) {
        log.debug("Fetching order response for order ID: {}", orderId);
        Order order = getOrder(orderId);
        return orderMapper.orderToOrderResponse(order);
    }

    @Transactional(readOnly = true)
    public Page<OrderResponse> getOrderList(Pageable pageable) {
        log.debug("Fetching order list. Page: {}, Size: {}", pageable.getPageNumber(), pageable.getPageSize());
        Page<Order> orderPage = orderRepository.findAll(pageable);
        return orderPage.map(orderMapper::orderToOrderResponse);
    }

    @Transactional(readOnly = true)
    public Page<OrderResponse> getUserOrders(Long userId, Pageable pageable) {
        log.debug("Fetching orders for user ID: {}. Page: {}, Size: {}", userId, pageable.getPageNumber(), pageable.getPageSize());
        Page<Order> ordersWithItems = orderRepository.findByUserId(userId, pageable);
        return ordersWithItems.map(orderMapper::orderToOrderResponse);
    }


    /**********************************************
     주문 자동 확정
     **********************************************/
    // 매일 배송완료 주문 자동 확정
    @Scheduled(fixedDelay = 86400000)
    public void autoConfirmOrders() {
        log.info("Starting auto-confirmation of orders");
        List<Order> ordersToConfirm = getOrdersToConfirm();
        log.info("Found {} orders to auto-confirm", ordersToConfirm.size());

        for (Order order : ordersToConfirm) {
            try {
                confirmOrder(order);
            } catch (Exception e) {
                log.error("Error during auto-confirmation of order ID: {}", order.getId(), e);
            }
        }
    }

    public List<Order> getOrdersToConfirm() {
        LocalDateTime confirmationDate = LocalDateTime.now().minusDays(1);
        log.debug("Fetching orders to confirm before: {}", confirmationDate);
        return orderRepository.findByStatusAndDeliveredAtBefore(OrderStatus.DELIVERED, confirmationDate);
    }

    @Transactional
    public void confirmOrder(Order order) {
        log.info("Confirming order with ID: {}", order.getId());
        updateOrderStatus(order, OrderStatus.ORDER_CONFIRMED);
    }


    /**********************************************
     주문 소유자 확인
     **********************************************/
    public boolean isOrderOwnedByUser(Long orderId, Long userId) {
        log.debug("Checking if order ID: {} is owned by user ID: {}", orderId, userId);
        Order order = getOrder(orderId);
        return order.getUserId().equals(userId);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/application/service/PaymentService.java
--------
package com.zzimcong.order.application.service;

import com.zzimcong.order.application.dto.PaymentRequest;
import com.zzimcong.order.application.dto.PaymentResponse;
import com.zzimcong.order.application.dto.RefundResponse;
import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

import java.util.Random;

@Slf4j(topic = "payment-service")
@Service
public class PaymentService {
    private final KafkaTemplate<String, KafkaMessage> kafkaTemplate;
    private final Random random = new Random();

    @Autowired
    public PaymentService(KafkaTemplate<String, KafkaMessage> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    @KafkaListener(topics = "payment-requests")
    public void processPayment(PaymentRequest request) {
        // 90% 확률로 결제 성공, 10% 확률로 결제 실패 시뮬레이션
        boolean isSuccess = random.nextInt(100) < 90;

        PaymentResponse result = new PaymentResponse(request.getUserId(), request.getUuid(), isSuccess);

        if (isSuccess) {
            log.info("결제 성공: 주문 ID {}", request.getUuid());
        } else {
            log.info("결제 실패: 주문 ID {}", request.getUuid());
        }

        // 결제 결과를 Kafka로 전송
        kafkaTemplate.send("payment-results", result);
    }

    public void refundPayment(Order order) {
        // 실제 환불 처리 대신 로그만 남김
        log.info("환불 처리 완료: 주문 ID {}, 금액 {}", order.getId(), order.getPaymentAmount());

        // 환불 결과를 Kafka로 전송
        RefundResponse refundResult = new RefundResponse(order.getUserId(), order.getId(), true, order.getStatus());
        kafkaTemplate.send("refund-results", refundResult);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/config/WebMvcConfig.java
--------
//package com.zzimcong.order.config;
//
//import org.springframework.context.annotation.Configuration;
//import org.springframework.web.method.support.HandlerMethodArgumentResolver;
//import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
//
//import java.util.List;
//
//@Configuration
//public class WebMvcConfig implements WebMvcConfigurer {
//
//    private final UserInfoArgumentResolver userInfoArgumentResolver;
//
//    public WebMvcConfig(UserInfoArgumentResolver userInfoArgumentResolver) {
//        this.userInfoArgumentResolver = userInfoArgumentResolver;
//    }
//
//    @Override
//    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
//        resolvers.add(userInfoArgumentResolver);
//    }
//}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/config/SecurityConfig.java
--------
package com.zzimcong.order.infrastructure.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Slf4j(topic = "security")
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        log.info("Configuring security filter chain");
        http
                .csrf(csrf -> {
                    csrf.disable();
                    log.info("CSRF is disabled");
                })
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/v1/orders/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().permitAll()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                );

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/config/KafkaConfig.java
--------
package com.zzimcong.order.infrastructure.config;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.support.serializer.JsonSerializer;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Bean
    public <T> ProducerFactory<String, T> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public <T> KafkaTemplate<String, T> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/config/SwaggerConfig.java
--------
package com.zzimcong.order.infrastructure.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("찜콩 API")
                        .version("1.0")
                        .description("선착순 구매 기능이 있는 이커머스 서비스 API 문서"));
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/config/UserInfoArgumentResolver.java
--------
//package com.zzimcong.order.config;
//
//import com.fasterxml.jackson.databind.ObjectMapper;
//import com.zzimcong.order.common.UserInfo;
//import jakarta.servlet.http.HttpServletRequest;
//import org.springframework.core.MethodParameter;
//import org.springframework.stereotype.Component;
//import org.springframework.web.bind.support.WebDataBinderFactory;
//import org.springframework.web.context.request.NativeWebRequest;
//import org.springframework.web.method.support.HandlerMethodArgumentResolver;
//import org.springframework.web.method.support.ModelAndViewContainer;
//
//import java.util.Base64;
//
//@Component
//public class UserInfoArgumentResolver implements HandlerMethodArgumentResolver {
//
//    private final ObjectMapper objectMapper;
//
//    public UserInfoArgumentResolver(ObjectMapper objectMapper) {
//        this.objectMapper = objectMapper;
//    }
//
//    @Override
//    public boolean supportsParameter(MethodParameter parameter) {
//        return parameter.getParameterType().equals(UserInfo.class);
//    }
//
//    @Override
//    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
//                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
//        HttpServletRequest request = (HttpServletRequest) webRequest.getNativeRequest();
//        String userInfoHeader = request.getHeader("X-User-Info");
//
//        if (userInfoHeader != null) {
//            String decodedUserInfo = new String(Base64.getDecoder().decode(userInfoHeader));
//            return objectMapper.readValue(decodedUserInfo, UserInfo.class);
//        }
//
//        return null;
//    }
//}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/config/JpaConfig.java
--------
package com.zzimcong.order.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
@EnableJpaAuditing
public class JpaConfig {
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/config/CorsConfig.java
--------
package com.zzimcong.order.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CorsConfig {

    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("http://localhost:3000"); // React 앱의 주소
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        source.registerCorsConfiguration("/api/**", config);
        return new CorsFilter(source);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/statemachine/OrderStateMachineFactory.java
--------
package com.zzimcong.order.infrastructure.statemachine;

import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.zzimconginventorycore.common.event.OrderEventType;
import org.springframework.statemachine.StateMachine;
import org.springframework.statemachine.config.StateMachineFactory;
import org.springframework.statemachine.support.DefaultStateMachineContext;
import org.springframework.stereotype.Component;

@Component
public class OrderStateMachineFactory {
    private final StateMachineFactory<OrderStatus, OrderEventType> stateMachineFactory;

    public OrderStateMachineFactory(StateMachineFactory<OrderStatus, OrderEventType> stateMachineFactory) {
        this.stateMachineFactory = stateMachineFactory;
    }

    public StateMachine<OrderStatus, OrderEventType> create(Order order) {
        StateMachine<OrderStatus, OrderEventType> sm = stateMachineFactory.getStateMachine(order.getId().toString());
        sm.stop();
        sm.getStateMachineAccessor().doWithAllRegions(sma -> {
            sma.resetStateMachine(new DefaultStateMachineContext<>(order.getStatus(), null, null, null));
        });
        sm.start();
        return sm;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/statemachine/OrderStateMachineConfig.java
--------
package com.zzimcong.order.infrastructure.statemachine;

import com.zzimcong.order.domain.entity.OrderStatus;
import com.zzimcong.zzimconginventorycore.common.event.OrderEventType;
import org.springframework.context.annotation.Configuration;
import org.springframework.statemachine.config.EnableStateMachineFactory;
import org.springframework.statemachine.config.StateMachineConfigurerAdapter;
import org.springframework.statemachine.config.builders.StateMachineStateConfigurer;
import org.springframework.statemachine.config.builders.StateMachineTransitionConfigurer;

import java.util.EnumSet;

@Configuration
@EnableStateMachineFactory
public class OrderStateMachineConfig extends StateMachineConfigurerAdapter<OrderStatus, OrderEventType> {

    @Override
    public void configure(StateMachineStateConfigurer<OrderStatus, OrderEventType> states) throws Exception {
        states
                .withStates()
                .initial(OrderStatus.TEMP)
                .states(EnumSet.allOf(OrderStatus.class));
    }

    @Override
    public void configure(StateMachineTransitionConfigurer<OrderStatus, OrderEventType> transitions) throws Exception {
        transitions
                .withExternal()
                .source(OrderStatus.TEMP).target(OrderStatus.STOCK_RESERVED)
                .event(OrderEventType.INVENTORY_RESERVED)
                .and()
                .withExternal()
                .source(OrderStatus.STOCK_RESERVED).target(OrderStatus.PAYMENT_PROCESSED)
                .event(OrderEventType.PAYMENT_PROCESSED)
                .and()
                .withExternal()
                .source(OrderStatus.PAYMENT_PROCESSED).target(OrderStatus.ORDER_COMPLETED)
                .event(OrderEventType.ORDER_COMPLETED)
                .and()
                .withExternal()
                .source(OrderStatus.ORDER_COMPLETED).target(OrderStatus.PREPARING_FOR_SHIPMENT)
                .event(OrderEventType.SHIPMENT_PREPARING)
                .and()
                .withExternal()
                .source(OrderStatus.PREPARING_FOR_SHIPMENT).target(OrderStatus.SHIPPING)
                .event(OrderEventType.SHIPMENT_STARTED)
                .and()
                .withExternal()
                .source(OrderStatus.SHIPPING).target(OrderStatus.DELIVERED)
                .event(OrderEventType.SHIPMENT_DELIVERED);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/kafka/ShippingProducerListener.java
--------
package com.zzimcong.order.infrastructure.kafka;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.support.ProducerListener;

public class ShippingProducerListener implements ProducerListener<String, Object> {

    private static final Logger logger = LoggerFactory.getLogger(ShippingProducerListener.class);

    @Override
    public void onSuccess(ProducerRecord<String, Object> producerRecord, RecordMetadata recordMetadata) {
        logger.info("Message sent successfully to topic {} partition {} offset {}",
                recordMetadata.topic(), recordMetadata.partition(), recordMetadata.offset());
    }

    @Override
    public void onError(ProducerRecord<String, Object> producerRecord, RecordMetadata recordMetadata, Exception exception) {
        logger.error("Error sending message to topic {} partition {}",
                producerRecord.topic(), producerRecord.partition(), exception);
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/kafka/KafkaProducer.java
--------
package com.zzimcong.order.infrastructure.kafka;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.stereotype.Component;

import java.util.concurrent.CompletableFuture;

@Component
public class KafkaProducer<T> {
    private static final Logger logger = LoggerFactory.getLogger(KafkaProducer.class);

    private final KafkaTemplate<String, T> kafkaTemplate;

    public KafkaProducer(KafkaTemplate<String, T> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    public void send(String topic, T payload) {
        logger.info("Sending Kafka message to topic: {} with payload: {}", topic, payload);
        CompletableFuture<SendResult<String, T>> future = kafkaTemplate.send(topic, payload);

        future.whenComplete((result, ex) -> {
            if (ex == null) {
                logger.info("Message sent successfully to topic: {}", topic);
            } else {
                logger.error("Failed to send message to topic: {}", topic, ex);
            }
        });
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/infrastructure/kafka/PaymentEvent.java
--------
package com.zzimcong.order.infrastructure.kafka;

import com.zzimcong.order.domain.entity.PaymentType;
import lombok.Data;
import lombok.Setter;

import java.math.BigDecimal;

@Data
@Setter
public class PaymentEvent {
    private Long orderId;
    private BigDecimal amount;
    private PaymentType payment;
    private boolean success;

    public PaymentEvent(Long orderId, BigDecimal amount, PaymentType payment) {
        this.orderId = orderId;
        this.amount = amount;
        this.payment = payment;
        this.success = false;
    }
}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/repository/OrderRepository.java
--------
package com.zzimcong.order.domain.repository;

import com.zzimcong.order.domain.entity.Order;
import com.zzimcong.order.domain.entity.OrderStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;

import java.time.LocalDateTime;
import java.util.List;

public interface OrderRepository extends JpaRepository<Order, Long> {
    List<Order> findByStatus(OrderStatus orderStatus);

    List<Order> findByStatusAndDeliveredAtBefore(OrderStatus orderStatus, LocalDateTime confirmationDate);

    List<Order> findByStatusAndCreatedAtBefore(OrderStatus orderStatus, LocalDateTime oneHourAgo);

    @EntityGraph(attributePaths = "orderItems")
    Page<Order> findByUserId(Long userId, Pageable pageable);
}


--------


File: ./order/src/main/java/com/zzimcong/order/domain/repository/OrderItemRepository.java
--------
package com.zzimcong.order.domain.repository;

import com.zzimcong.order.domain.entity.OrderItem;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface OrderItemRepository extends JpaRepository<OrderItem, Long> {
    List<OrderItem> findByOrderId(Long orderId);
}


--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/PaymentType.java
--------
package com.zzimcong.order.domain.entity;

public enum PaymentType {
    KB, KAKAO, NAVER, KEB, IBK, NH
}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/Order.java
--------
package com.zzimcong.order.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import org.hibernate.annotations.ColumnDefault;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@ToString
@NoArgsConstructor
@Entity
@Table(name = "orders")
public class Order extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "order_id")
    private Long id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "order_address_id")
    private OrderAddress orderAddress;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal orderAmount;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal paymentAmount;

    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "payment_details_id")
    private PaymentDetails paymentDetails;

    @Enumerated(EnumType.STRING)
    @Column(length = 30)
    @ColumnDefault("'ORDER_COMPLETED'")
    private OrderStatus status = OrderStatus.ORDER_COMPLETED;

    @Column(nullable = false)
    private boolean deleted = false;

    @Column(length = 255)
    private String cancellationReason;

    @Column(length = 255)
    private String refundReason;

    private LocalDateTime deliveredAt;

    private LocalDateTime refundRequestedAt;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItem> orderItems = new ArrayList<>();
}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/OrderItem.java
--------
package com.zzimcong.order.domain.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "order_items") // 복수형 사용
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "order_item_id")
    private Long id;

    @Column(name = "product_id", nullable = false)
    private Long productId;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(nullable = false)
    private Integer quantity;

    @JsonIgnore
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;
}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/OrderStatus.java
--------
package com.zzimcong.order.domain.entity;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum OrderStatus {
    TEMP("임시 주문"),
    STOCK_RESERVED("재고 확보 완료"),
    PAYMENT_REQUESTED("결제 요청됨"),
    PAYMENT_PROCESSED("결제 완료"),
    SAGA_FAILED("주문 처리 실패"),
    ORDER_COMPLETED("주문 완료"),
    PREPARING_FOR_SHIPMENT("배송 준비 중"),
    SHIPPING("배송 중"),
    DELIVERED("배송 완료"),
    ORDER_CONFIRMED("주문 확정"),
    CANCELED("취소됨"),
    REFUND_REQUESTED("환불 신청됨"),
    REFUND_COMPLETED("환불 완료됨");

    private final String description;
}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/OrderAddress.java
--------
package com.zzimcong.order.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "order_addresses")
public class OrderAddress extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "order_address_id")
    private Long id;

    @Column(nullable = false, length = 64)
    private String name;

    @Column(nullable = false, length = 255)
    private String streetAddress;

    @Column(nullable = false, length = 255)
    private String addressDetail;

    @Column(nullable = false, length = 10)
    private String zipcode;

    @Column(nullable = false, length = 20)
    private String phone;

    @Column(length = 255)
    private String message;

    @OneToOne(mappedBy = "orderAddress")
    private Order order;
}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/BaseEntity.java
--------
package com.zzimcong.order.domain.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@Setter
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
public abstract class BaseEntity {

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

}

--------


File: ./order/src/main/java/com/zzimcong/order/domain/entity/PaymentDetails.java
--------
package com.zzimcong.order.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "payment_details")
public class PaymentDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "payment_details_id")
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(length = 20)
    private PaymentType paymentMethod;

    private String cardNumber;
    private String cardHolderName;
    private String expirationDate;
    private String cvv;

    @OneToOne(mappedBy = "paymentDetails")
    private Order order;
}


--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/model/KafkaMessage.java
--------
package com.zzimcong.zzimconginventorycore.common.model;

public interface KafkaMessage {
}


--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/OrderEvent.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@JsonSerialize
@JsonDeserialize
public class OrderEvent implements KafkaMessage {
    private Long orderId;
    private OrderEventType eventType;
    private String errorMessage;

    public OrderEvent(Long orderId, OrderEventType eventType) {
        this.orderId = orderId;
        this.eventType = eventType;
    }
}

--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/InventoryEventType.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

public enum InventoryEventType {
    CHECK, RESERVE, CONFIRM, CANCEL, RESTORE
}

--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/ShippingEvent.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.zzimcong.zzimconginventorycore.common.model.KafkaMessage;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@JsonSerialize
@JsonDeserialize
public class ShippingEvent implements KafkaMessage {
    private Long orderId;
    private ShippingEventType eventType;
}

--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/InventoryEvent.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

import com.zzimcong.zzimconginventorycore.common.event.InventoryEventType;

import java.util.Objects;

public class InventoryEvent {
    private Long productId;
    private InventoryEventType eventType;
    private int quantity;

    public InventoryEvent() {
    }

    public InventoryEvent(Long productId, InventoryEventType eventType, int quantity) {
        this.productId = productId;
        this.eventType = eventType;
        this.quantity = quantity;
    }

    public Long getProductId() {
        return productId;
    }

    public void setProductId(Long productId) {
        this.productId = productId;
    }

    public InventoryEventType getEventType() {
        return eventType;
    }

    public void setEventType(InventoryEventType eventType) {
        this.eventType = eventType;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        InventoryEvent that = (InventoryEvent) o;
        return quantity == that.quantity &&
                Objects.equals(productId, that.productId) &&
                eventType == that.eventType;
    }

    @Override
    public int hashCode() {
        return Objects.hash(productId, eventType, quantity);
    }

    @Override
    public String toString() {
        return "com.zzimcong.InventoryEvent{" +
                "productId=" + productId +
                ", eventType=" + eventType +
                ", quantity=" + quantity +
                '}';
    }
}

--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/OrderEventType.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

public enum OrderEventType {
    ORDER_CREATED("주문 생성"),
    INVENTORY_RESERVED("재고 예약"),
    PAYMENT_PROCESSED("결제 완료"),
    SHIPMENT_PREPARING("배송 준비 시작"),
    SHIPMENT_STARTED("배송 출발"),
    SHIPMENT_DELIVERED("배송 도착"),
    ORDER_COMPLETED("주문 완료"),
    SAGA_FAILED("주문 실패");

    private final String description;

    OrderEventType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}

--------


File: ./zzimcong-inventory-core/src/main/java/com/zzimcong/zzimconginventorycore/common/event/ShippingEventType.java
--------
package com.zzimcong.zzimconginventorycore.common.event;

public enum ShippingEventType {
    PREPARING("배송 준비 중"),
    SHIPPING("배송 중"),
    DELIVERED("배송 완료"),
    PICKUP_COMPLETED("회수 완료");

    private String description;

    ShippingEventType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}

--------


File: ./api-gateway/src/test/java/com/zzimcong/apigateway/ApiGatewayApplicationTests.java
--------
package com.zzimcong.apigateway;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApiGatewayApplicationTests {

    @Test
    void contextLoads() {
    }

}


--------


File: ./api-gateway/src/main/java/com/zzimcong/apigateway/dto/Response.java
--------
package com.zzimcong.apigateway.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Builder;
import org.springframework.http.HttpStatus;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public record Response<T>(
        Integer code,
        String message,
        T data
) {
    public Response {
        if (code == null) {
            code = HttpStatus.OK.value();
        }
        if (message == null) {
            message = HttpStatus.OK.getReasonPhrase();
        }
    }
}

--------


File: ./api-gateway/src/main/java/com/zzimcong/apigateway/util/JwtUtil.java
--------
package com.zzimcong.apigateway.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.security.Key;

@Component
public class JwtUtil {

    private final Key key;

    public JwtUtil(@Value("${jwt.secret}") String secret) {
        this.key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * JWT 토큰의 유효성을 검사합니다.
     *
     * @param token 검사할 JWT 토큰
     * @return 토큰이 유효하면 true, 그렇지 않으면 false
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            // 토큰 검증 실패 시 로그 출력
            // log.error("Invalid JWT token: {}", e.getMessage());
            return false;
        }
    }

    /**
     * JWT 토큰에서 userId를 추출합니다.
     *
     * @param token JWT 토큰
     * @return 추출된 userId
     */
    public String extractUserId(String token) {
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
        return claims.getSubject();
    }
}

--------


File: ./api-gateway/src/main/java/com/zzimcong/apigateway/ApiGatewayApplication.java
--------
package com.zzimcong.apigateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}


--------


File: ./api-gateway/src/main/java/com/zzimcong/apigateway/filter/JwtAuthFilter.java
--------
package com.zzimcong.apigateway.filter;

import com.zzimcong.apigateway.util.JwtUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Slf4j(topic = "JwtAuthFilter")
@Component
public class JwtAuthFilter extends AbstractGatewayFilterFactory<JwtAuthFilter.Config> {

    private final JwtUtil jwtUtil;

    public JwtAuthFilter(JwtUtil jwtUtil) {
        super(Config.class);
        this.jwtUtil = jwtUtil;
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            String token = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);

            // JWT 토큰이 없거나 "Bearer " 접두사가 없는 경우
            if (token == null || !token.startsWith("Bearer ")) {
                return onError(exchange, "인증 토큰이 없거나 잘못되었습니다.", HttpStatus.UNAUTHORIZED);
            }

            // "Bearer " 접두사 제거
            token = token.substring(7);

            // 토큰 유효성 검사
            if (!jwtUtil.validateToken(token)) {
                return onError(exchange, "유효하지 않은 JWT 토큰입니다.", HttpStatus.UNAUTHORIZED);
            }

            // userId 추출 및 요청 속성에 저장
            String userId = jwtUtil.extractUserId(token);
            ServerWebExchange modifiedExchange = exchange.mutate()
                    .request(exchange.getRequest().mutate()
                            .header("X-Auth-User-ID", userId)
                            .build())
                    .build();

            return chain.filter(modifiedExchange);
        };
    }

    private Mono<Void> onError(ServerWebExchange exchange, String err, HttpStatus httpStatus) {
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(httpStatus);
        response.getHeaders().add("Content-Type", "application/json;charset=UTF-8");
        String responseBody = String.format("{\"error\": \"%s\"}", err);
        log.error("Authentication error: {}", err);
        return response.writeWith(Mono.just(response.bufferFactory().wrap(responseBody.getBytes())));
    }

    public static class Config {
        // 필요한 경우 설정 속성을 추가할 수 있습니다.
    }
}

--------


File: ./eureka-server/src/test/java/com/zzimcong/eurekaserver/EurekaServerApplicationTests.java
--------
package com.zzimcong.eurekaserver;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class EurekaServerApplicationTests {

    @Test
    void contextLoads() {
    }

}


--------


File: ./eureka-server/src/main/java/com/zzimcong/eurekaserver/EurekaServerApplication.java
--------
package com.zzimcong.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}


--------


File: ./user/bin/generated-sources/annotations/com/zzimcong/user/domain/mapper/AddressMapperImpl.java
--------
package com.zzimcong.user.domain.mapper;

import com.zzimcong.user.application.dto.AddressCreateRequest;
import com.zzimcong.user.application.dto.AddressResponse;
import com.zzimcong.user.application.dto.AddressUpdateRequest;
import com.zzimcong.user.domain.entity.Address;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-24T13:14:36+0900",
    comments = "version: 1.5.3.Final, compiler: Eclipse JDT (IDE) 3.39.0.v20240725-1906, environment: Java 17.0.11 (Eclipse Adoptium)"
)
@Component
public class AddressMapperImpl implements AddressMapper {

    @Override
    public Address toEntity(AddressCreateRequest request) {
        if ( request == null ) {
            return null;
        }

        Address.AddressBuilder address = Address.builder();

        address.addressDetail( request.addressDetail() );
        address.isDefault( request.isDefault() );
        address.message( request.message() );
        address.name( request.name() );
        address.phone( request.phone() );
        address.streetAddress( request.streetAddress() );
        address.zipcode( request.zipcode() );

        return address.build();
    }

    @Override
    public void updateEntityFromDto(AddressUpdateRequest request, Address address) {
        if ( request == null ) {
            return;
        }

        address.setAddressDetail( request.addressDetail() );
        address.setIsDefault( request.isDefault() );
        address.setMessage( request.message() );
        address.setName( request.name() );
        address.setPhone( request.phone() );
        address.setStreetAddress( request.streetAddress() );
        address.setZipcode( request.zipcode() );

        setDefaults( address );
    }

    @Override
    public AddressResponse toDto(Address address) {
        if ( address == null ) {
            return null;
        }

        Long id = null;
        String name = null;
        String streetAddress = null;
        String addressDetail = null;
        String zipcode = null;
        String phone = null;
        String message = null;
        boolean isDefault = false;

        id = address.getId();
        name = address.getName();
        streetAddress = address.getStreetAddress();
        addressDetail = address.getAddressDetail();
        zipcode = address.getZipcode();
        phone = address.getPhone();
        message = address.getMessage();
        if ( address.getIsDefault() != null ) {
            isDefault = address.getIsDefault();
        }

        AddressResponse addressResponse = new AddressResponse( id, name, streetAddress, addressDetail, zipcode, phone, message, isDefault );

        return addressResponse;
    }

    @Override
    public List<AddressResponse> toDtoList(List<Address> addresses) {
        if ( addresses == null ) {
            return null;
        }

        List<AddressResponse> list = new ArrayList<AddressResponse>( addresses.size() );
        for ( Address address : addresses ) {
            list.add( toDto( address ) );
        }

        return list;
    }
}


--------


File: ./user/bin/generated-sources/annotations/com/zzimcong/user/domain/mapper/UserMapperImpl.java
--------
package com.zzimcong.user.domain.mapper;

import com.zzimcong.user.application.dto.SignupRequest;
import com.zzimcong.user.application.dto.UserModifyRequest;
import com.zzimcong.user.application.dto.UserResponse;
import com.zzimcong.user.domain.entity.User;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-24T13:14:36+0900",
    comments = "version: 1.5.3.Final, compiler: Eclipse JDT (IDE) 3.39.0.v20240725-1906, environment: Java 17.0.11 (Eclipse Adoptium)"
)
@Component
public class UserMapperImpl extends UserMapper {

    @Override
    public User toEntity(SignupRequest dto) {
        if ( dto == null ) {
            return null;
        }

        User.UserBuilder user = User.builder();

        user.name( aesUtil.encrypt(dto.name()) );
        user.email( aesUtil.encrypt(dto.email()) );
        user.phone( aesUtil.encrypt(dto.phone()) );
        user.password( passwordEncoder.encode(dto.password()) );

        return user.build();
    }

    @Override
    public UserResponse toDto(User user) {
        if ( user == null ) {
            return null;
        }

        Long id = null;

        id = user.getId();

        String email = aesUtil.decrypt(user.getEmail());
        String username = aesUtil.decrypt(user.getName());
        String phone = aesUtil.decrypt(user.getPhone());

        UserResponse userResponse = new UserResponse( id, email, username, phone );

        return userResponse;
    }

    @Override
    public User updateFromDto(UserModifyRequest dto, User user) {
        if ( dto == null ) {
            return user;
        }

        user.setName( aesUtil.encrypt(dto.name()) );
        user.setPhone( aesUtil.encrypt(dto.phone()) );
        user.setPassword( passwordEncoder.encode(dto.password()) );

        return user;
    }
}


--------


File: ./user/build/generated/sources/annotationProcessor/java/main/com/zzimcong/user/domain/mapper/AddressMapperImpl.java
--------
package com.zzimcong.user.domain.mapper;

import com.zzimcong.user.application.dto.AddressCreateRequest;
import com.zzimcong.user.application.dto.AddressResponse;
import com.zzimcong.user.application.dto.AddressUpdateRequest;
import com.zzimcong.user.domain.entity.Address;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-25T15:08:01+0900",
    comments = "version: 1.5.3.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.8.jar, environment: Java 22.0.1 (Eclipse Adoptium)"
)
@Component
public class AddressMapperImpl implements AddressMapper {

    @Override
    public Address toEntity(AddressCreateRequest request) {
        if ( request == null ) {
            return null;
        }

        Address.AddressBuilder address = Address.builder();

        address.name( request.name() );
        address.streetAddress( request.streetAddress() );
        address.addressDetail( request.addressDetail() );
        address.zipcode( request.zipcode() );
        address.phone( request.phone() );
        address.message( request.message() );
        address.isDefault( request.isDefault() );

        return address.build();
    }

    @Override
    public void updateEntityFromDto(AddressUpdateRequest request, Address address) {
        if ( request == null ) {
            return;
        }

        address.setName( request.name() );
        address.setStreetAddress( request.streetAddress() );
        address.setAddressDetail( request.addressDetail() );
        address.setZipcode( request.zipcode() );
        address.setPhone( request.phone() );
        address.setMessage( request.message() );
        address.setIsDefault( request.isDefault() );

        setDefaults( address );
    }

    @Override
    public AddressResponse toDto(Address address) {
        if ( address == null ) {
            return null;
        }

        Long id = null;
        String name = null;
        String streetAddress = null;
        String addressDetail = null;
        String zipcode = null;
        String phone = null;
        String message = null;
        boolean isDefault = false;

        id = address.getId();
        name = address.getName();
        streetAddress = address.getStreetAddress();
        addressDetail = address.getAddressDetail();
        zipcode = address.getZipcode();
        phone = address.getPhone();
        message = address.getMessage();
        if ( address.getIsDefault() != null ) {
            isDefault = address.getIsDefault();
        }

        AddressResponse addressResponse = new AddressResponse( id, name, streetAddress, addressDetail, zipcode, phone, message, isDefault );

        return addressResponse;
    }

    @Override
    public List<AddressResponse> toDtoList(List<Address> addresses) {
        if ( addresses == null ) {
            return null;
        }

        List<AddressResponse> list = new ArrayList<AddressResponse>( addresses.size() );
        for ( Address address : addresses ) {
            list.add( toDto( address ) );
        }

        return list;
    }
}


--------


File: ./user/build/generated/sources/annotationProcessor/java/main/com/zzimcong/user/domain/mapper/UserMapperImpl.java
--------
package com.zzimcong.user.domain.mapper;

import com.zzimcong.user.application.dto.SignupRequest;
import com.zzimcong.user.application.dto.UserModifyRequest;
import com.zzimcong.user.application.dto.UserResponse;
import com.zzimcong.user.domain.entity.User;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2024-08-25T15:08:01+0900",
    comments = "version: 1.5.3.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.8.jar, environment: Java 22.0.1 (Eclipse Adoptium)"
)
@Component
public class UserMapperImpl extends UserMapper {

    @Override
    public User toEntity(SignupRequest dto) {
        if ( dto == null ) {
            return null;
        }

        User.UserBuilder user = User.builder();

        user.name( aesUtil.encrypt(dto.name()) );
        user.email( aesUtil.encrypt(dto.email()) );
        user.phone( aesUtil.encrypt(dto.phone()) );
        user.password( passwordEncoder.encode(dto.password()) );

        return user.build();
    }

    @Override
    public UserResponse toDto(User user) {
        if ( user == null ) {
            return null;
        }

        Long id = null;

        id = user.getId();

        String email = aesUtil.decrypt(user.getEmail());
        String username = aesUtil.decrypt(user.getName());
        String phone = aesUtil.decrypt(user.getPhone());

        UserResponse userResponse = new UserResponse( id, email, username, phone );

        return userResponse;
    }

    @Override
    public User updateFromDto(UserModifyRequest dto, User user) {
        if ( dto == null ) {
            return user;
        }

        user.setName( aesUtil.encrypt(dto.name()) );
        user.setPhone( aesUtil.encrypt(dto.phone()) );
        user.setPassword( passwordEncoder.encode(dto.password()) );

        return user;
    }
}


--------


File: ./user/src/test/java/com/zzimcong/user/UserApplicationTests.java
--------
//package com.zzimcong.user;
//
//import org.junit.jupiter.api.Test;
//import org.springframework.boot.test.context.SpringBootTest;
//
//@SpringBootTest
//class UserApplicationTests {
//
//    @Test
//    void contextLoads() {
//    }
//
//}


--------


File: ./user/src/test/java/com/zzimcong/user/application/service/EmailVerificationServiceTest.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.common.exception.ConflictException;
import com.zzimcong.user.common.exception.UnauthorizedException;
import com.zzimcong.user.common.util.RedisUtil;
import com.zzimcong.user.infrastructure.config.EmailProperties;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

class EmailVerificationServiceTest {

    @Mock
    private EmailProperties emailProperties;

    @Mock
    private EmailService emailService;

    @Mock
    private UserService userService;

    @Mock
    private RedisUtil redisUtil;

    @InjectMocks
    private EmailVerificationService emailVerificationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testSendVerificationEmail() {
        when(userService.isEmailAvailable("test@example.com")).thenReturn(true);
        when(emailService.generateVerificationCode()).thenReturn("123456");

        emailVerificationService.sendVerificationEmail("test@example.com");

        verify(emailService, times(1)).sendVerificationEmail(eq("test@example.com"), anyString());
        verify(redisUtil, times(1)).setDataExpire(anyString(), eq("test@example.com"), anyLong());
    }

    @Test
    void testSendVerificationEmailDuplicateEmail() {
        when(userService.isEmailAvailable("test@example.com")).thenReturn(false);

        assertThrows(ConflictException.class, () -> emailVerificationService.sendVerificationEmail("test@example.com"));

        verify(emailService, never()).sendVerificationEmail(anyString(), anyString());
        verify(redisUtil, never()).setDataExpire(anyString(), anyString(), anyLong());
    }

    @Test
    void testVerifyEmailAndGenerateToken() {
        when(redisUtil.getData("123456")).thenReturn("test@example.com");

        String token = emailVerificationService.verifyEmailAndGenerateToken("test@example.com", "123456");

        assertNotNull(token);
        verify(redisUtil, times(1)).getData("123456");
    }

    @Test
    void testVerifyEmailAndGenerateTokenInvalidCode() {
        when(redisUtil.getData("123456")).thenReturn(null);

        assertThrows(UnauthorizedException.class, () -> emailVerificationService.verifyEmailAndGenerateToken("test@example.com", "123456"));

        verify(redisUtil, times(1)).getData("123456");
    }

    @Test
    void testValidateTokenForRegistration() {
        String email = "test@example.com";
        String token = "valid-token";

        emailVerificationService.validateTokenForRegistration(email, token);

        // 이 메서드가 예외를 던지지 않고 정상적으로 완료되면 테스트는 성공입니다.
    }

    @Test
    void testValidateTokenForRegistrationInvalidToken() {
        String email = "test@example.com";
        String token = "invalid-token";

        assertThrows(UnauthorizedException.class, () -> emailVerificationService.validateTokenForRegistration(email, token));
    }

    @Test
    void testIsEmailAvailable() {
        when(userService.isEmailAvailable("test@example.com")).thenReturn(true);

        boolean result = emailVerificationService.isEmailAvailable("test@example.com");

        assertTrue(result);
        verify(userService, times(1)).isEmailAvailable("test@example.com");
    }

    @Test
    void testIsEmailAvailableFalse() {
        when(userService.isEmailAvailable("test@example.com")).thenReturn(false);

        boolean result = emailVerificationService.isEmailAvailable("test@example.com");

        assertFalse(result);
        verify(userService, times(1)).isEmailAvailable("test@example.com");
    }
}


--------


File: ./user/src/test/java/com/zzimcong/user/application/service/AddressServiceTest.java
--------
//package com.zzimcong.user.application.service;
//
//import com.zzimcong.user.application.dto.AddressCreateRequest;
//import com.zzimcong.user.application.dto.AddressResponse;
//import com.zzimcong.user.application.dto.AddressUpdateRequest;
//import com.zzimcong.user.common.exception.NotFoundException;
//import com.zzimcong.user.domain.entity.Address;
//import com.zzimcong.user.domain.mapper.AddressMapper;
//import com.zzimcong.user.domain.repository.AddressRepository;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.mockito.InjectMocks;
//import org.mockito.Mock;
//import org.mockito.MockitoAnnotations;
//
//import java.util.Arrays;
//import java.util.List;
//import java.util.Optional;
//
//import static org.junit.jupiter.api.Assertions.*;
//import static org.mockito.Mockito.*;
//
//class AddressServiceTest {
//
//    @Mock
//    private AddressRepository addressRepository;
//
//    @Mock
//    private AddressMapper addressMapper;
//
//    @InjectMocks
//    private AddressService addressService;
//
//    @BeforeEach
//    void setUp() {
//        MockitoAnnotations.openMocks(this);
//    }
//
//    @Test
//    void testCreateAddress() {
//        AddressCreateRequest request = new AddressCreateRequest("John Doe", "123 Main St", "Apt 4", "12345", "1234567890", "Leave at door", true);
//        Address address = new Address();
//        address.setId(1L);
//
//        when(addressMapper.toEntity(request)).thenReturn(address);
//        when(addressRepository.save(address)).thenReturn(address);
//        when(addressMapper.toDto(address)).thenReturn(new AddressResponse(1L, "John Doe", "123 Main St", "Apt 4", "12345", "1234567890", "Leave at door", true));
//
//        AddressResponse result = addressService.createAddress(1L, request);
//
//        assertNotNull(result);
//        assertEquals(1L, result.id());
//        assertEquals("John Doe", result.name());
//
//        verify(addressMapper).toEntity(request);
//        verify(addressRepository).save(address);
//        verify(addressMapper).toDto(address);
//    }
//
//    @Test
//    void testGetAddress() {
//        Address address = new Address();
//        address.setId(1L);
//        address.setUserId(1L);
//
//        when(addressRepository.findById(1L)).thenReturn(Optional.of(address));
//        when(addressMapper.toDto(address)).thenReturn(new AddressResponse(1L, "John Doe", "123 Main St", "Apt 4", "12345", "1234567890", "Leave at door", true));
//
//        AddressResponse result = addressService.getAddress(1L, 1L);
//
//        assertNotNull(result);
//        assertEquals(1L, result.id());
//
//        verify(addressRepository).findById(1L);
//        verify(addressMapper).toDto(address);
//    }
//
//    @Test
//    void testGetAddressNotFound() {
//        when(addressRepository.findById(1L)).thenReturn(Optional.empty());
//
//        assertThrows(NotFoundException.class, () -> addressService.getAddress(1L, 1L));
//
//        verify(addressRepository).findById(1L);
//    }
//
//    @Test
//    void testGetUserAddresses() {
//        Address address1 = new Address();
//        address1.setId(1L);
//        Address address2 = new Address();
//        address2.setId(2L);
//        List<Address> addresses = Arrays.asList(address1, address2);
//
//        when(addressRepository.findAllByUserId(1L)).thenReturn(addresses);
//        when(addressMapper.toDtoList(addresses)).thenReturn(Arrays.asList(
//                new AddressResponse(1L, "John Doe", "123 Main St", "Apt 4", "12345", "1234567890", "Leave at door", true),
//                new AddressResponse(2L, "Jane Doe", "456 Elm St", "Suite 2", "67890", "9876543210", "Ring bell", false)
//        ));
//
//        List<AddressResponse> result = addressService.getUserAddresses(1L);
//
//        assertNotNull(result);
//        assertEquals(2, result.size());
//
//        verify(addressRepository).findAllByUserId(1L);
//        verify(addressMapper).toDtoList(addresses);
//    }
//
//    @Test
//    void testUpdateAddress() {
//        // 테스트 데이터 준비
//        Long userId = 1L;
//        Long addressId = 1L;
//        AddressUpdateRequest request = new AddressUpdateRequest("John Doe Updated", "456 Elm St", "Suite 2", "67890", "9876543210", "Ring bell", false);
//
//        // 기존 주소 객체 생성
//        Address existingAddress = new Address();
//        existingAddress.setId(addressId);
//        existingAddress.setUserId(userId);
//
//        // Mock 객체 설정
//        when(addressRepository.findById(addressId)).thenReturn(Optional.of(existingAddress));
//
//        // updateEntityFromDto 메소드 동작 설정
//        doAnswer(invocation -> {
//            Address address = invocation.getArgument(1);
//            address.setName(request.name());
//            address.setStreetAddress(request.streetAddress());
//            // 나머지 필드들도 설정...
//            return null;
//        }).when(addressMapper).updateEntityFromDto(eq(request), any(Address.class));
//
//        // toDto 메소드 동작 설정
//        when(addressMapper.toDto(any(Address.class))).thenAnswer(invocation -> {
//            Address address = invocation.getArgument(0);
//            return new AddressResponse(
//                    address.getId(),
//                    address.getName(),
//                    address.getStreetAddress(),
//                    address.getAddressDetail(),
//                    address.getZipcode(),
//                    address.getPhone(),
//                    address.getMessage(),
//                    address.getIsDefault()
//            );
//        });
//
//        // 테스트 실행
//        AddressResponse result = addressService.updateAddress(userId, addressId, request);
//
//        // 결과 검증
//        assertNotNull(result, "결과가 null이면 안됩니다.");
//        assertEquals("John Doe Updated", result.name(), "이름이 올바르게 업데이트되어야 합니다.");
//        assertEquals("456 Elm St", result.streetAddress(), "주소가 올바르게 업데이트되어야 합니다.");
//
//        // Mock 객체 호출 검증
//        verify(addressRepository).findById(addressId);
//        verify(addressMapper).updateEntityFromDto(eq(request), any(Address.class));
//        verify(addressRepository).save(existingAddress);
//        verify(addressMapper).toDto(existingAddress);
//    }
//
//    @Test
//    void testDeleteAddress() {
//        Address address = new Address();
//        address.setId(1L);
//        address.setUserId(1L);
//
//        when(addressRepository.findById(1L)).thenReturn(Optional.of(address));
//
//        addressService.deleteAddress(1L, 1L);
//
//        verify(addressRepository).findById(1L);
//        verify(addressRepository).delete(address);
//    }
//
//    @Test
//    void testSetDefaultAddress() {
//        Address address = new Address();
//        address.setId(1L);
//        address.setUserId(1L);
//
//        when(addressRepository.findById(1L)).thenReturn(Optional.of(address));
//        when(addressMapper.toDto(address)).thenReturn(new AddressResponse(1L, "John Doe", "123 Main St", "Apt 4", "12345", "1234567890", "Leave at door", true));
//
//        AddressResponse result = addressService.setDefaultAddress(1L, 1L);
//
//        assertNotNull(result);
//        assertTrue(result.isDefault());
//
//        verify(addressRepository).findById(1L);
//        verify(addressRepository).resetDefaultForUser(1L);
//        verify(addressRepository).save(address);
//        verify(addressMapper).toDto(address);
//    }
//
//    @Test
//    void testGetDefaultAddress() {
//        Address address = new Address();
//        address.setId(1L);
//        address.setUserId(1L);
//        address.setIsDefault(true);
//
//        when(addressRepository.findAllByUserIdAndIsDefaultTrue(1L)).thenReturn(Optional.of(address));
//        when(addressMapper.toDto(address)).thenReturn(new AddressResponse(1L, "John Doe", "123 Main St", "Apt 4", "12345", "1234567890", "Leave at door", true));
//
//        AddressResponse result = addressService.getDefaultAddress(1L);
//
//        assertNotNull(result);
//        assertTrue(result.isDefault());
//
//        verify(addressRepository).findAllByUserIdAndIsDefaultTrue(1L);
//        verify(addressMapper).toDto(address);
//    }
//}

--------


File: ./user/src/test/java/com/zzimcong/user/application/service/AuthServiceTest.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.application.dto.AuthResponse;
import com.zzimcong.user.application.dto.LoginRequest;
import com.zzimcong.user.application.dto.SignupRequest;
import com.zzimcong.user.common.exception.UnauthorizedException;
import com.zzimcong.user.common.util.SecurityUtil;
import com.zzimcong.user.infrastructure.security.jwt.JwtUtil;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.MockitoAnnotations;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

class AuthServiceTest {

    @Mock
    private TokenService tokenService;

    @Mock
    private UserService userService;

    @Mock
    private EmailVerificationService emailVerificationService;

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private AuthenticationManager authenticationManager;

    @InjectMocks
    private AuthService authService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testSignUp() {
        SignupRequest signupRequest = new SignupRequest("test@example.com", "test", "010-0000-0000", "password");

        doNothing().when(emailVerificationService).validateTokenForRegistration(anyString(), anyString());
        when(userService.createUser(any(SignupRequest.class))).thenReturn(null);

        assertDoesNotThrow(() -> authService.signUp(signupRequest, "token"));

        verify(emailVerificationService, times(1)).validateTokenForRegistration(anyString(), anyString());
        verify(userService, times(1)).createUser(any(SignupRequest.class));
    }

    @Test
    void testLogin() {
        LoginRequest loginRequest = new LoginRequest("test@example.com", "password");

        Authentication authentication = mock(Authentication.class);
        UserDetails userDetails = User.withUsername("1").password("password").roles("USER").build();

        when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class))).thenReturn(authentication);
        when(authentication.getPrincipal()).thenReturn(userDetails);
        when(jwtUtil.generateAccessToken(anyLong())).thenReturn("accessToken");
        when(jwtUtil.generateRefreshToken(anyLong())).thenReturn("refreshToken");

        AuthResponse authResponse = authService.login(loginRequest);

        assertNotNull(authResponse);
        assertEquals("accessToken", authResponse.accessToken());
        assertEquals("refreshToken", authResponse.refreshToken());

        verify(authenticationManager, times(1)).authenticate(any(UsernamePasswordAuthenticationToken.class));
        verify(jwtUtil, times(1)).generateAccessToken(anyLong());
        verify(jwtUtil, times(1)).generateRefreshToken(anyLong());
        verify(tokenService, times(1)).storeRefreshToken(anyString(), anyString());
    }

    @Test
    void testLogout() {
        try (MockedStatic<SecurityUtil> mockedSecurityUtil = mockStatic(SecurityUtil.class)) {
            mockedSecurityUtil.when(SecurityUtil::getCurrentUserId).thenReturn(1L);

            assertDoesNotThrow(() -> authService.logout());

            verify(tokenService, times(1)).deleteRefreshToken("1");
        }
    }

    @Test
    void testRefreshToken() {
        String refreshToken = "validRefreshToken";
        when(jwtUtil.validateToken(refreshToken)).thenReturn(true);
        when(jwtUtil.extractId(refreshToken)).thenReturn(1L);
        when(jwtUtil.generateAccessToken(1L)).thenReturn("newAccessToken");
        when(jwtUtil.generateRefreshToken(1L)).thenReturn("newRefreshToken");

        AuthResponse result = authService.refreshToken(refreshToken);

        assertNotNull(result);
        assertEquals("newAccessToken", result.accessToken());
        assertEquals("newRefreshToken", result.refreshToken());

        verify(jwtUtil, times(1)).validateToken(refreshToken);
        verify(jwtUtil, times(1)).extractId(refreshToken);
        verify(jwtUtil, times(1)).generateAccessToken(1L);
        verify(jwtUtil, times(1)).generateRefreshToken(1L);
        verify(tokenService, times(1)).storeRefreshToken("1", "newRefreshToken");
    }

    @Test
    void testRefreshTokenInvalid() {
        String refreshToken = "invalidRefreshToken";
        when(jwtUtil.validateToken(refreshToken)).thenReturn(false);

        assertThrows(UnauthorizedException.class, () -> authService.refreshToken(refreshToken));

        verify(jwtUtil, times(1)).validateToken(refreshToken);
        verify(jwtUtil, never()).extractId(anyString());
        verify(jwtUtil, never()).generateAccessToken(anyLong());
    }
}

--------


File: ./user/src/test/java/com/zzimcong/user/application/service/UserServiceTest.java
--------
//package com.zzimcong.user.application.service;
//
//import com.zzimcong.user.application.dto.SignupRequest;
//import com.zzimcong.user.application.dto.UserModifyRequest;
//import com.zzimcong.user.application.dto.UserResponse;
//import com.zzimcong.user.common.exception.ConflictException;
//import com.zzimcong.user.common.exception.NotFoundException;
//import com.zzimcong.user.common.util.AESUtil;
//import com.zzimcong.user.domain.entity.User;
//import com.zzimcong.user.domain.entity.UserRole;
//import com.zzimcong.user.domain.mapper.UserMapper;
//import com.zzimcong.user.domain.repository.UserRepository;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.mockito.InjectMocks;
//import org.mockito.Mock;
//import org.mockito.MockitoAnnotations;
//
//import java.util.Optional;
//
//import static org.junit.jupiter.api.Assertions.*;
//import static org.mockito.ArgumentMatchers.any;
//import static org.mockito.ArgumentMatchers.argThat;
//import static org.mockito.Mockito.*;
//
//class UserServiceTest {
//
//    @Mock
//    private UserRepository userRepository;
//
//    @Mock
//    private UserMapper userMapper;
//
//    @Mock
//    private AESUtil aesUtil;
//
//    @InjectMocks
//    private UserService userService;
//
//    @BeforeEach
//    void setUp() {
//        MockitoAnnotations.openMocks(this);
//    }
//
//    @Test
//    void testIsEmailAvailable() {
//        when(aesUtil.encrypt("test@example.com")).thenReturn("encryptedEmail");
//        when(userRepository.existsByEmail("encryptedEmail")).thenReturn(false);
//
//        assertTrue(userService.isEmailAvailable("test@example.com"));
//
//        verify(aesUtil).encrypt("test@example.com");
//        verify(userRepository).existsByEmail("encryptedEmail");
//    }
//
//    @Test
//    void testCreateUser() {
//        SignupRequest signupRequest = new SignupRequest("test@example.com", "Test User", "1234567890", "password");
//        User user = User.builder()
//                .id(1L)
//                .email("encryptedEmail")
//                .name("encryptedName")
//                .phone("encryptedPhone")
//                .password("encodedPassword")
//                .role(UserRole.USER)
//                .build();
//
//        when(aesUtil.encrypt("test@example.com")).thenReturn("encryptedEmail");
//        when(userRepository.existsByEmail("encryptedEmail")).thenReturn(false);
//        when(userMapper.toEntity(signupRequest)).thenReturn(user);
//        when(userRepository.save(user)).thenReturn(user);
//        when(userMapper.toDto(user)).thenReturn(new UserResponse(1L, "test@example.com", "Test User", "1234567890"));
//
//        UserResponse result = userService.createUser(signupRequest);
//
//        assertNotNull(result);
//        assertEquals(1L, result.id());
//        assertEquals("test@example.com", result.email());
//
//        verify(userRepository).existsByEmail("encryptedEmail");
//        verify(userMapper).toEntity(signupRequest);
//        verify(userRepository).save(user);
//        verify(userMapper).toDto(user);
//    }
//
//    @Test
//    void testCreateUserDuplicateEmail() {
//        SignupRequest signupRequest = new SignupRequest("test@example.com", "Test User", "1234567890", "password");
//
//        when(aesUtil.encrypt("test@example.com")).thenReturn("encryptedEmail");
//        when(userRepository.existsByEmail("encryptedEmail")).thenReturn(true);
//
//        assertThrows(ConflictException.class, () -> userService.createUser(signupRequest));
//
//        verify(userRepository).existsByEmail("encryptedEmail");
//        verify(userMapper, never()).toEntity(any());
//        verify(userRepository, never()).save(any());
//    }
//
//    @Test
//    void testGetUserById() {
//        User user = User.builder()
//                .id(1L)
//                .email("encryptedEmail")
//                .name("encryptedName")
//                .phone("encryptedPhone")
//                .password("encodedPassword")
//                .role(UserRole.USER)
//                .build();
//
//        when(userRepository.findById(1L)).thenReturn(Optional.of(user));
//        when(userMapper.toDto(user)).thenReturn(new UserResponse(1L, "test@example.com", "Test User", "1234567890"));
//
//        UserResponse result = userService.getUserById(1L);
//
//        assertNotNull(result);
//        assertEquals(1L, result.id());
//
//        verify(userRepository).findById(1L);
//        verify(userMapper).toDto(user);
//    }
//
//    @Test
//    void testGetUserByIdNotFound() {
//        when(userRepository.findById(1L)).thenReturn(Optional.empty());
//
//        assertThrows(NotFoundException.class, () -> userService.getUserById(1L));
//
//        verify(userRepository).findById(1L);
//    }
//
//    @Test
//    void testUpdateUser() {
//        UserModifyRequest userModifyRequest = new UserModifyRequest("Updated User", "9876543210", "newpassword");
//        User existingUser = User.builder()
//                .id(1L)
//                .email("encryptedEmail")
//                .name("encryptedName")
//                .phone("encryptedPhone")
//                .password("encodedPassword")
//                .role(UserRole.USER)
//                .build();
//
//        User updatedUser = User.builder()
//                .id(1L)
//                .email("encryptedEmail")
//                .name("encryptedUpdatedName")
//                .phone("encryptedUpdatedPhone")
//                .password("encodedNewPassword")
//                .role(UserRole.USER)
//                .build();
//
//        when(userRepository.findById(1L)).thenReturn(Optional.of(existingUser));
//        when(userMapper.updateFromDto(userModifyRequest, existingUser)).thenReturn(updatedUser);
//        when(userRepository.save(updatedUser)).thenReturn(updatedUser);
//        when(userMapper.toDto(updatedUser)).thenReturn(new UserResponse(1L, "test@example.com", "Updated User", "9876543210"));
//
//        UserResponse result = userService.updateUser(1L, userModifyRequest);
//
//        assertNotNull(result);
//        assertEquals("Updated User", result.username());
//        assertEquals("9876543210", result.phone());
//
//        verify(userRepository).findById(1L);
//        verify(userMapper).updateFromDto(userModifyRequest, existingUser);
//        verify(userRepository).save(updatedUser);
//        verify(userMapper).toDto(updatedUser);
//    }
//
//    @Test
//    void testSignoutUser() {
//        User user = User.builder()
//                .id(1L)
//                .email("encryptedEmail")
//                .name("encryptedName")
//                .phone("encryptedPhone")
//                .password("encodedPassword")
//                .role(UserRole.USER)
//                .signout(false)
//                .build();
//
//        User signedOutUser = User.builder()
//                .id(1L)
//                .email("encryptedEmail")
//                .name("encryptedName")
//                .phone("encryptedPhone")
//                .password("encodedPassword")
//                .role(UserRole.USER)
//                .signout(true)
//                .build();
//
//        when(userRepository.findById(1L)).thenReturn(Optional.of(user));
//        when(userRepository.save(any(User.class))).thenReturn(signedOutUser);
//
//        userService.signoutUser(1L);
//
//        verify(userRepository).findById(1L);
//        verify(userRepository).save(argThat(savedUser -> savedUser.getSignout()));
//    }
//}

--------


File: ./user/src/main/java/com/zzimcong/user/common/util/SecurityUtil.java
--------
package com.zzimcong.user.common.util;

import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.UnauthorizedException;
import com.zzimcong.user.infrastructure.security.UserDetailsImpl;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

public class SecurityUtil {
    public static Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !(authentication.getPrincipal() instanceof UserDetailsImpl)) {
            throw new UnauthorizedException(ErrorCode.USER_NOT_AUTHENTICATED);
        }
        return Long.parseLong(((UserDetailsImpl) authentication.getPrincipal()).getUsername());
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/util/KeyManagementUtil.java
--------
package com.zzimcong.user.common.util;

import lombok.Getter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

@Component
public class KeyManagementUtil {

    private final Environment environment;
    @Getter
    private String encryptionKey;

    @Autowired
    public KeyManagementUtil(Environment environment) {
        this.environment = environment;
        initEncryptionKey();
    }

    private void initEncryptionKey() {
        // 시스템 환경 변수에서 먼저 확인
        encryptionKey = System.getenv("ENCRYPTION_KEY");

        // 시스템 환경 변수에 없으면 스프링 Environment에서 확인
        if (encryptionKey == null || encryptionKey.isEmpty()) {
            encryptionKey = environment.getProperty("encryption.key");
        }

        // 둘 다 없으면 예외 발생
        if (encryptionKey == null || encryptionKey.isEmpty()) {
            throw new IllegalStateException("ENCRYPTION_KEY가 설정되지 않았습니다.");
        }
    }

}

--------


File: ./user/src/main/java/com/zzimcong/user/common/util/EmailVerificationToken.java
--------
package com.zzimcong.user.common.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@AllArgsConstructor
public class EmailVerificationToken {
    private String token;
    private String email;
    private LocalDateTime expiryDate;
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/util/RedisUtil.java
--------
package com.zzimcong.user.common.util;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Service
@RequiredArgsConstructor
public class RedisUtil {
    private final StringRedisTemplate redisTemplate;//Redis에 접근하기 위한 Spring의 Redis 템플릿 클래스

    public String getData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 가져오는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        return valueOperations.get(key);
    }

    public void setData(String key, String value) {//지정된 키(key)에 값을 저장하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        valueOperations.set(key, value);
    }

    public void setDataExpire(String key, String value, long duration) {//지정된 키(key)에 값을 저장하고, 지정된 시간(duration) 후에 데이터가 만료되도록 설정하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        Duration expireDuration = Duration.ofSeconds(duration);
        valueOperations.set(key, value, expireDuration);
    }

    public void deleteData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 삭제하는 메서드
        redisTemplate.delete(key);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/util/AESUtil.java
--------
package com.zzimcong.user.common.util;

import com.zzimcong.user.common.exception.BadRequestException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.InternalServerErrorException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Slf4j(topic = "AESUtil")
@Component
public class AESUtil {
    private static final String ALGORITHM = "AES";
    private static final String CIPHER_INSTANCE = "AES/ECB/PKCS5Padding";  // 명시적으로 모드와 패딩 지정

    private final KeyManagementUtil keyManagementUtil;

    @Autowired
    public AESUtil(KeyManagementUtil keyManagementUtil) {
        this.keyManagementUtil = keyManagementUtil;
    }

    public String encrypt(String data) {
        if(data == null) throw new BadRequestException(ErrorCode.INVALID_EMAIL);
        try {
            Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE);
            cipher.init(Cipher.ENCRYPT_MODE, getKeySpec());
            byte[] encryptedData = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(encryptedData);
        } catch (Exception e) {
            log.error("Encryption failed", e);
            throw new InternalServerErrorException(ErrorCode.ENCRYPTION_FAILED);
        }
    }

    public String decrypt(String encryptedData) {
        try {
            Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE);
            cipher.init(Cipher.DECRYPT_MODE, getKeySpec());
            byte[] decryptedData = cipher.doFinal(Base64.getDecoder().decode(encryptedData));
            return new String(decryptedData, StandardCharsets.UTF_8);
        } catch (Exception e) {
            log.error("Decryption failed", e);
            throw new InternalServerErrorException(ErrorCode.DECRYPTION_FAILED);
        }
    }

    private SecretKeySpec getKeySpec() {
        String key = keyManagementUtil.getEncryptionKey();
        byte[] decodedKey = Base64.getDecoder().decode(key);
        return new SecretKeySpec(decodedKey, ALGORITHM);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/UserInfo.java
--------
package com.zzimcong.user.common;

import lombok.Data;

@Data
public class UserInfo {
    private Long id;
    private String username;
    private String role;
    // 필요한 다른 필드들...
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/ErrorCode.java
--------
package com.zzimcong.user.common.exception;

import lombok.Getter;

@Getter
public enum ErrorCode {
    // BadRequestException (400)
    INVALID_INPUT("잘못된 입력입니다."),
    INVALID_EMAIL("잘못된 이메일 형식입니다."),
    INVALID_PASSWORD("잘못된 비밀번호 형식입니다."),
    INVALID_VERIFICATION_CODE("잘못된 인증 코드입니다."),
    EMAIL_VERIFICATION_FAILED("이메일 인증에 실패했습니다."),
    MISSING_REQUEST_BODY("요청 바디가 없습니다."),
    ADDRESS_NOT_FOUND("주소를 찾을 수 없습니다."),

    // UnauthorizedException (401)
    INVALID_CREDENTIALS("잘못된 인증 정보입니다."),
    INVALID_TOKEN("유효하지 않은 토큰입니다."),
    EXPIRED_TOKEN("만료된 토큰입니다."),
    TOKEN_NOT_FOUND("토큰을 찾을 수 없습니다."),
    USER_NOT_AUTHENTICATED("사용자가 인증되지 않았습니다."),

    // ForbiddenException (403)
    ACCESS_DENIED("접근 권한이 없습니다."),

    // NotFoundException (404)
    RESOURCE_NOT_FOUND("요청한 리소스를 찾을 수 없습니다."),
    USER_NOT_FOUND("사용자를 찾을 수 없습니다."),

    // MethodNotAllowedException (405)
    METHOD_NOT_ALLOWED("허용되지 않은 HTTP 메서드입니다."),

    // ConflictException (409)
    DUPLICATE_EMAIL("이미 존재하는 이메일입니다."),

    // InternalServerErrorException (500)
    ENCRYPTION_FAILED("사용자 정보 암호화에 실패했습니다."),
    DECRYPTION_FAILED("사용자 정보 복호화에 실패했습니다."),
    RESOURCE_LOAD_FAILED("내부 리소스 로딩에 실패했습니다."),
    EMAIL_SEND_FAILED("이메일 전송에 실패했습니다."),
    INTERNAL_SERVER_ERROR("서버 내부 오류가 발생했습니다."),
    UNKNOWN_ERROR("알 수 없는 오류가 발생했습니다.");

    private final String message;

    ErrorCode(String message) {
        this.message = message;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/ForbiddenException.java
--------
package com.zzimcong.user.common.exception;

public class ForbiddenException extends BaseException {
    public ForbiddenException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ForbiddenException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/UnauthorizedException.java
--------
package com.zzimcong.user.common.exception;

public class UnauthorizedException extends BaseException {
    public UnauthorizedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public UnauthorizedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/ConflictException.java
--------
package com.zzimcong.user.common.exception;

public class ConflictException extends BaseException {
    public ConflictException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ConflictException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/MethodNotAllowedException.java
--------
package com.zzimcong.user.common.exception;

public class MethodNotAllowedException extends BaseException {
    public MethodNotAllowedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public MethodNotAllowedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/InternalServerErrorException.java
--------
package com.zzimcong.user.common.exception;

public class InternalServerErrorException extends BaseException {
    public InternalServerErrorException(ErrorCode errorCode) {
        super(errorCode);
    }

    public InternalServerErrorException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}


--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/GlobalExceptionHandler.java
--------
package com.zzimcong.user.common.exception;

import com.zzimcong.user.api.response.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.protocol.HTTP;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j(topic = "GLOBAL_EXCEPTION_HANDLER")
@ControllerAdvice
public class GlobalExceptionHandler {
    // BadRequestException (400)
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorResponse> httpMessageNotReadableException(HttpServletRequest request) {
        BadRequestException ex = new BadRequestException(ErrorCode.MISSING_REQUEST_BODY);
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    // UnauthorizedException (401)
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(UnauthorizedException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.UNAUTHORIZED, request.getRequestURI());
    }

    // ForbiddenException (403)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbiddenException(ForbiddenException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.FORBIDDEN, request.getRequestURI());
    }

    // NotFoundException (404)
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.NOT_FOUND, request.getRequestURI());
    }

    // MethodNotAllowedException (405)
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowedException(HttpServletRequest request) {
        MethodNotAllowedException ex = new MethodNotAllowedException(ErrorCode.METHOD_NOT_ALLOWED);
        return createErrorResponse(ex, HttpStatus.METHOD_NOT_ALLOWED, request.getRequestURI());
    }

    // ConflictException (409)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(ConflictException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.CONFLICT, request.getRequestURI());
    }

    // InternalServerErrorException (500)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllException(Exception ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
    }

    // Create ErrorResponse
    private ResponseEntity<ErrorResponse> createErrorResponse(Exception ex, HttpStatus status, String path) {
        logException(ex, status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.INTERNAL_SERVER_ERROR);
        ErrorResponse errorResponse = ErrorResponse.of(baseException, status, path);
        return new ResponseEntity<>(errorResponse, status);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        // 스택 트레이스를 분석하여 예외 발생 위치 추출
        StackTraceElement[] stackTraceElements = ex.getStackTrace();
        String errorLocation = "Unknown";
        if (stackTraceElements.length > 0) {
            StackTraceElement element = stackTraceElements[0];
            errorLocation = String.format("%s.%s (Line: %d)",
                    element.getClassName(),
                    element.getMethodName(),
                    element.getLineNumber());
        }
        log.error(
                "Exception occurred:: {}, Path: {}",
                errorLocation,
                path
        );
        log.error("Error Code: {}, HTTP Status: {}, Message: {}",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage());
    }
}


--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/BadRequestException.java
--------
package com.zzimcong.user.common.exception;

public class BadRequestException extends BaseException {
    public BadRequestException(ErrorCode errorCode) {
        super(errorCode);
    }

    public BadRequestException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/BaseException.java
--------
package com.zzimcong.user.common.exception;

public class BaseException extends RuntimeException {
    private final ErrorCode errorCode;
    private final String message;

    public BaseException(ErrorCode errorCode) {
        this(errorCode, errorCode.getMessage());
    }

    public BaseException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.message = message;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    @Override
    public String getMessage() {
        return message;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/common/exception/NotFoundException.java
--------
package com.zzimcong.user.common.exception;

public class NotFoundException extends BaseException {
    public NotFoundException(ErrorCode errorCode) {
        super(errorCode);
    }

    public NotFoundException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/UserApplication.java
--------
package com.zzimcong.user;

import com.zzimcong.user.infrastructure.config.EmailProperties;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
@EnableConfigurationProperties(EmailProperties.class)
public class UserApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }
}


--------


File: ./user/src/main/java/com/zzimcong/user/api/response/ApiResponse.java
--------
package com.zzimcong.user.api.response;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }
}


--------


File: ./user/src/main/java/com/zzimcong/user/api/response/ErrorResponse.java
--------
package com.zzimcong.user.api.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.zzimcong.user.common.exception.BaseException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;
import java.util.Objects;

@Slf4j(topic = "error")
@JsonInclude(JsonInclude.Include.NON_NULL)
public record ErrorResponse(
        int status,
        String message,
        String errorCode,
        LocalDateTime timestamp,
        String path
) {
    public ErrorResponse {
        Objects.requireNonNull(message, "메시지는 null일 수 없습니다.");
        Objects.requireNonNull(errorCode, "에러 코드는 null일 수 없습니다.");
        Objects.requireNonNull(path, "경로는 null일 수 없습니다.");
        timestamp = LocalDateTime.now();
    }

    public static ErrorResponse of(BaseException ex, HttpStatus status, String path) {
        Objects.requireNonNull(ex, "예외는 null일 수 없습니다.");
        Objects.requireNonNull(status, "HTTP 상태는 null일 수 없습니다.");

        log.error("Error occurred: status={}, message={}, errorCode={}, path={}",
                status.value(), ex.getMessage(), ex.getErrorCode().name(), path, ex);

        return new ErrorResponse(
                status.value(),
                ex.getMessage(),
                ex.getErrorCode().name(),
                LocalDateTime.now(),
                path
        );
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/api/controller/EmailVerificationsController.java
--------
package com.zzimcong.user.api.controller;

import com.zzimcong.user.application.dto.EmailCheckResponse;
import com.zzimcong.user.application.dto.EmailRequest;
import com.zzimcong.user.application.service.EmailVerificationService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j(topic = "EMAIL_VERIFICATIONS_CONTROLLER")
@RestController
@RequestMapping("/api/v1/email-verifications")
public class EmailVerificationsController {
    private final EmailVerificationService emailVerificationService;

    @Autowired
    public EmailVerificationsController(EmailVerificationService emailVerificationService) {
        this.emailVerificationService = emailVerificationService;
    }

    @PostMapping("/send")
    public ResponseEntity<String> sendVerificationEmail(@RequestBody @Valid EmailRequest emailDto) {
        log.info("인증 이메일 전송 요청: {}", emailDto.email());
        emailVerificationService.sendVerificationEmail(emailDto.email());
        return ResponseEntity.ok("인증 이메일이 성공적으로 전송되었습니다.");
    }

    @PostMapping("/verify")
    public ResponseEntity<String> verifyEmail(@RequestBody @Valid EmailCheckResponse emailCheckResponse) {
        log.info("이메일 인증 요청: {}", emailCheckResponse.email());
        String token = emailVerificationService.verifyEmailAndGenerateToken(emailCheckResponse.email(), emailCheckResponse.authNum());
        return ResponseEntity.ok(token);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/api/controller/AddressController.java
--------
package com.zzimcong.user.api.controller;

import com.zzimcong.user.api.response.ApiResponse;
import com.zzimcong.user.application.dto.AddressCreateRequest;
import com.zzimcong.user.application.dto.AddressResponse;
import com.zzimcong.user.application.dto.AddressUpdateRequest;
import com.zzimcong.user.application.service.AddressService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j(topic = "ADDRESS_CONTROLLER")
@RestController
@RequestMapping("/api/v1/address")
@RequiredArgsConstructor
public class AddressController {

    private final AddressService addressService;

    @PostMapping
    public ResponseEntity<ApiResponse<AddressResponse>> createAddress(
            @RequestHeader("X-AUTH-USER-ID") Long userId,
            @RequestBody AddressCreateRequest request) {
        log.info("Creating new address for user: {}", userId);
        AddressResponse createdAddress = addressService.createAddress(userId, request);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(createdAddress, "주소가 성공적으로 생성되었습니다."));
    }

    @GetMapping
    public ResponseEntity<ApiResponse<List<AddressResponse>>> getUserAddresses(
            @RequestHeader("X-AUTH-USER-ID") Long userId) {
        log.info("Fetching all addresses for user with id: {}", userId);
        List<AddressResponse> addresses = addressService.getUserAddresses(userId);
        return ResponseEntity.ok(ApiResponse.success(addresses, "사용자의 모든 주소 조회에 성공하였습니다."));
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<AddressResponse>> getAddress(
            @RequestHeader("X-AUTH-USER-ID") Long userId,
            @PathVariable Long id) {
        log.info("Fetching address with id: {} for user: {}", id, userId);
        AddressResponse address = addressService.getAddress(userId, id);
        return ResponseEntity.ok(ApiResponse.success(address, "주소 조회에 성공하였습니다."));
    }

    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<AddressResponse>> updateAddress(
            @RequestHeader("X-AUTH-USER-ID") Long userId,
            @PathVariable Long id,
            @RequestBody AddressUpdateRequest request) {
        log.info("Updating address with id: {} for user: {}", id, userId);
        AddressResponse updatedAddress = addressService.updateAddress(userId, id, request);
        return ResponseEntity.ok(ApiResponse.success(updatedAddress, "주소가 성공적으로 업데이트되었습니다."));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteAddress(
            @RequestHeader("X-AUTH-USER-ID") Long userId,
            @PathVariable Long id) {
        log.info("Deleting address with id: {} for user: {}", id, userId);
        addressService.deleteAddress(userId, id);
        return ResponseEntity.ok(ApiResponse.success(null, "주소가 성공적으로 삭제되었습니다."));
    }

    @PutMapping("/{id}/set-default")
    public ResponseEntity<ApiResponse<AddressResponse>> setDefaultAddress(
            @RequestHeader("X-AUTH-USER-ID") Long userId,
            @PathVariable Long id) {
        log.info("Setting address with id: {} as default for user: {}", id, userId);
        AddressResponse updatedAddress = addressService.setDefaultAddress(userId, id);
        return ResponseEntity.ok(ApiResponse.success(updatedAddress, "기본 주소가 성공적으로 설정되었습니다."));
    }

    @GetMapping("/default")
    public ResponseEntity<ApiResponse<AddressResponse>> getDefaultAddress(
            @RequestHeader("X-AUTH-USER-ID") Long userId) {
        log.info("Fetching default address for user with id: {}", userId);
        AddressResponse address = addressService.getDefaultAddress(userId);
        return ResponseEntity.ok(ApiResponse.success(address, "기본 주소 조회에 성공하였습니다."));
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/api/controller/AuthController.java
--------
package com.zzimcong.user.api.controller;

import com.zzimcong.user.api.response.ApiResponse;
import com.zzimcong.user.application.dto.*;
import com.zzimcong.user.application.service.AuthService;
import com.zzimcong.user.application.service.EmailVerificationService;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j(topic = "AUTH_CONTROLLER")
@RestController
@RequestMapping("/api/v1/auth")
public class AuthController {
    private final AuthService authService;
    private final EmailVerificationService emailVerificationService;

    @Autowired
    public AuthController(AuthService authService, EmailVerificationService emailVerificationService) {
        this.authService = authService;
        this.emailVerificationService = emailVerificationService;
    }

    @GetMapping("/info")
    public String getUserInfo(HttpServletRequest request) {
        return "User Info";
    }

    // 이메일 중복 확인
    @PostMapping("/check-email")
    public ResponseEntity<?> checkEmailAvailability(@RequestBody EmailRequest emailRequest) {
        boolean isAvailable = emailVerificationService.isEmailAvailable(emailRequest.email());
        String message = isAvailable ? "사용 가능한 이메일입니다." : "이미 사용 중인 이메일입니다.";
        return ResponseEntity.ok(ApiResponse.success(isAvailable, message));
    }

    @PostMapping("/signup")
    public ResponseEntity<?> signUp(@RequestBody @Valid SignupRequest signupRequest,
                                    @RequestParam String token) {
        authService.signUp(signupRequest, token);
        return ResponseEntity.ok(ApiResponse.success(null, "회원가입이 완료되었습니다."));
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest loginRequest, HttpServletRequest request) {
        AuthResponse authResponse = authService.login(loginRequest);
        return ResponseEntity.ok(ApiResponse.success(authResponse, "로그인에 성공했습니다."));
    }

    @PostMapping("/logout")
    public ResponseEntity<?> logout() {
        authService.logout();
        return ResponseEntity.ok(ApiResponse.success(null, "로그아웃되었습니다."));
    }

    // refreshToken을 이용한 accessToken 재발급
    @PostMapping("/refresh")
    public ResponseEntity<?> refreshToken(@RequestBody RefreshRequest refreshRequest) {
        String refreshToken = refreshRequest.refreshToken();
        AuthResponse authResponse = authService.refreshToken(refreshToken);
        return ResponseEntity.ok(ApiResponse.success(authResponse, "토큰이 갱신되었습니다."));
    }

    private String extractRefreshTokenFromCookie(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("refreshToken".equals(cookie.getName())) {
                    return cookie.getValue();
                }
            }
        }
        return null;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/api/controller/UserController.java
--------
package com.zzimcong.user.api.controller;

import com.zzimcong.user.application.dto.UserModifyRequest;
import com.zzimcong.user.application.dto.UserResponse;
import com.zzimcong.user.application.service.UserService;
import com.zzimcong.user.common.util.SecurityUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j(topic = "USER_CONTROLLER")
@RestController
@RequestMapping("/api/v1/users")
public class UserController {
    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }

    //회원정보 조회
    @GetMapping
    public ResponseEntity<UserResponse> getUserByEmail() {
        UserResponse user = userService.getUserById(SecurityUtil.getCurrentUserId());
        return ResponseEntity.ok(user);
    }

    //회원정보 수정
    @PutMapping
    public ResponseEntity<UserResponse> updateUser(@RequestBody UserModifyRequest userModifyRequest) {
        UserResponse updatedUser = userService.updateUser(SecurityUtil.getCurrentUserId(), userModifyRequest);
        return ResponseEntity.ok(updatedUser);
    }

    //회원탈퇴
    @DeleteMapping("/signout")
    public ResponseEntity<Void> signoutUser() {
        userService.signoutUser(SecurityUtil.getCurrentUserId());
        return ResponseEntity.ok().build();
    }
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/AddressCreateRequest.java
--------
package com.zzimcong.user.application.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public record AddressCreateRequest(
        @NotBlank(message = "이름은 필수입니다.")
        @Size(max = 64, message = "이름은 64자를 초과할 수 없습니다.")
        String name,

        @NotBlank(message = "주소는 필수입니다.")
        @Size(max = 255, message = "주소는 255자를 초과할 수 없습니다.")
        String streetAddress,

        @NotBlank(message = "상세 주소는 필수입니다.")
        @Size(max = 255, message = "상세 주소는 255자를 초과할 수 없습니다.")
        String addressDetail,

        @NotBlank(message = "우편번호는 필수입니다.")
        @Pattern(regexp = "\\d{5}", message = "우편번호는 5자리 숫자여야 합니다.")
        String zipcode,

        @NotBlank(message = "전화번호는 필수입니다.")
        @Size(max = 20, message = "전화번호는 20자를 초과할 수 없습니다.")
        String phone,

        @Size(max = 255, message = "메시지는 255자를 초과할 수 없습니다.")
        String message,

        boolean isDefault
) {
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/UserResponse.java
--------
package com.zzimcong.user.application.dto;

public record UserResponse(
        Long id,
        String email,
        String username,
        String phone
) {
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/UserModifyRequest.java
--------
package com.zzimcong.user.application.dto;

public record UserModifyRequest(
        String name,
        String phone,
        String password
) {
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/LogoutRequest.java
--------
package com.zzimcong.user.application.dto;

public record LogoutRequest(
        String accessToken) {
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/RefreshRequest.java
--------
package com.zzimcong.user.application.dto;

public record RefreshRequest(
        String refreshToken
) {
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/AddressUpdateRequest.java
--------
package com.zzimcong.user.application.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public record AddressUpdateRequest(
        @NotBlank(message = "이름은 필수입니다.")
        @Size(max = 64, message = "이름은 64자를 초과할 수 없습니다.")
        String name,

        @NotBlank(message = "주소는 필수입니다.")
        @Size(max = 255, message = "주소는 255자를 초과할 수 없습니다.")
        String streetAddress,

        @NotBlank(message = "상세 주소는 필수입니다.")
        @Size(max = 255, message = "상세 주소는 255자를 초과할 수 없습니다.")
        String addressDetail,

        @NotBlank(message = "우편번호는 필수입니다.")
        @Pattern(regexp = "\\d{5}", message = "우편번호는 5자리 숫자여야 합니다.")
        String zipcode,

        @NotBlank(message = "전화번호는 필수입니다.")
        @Size(max = 20, message = "전화번호는 20자를 초과할 수 없습니다.")
        String phone,

        @Size(max = 255, message = "메시지는 255자를 초과할 수 없습니다.")
        String message,

        boolean isDefault
) {
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/SignupRequest.java
--------
package com.zzimcong.user.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record SignupRequest(
        @NotBlank(message = "이메일은 필수 입력 값입니다.")
        @Email(message = "이메일 형식이 아닙니다.")
        String email,

        @NotBlank(message = "이름은 필수 입력 값입니다.")
        String name,

        @NotBlank(message = "전화번호는 필수 입력 값입니다.")
        String phone,

        @NotBlank(message = "비밀번호는 필수 입력 값입니다.")
        String password
) {
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/EmailRequest.java
--------
package com.zzimcong.user.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;

public record EmailRequest(
        @Email(message = "이메일 형식이 올바르지 않습니다.")
        @NotEmpty(message = "이메일을 입력해 주세요")
        String email
) {
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/AuthResponse.java
--------
package com.zzimcong.user.application.dto;

public record AuthResponse(
        String accessToken,
        String refreshToken
) {
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/LoginRequest.java
--------
package com.zzimcong.user.application.dto;

public record LoginRequest(
        String email,
        String password
) {
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/AddressResponse.java
--------
package com.zzimcong.user.application.dto;

public record AddressResponse(
        Long id,
        String name,
        String streetAddress,
        String addressDetail,
        String zipcode,
        String phone,
        String message,
        boolean isDefault
) {
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/dto/EmailCheckResponse.java
--------
package com.zzimcong.user.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;

public record EmailCheckResponse(
        @Email
        @NotEmpty(message = "이메일을 입력해 주세요")
        String email,

        @NotEmpty(message = "인증 번호를 입력해 주세요")
        String authNum
) {
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/CookieService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.infrastructure.config.RefreshTokenCookieProperties;
import jakarta.servlet.http.Cookie;
import org.springframework.stereotype.Service;

@Service
public class CookieService {

    private final RefreshTokenCookieProperties refreshTokenCookieProperties;

    public CookieService(RefreshTokenCookieProperties refreshTokenCookieProperties) {
        this.refreshTokenCookieProperties = refreshTokenCookieProperties;
    }

    public Cookie createRefreshTokenCookie(String refreshToken) {
        Cookie cookie = new Cookie(refreshTokenCookieProperties.getName(), refreshToken);
        cookie.setHttpOnly(refreshTokenCookieProperties.isHttpOnly());
        cookie.setSecure(refreshTokenCookieProperties.isSecure());
        cookie.setPath(refreshTokenCookieProperties.getPath());
        cookie.setMaxAge(refreshTokenCookieProperties.getMaxAge());
        return cookie;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/UserService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.application.dto.SignupRequest;
import com.zzimcong.user.application.dto.UserModifyRequest;
import com.zzimcong.user.application.dto.UserResponse;
import com.zzimcong.user.common.exception.ConflictException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.NotFoundException;
import com.zzimcong.user.common.util.AESUtil;
import com.zzimcong.user.domain.entity.User;
import com.zzimcong.user.domain.mapper.UserMapper;
import com.zzimcong.user.domain.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j(topic = "USER_SERVICE")
@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final UserMapper userMapper;
    private final AESUtil aesUtil;

    public boolean isEmailAvailable(String email) {
        return !userRepository.existsByEmail(aesUtil.encrypt(email));
    }

    @Transactional
    public UserResponse createUser(SignupRequest signupRequest) {
        String encryptedEmail = aesUtil.encrypt(signupRequest.email());
        if (userRepository.existsByEmail(encryptedEmail)) {
            throw new ConflictException(ErrorCode.DUPLICATE_EMAIL);
        }
        User user = userMapper.toEntity(signupRequest);
        User savedUser = userRepository.save(user);
        return userMapper.toDto(savedUser);
    }

    public UserResponse getUserByEmail(String email) {
        return userRepository.findByEmail(aesUtil.encrypt(email))
                .map(userMapper::toDto)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
    }

    public UserResponse getUserById(Long id) {
        return userRepository.findById(id)
                .map(userMapper::toDto)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
    }

    @Transactional
    public UserResponse updateUser(Long id, UserModifyRequest userModifyRequest) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        userMapper.updateFromDto(userModifyRequest, user);
        User updatedUser = userRepository.save(user);
        return userMapper.toDto(updatedUser);
    }

    @Transactional
    public void signoutUser(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        user.signOut();
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/AuthService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.application.dto.AuthResponse;
import com.zzimcong.user.application.dto.LoginRequest;
import com.zzimcong.user.application.dto.SignupRequest;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.UnauthorizedException;
import com.zzimcong.user.common.util.SecurityUtil;
import com.zzimcong.user.infrastructure.security.jwt.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

@Slf4j(topic = "AUTH_SERVICE")
@Service
public class AuthService {
    private final TokenService tokenService;
    private final UserService userService;
    private final EmailVerificationService emailVerificationService;
    private final JwtUtil jwtUtil;
    private final AuthenticationManager authenticationManager;

    public AuthService(TokenService tokenService,
                       UserService userService,
                       EmailVerificationService emailVerificationService,
                       JwtUtil jwtUtil,
                       AuthenticationManager authenticationManager) {
        this.tokenService = tokenService;
        this.userService = userService;
        this.emailVerificationService = emailVerificationService;
        this.jwtUtil = jwtUtil;
        this.authenticationManager = authenticationManager;
    }

    public void signUp(SignupRequest signupRequest, String token) {
        emailVerificationService.validateTokenForRegistration(signupRequest.email(), token);
        userService.createUser(signupRequest);
    }

    public AuthResponse login(LoginRequest requestDto) {
        try {
            Authentication authentication = authenticateUser(requestDto);
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            Long id = Long.parseLong(userDetails.getUsername());
            return generateAuthResultDto(id);
        } catch (AuthenticationException e) {
            throw new UnauthorizedException(ErrorCode.INVALID_CREDENTIALS, "잘못된 이메일 또는 비밀번호입니다.");
        }
    }

    public void logout() {
        Long id = SecurityUtil.getCurrentUserId();
        try {
            tokenService.deleteRefreshToken(String.valueOf(id));
        } catch (ExpiredJwtException e) {
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }
        log.info("User {} logged out successfully", id);
    }

    public AuthResponse refreshToken(String refreshToken) {
        if (refreshToken == null) {
            throw new UnauthorizedException(ErrorCode.TOKEN_NOT_FOUND);
        }
        try {
            if (!jwtUtil.validateToken(refreshToken)) {
                throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
            }
            Long id = jwtUtil.extractId(refreshToken);
            return generateAuthResultDto(id);
        } catch (ExpiredJwtException e) {
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }
    }

    private Authentication authenticateUser(LoginRequest requestDto) {
        return authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(requestDto.email(), requestDto.password())
        );
    }

    private AuthResponse generateAuthResultDto(Long id) {
        String accessToken = jwtUtil.generateAccessToken(id);
        String refreshToken = jwtUtil.generateRefreshToken(id);
        tokenService.storeRefreshToken(String.valueOf(id), refreshToken);
        return new AuthResponse(accessToken, refreshToken);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/EmailVerificationService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.common.exception.ConflictException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.UnauthorizedException;
import com.zzimcong.user.common.util.EmailVerificationToken;
import com.zzimcong.user.common.util.RedisUtil;
import com.zzimcong.user.infrastructure.config.EmailProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j(topic = "EMAIL_VERIFICATION_SERVICE")
@Service
public class EmailVerificationService {
    private final Set<EmailVerificationToken> emailVerificationTokens =
            Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final EmailProperties emailProperties;
    private final EmailService emailService;
    private final UserService userService;
    private final RedisUtil redisUtil;

    public EmailVerificationService(EmailProperties emailProperties, EmailService emailService, UserService userService, RedisUtil redisUtil) {
        this.emailProperties = emailProperties;
        this.emailService = emailService;
        this.userService = userService;
        this.redisUtil = redisUtil;
    }

    public void sendVerificationEmail(String email) {
        if (!isEmailAvailable(email)) {
            log.warn("사용할 수 없는 이메일입니다: {}", email);
            throw new ConflictException(ErrorCode.DUPLICATE_EMAIL);
        }
        String verificationCode = emailService.generateVerificationCode();
        emailService.sendVerificationEmail(email, verificationCode);
        storeVerificationCode(verificationCode, email);
        log.info("인증 이메일 전송: {}", email);
    }

    public boolean isEmailAvailable(String email) {
        return userService.isEmailAvailable(email);
    }

    private void storeVerificationCode(String code, String email) {
        redisUtil.setDataExpire(code, email,
                emailProperties.getVerification().getCode().getExpiry().getSeconds());
    }

    public String verifyEmailAndGenerateToken(String email, String verificationCode) {
        if (!verifyEmailCode(email, verificationCode)) {
            throw new UnauthorizedException(ErrorCode.INVALID_VERIFICATION_CODE);
        }
        String token = UUID.randomUUID().toString();
        EmailVerificationToken verificationToken =
                new EmailVerificationToken(token, email, LocalDateTime.now().plusMinutes(
                        emailProperties.getVerification().getToken().getExpiry().getMinutes()));
        emailVerificationTokens.add(verificationToken);
        log.info("이메일 인증 성공 및 토큰 생성: {}", email);
        return token;
    }

    private boolean verifyEmailCode(String email, String code) {
        String storedEmail = redisUtil.getData(code);
        return storedEmail != null && storedEmail.equals(email);
    }

    public void validateTokenForRegistration(String email, String token) {
        EmailVerificationToken verificationToken = emailVerificationTokens.stream()
                .filter(t -> t.getToken().trim().equalsIgnoreCase(token.trim())
                        && t.getEmail().trim().equalsIgnoreCase(email.trim()))
                .findFirst()
                .orElseThrow(() -> new UnauthorizedException(ErrorCode.INVALID_TOKEN));

        if (LocalDateTime.now().isAfter(verificationToken.getExpiryDate())) {
            emailVerificationTokens.remove(verificationToken);
            throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
        }

        emailVerificationTokens.remove(verificationToken);
    }

    @Scheduled(fixedRate = 60000) // 1분마다 실행
    public void cleanupExpiredTokens() {
        emailVerificationTokens.removeIf(token -> LocalDateTime.now().isAfter(token.getExpiryDate()));
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/AddressService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.application.dto.AddressCreateRequest;
import com.zzimcong.user.application.dto.AddressResponse;
import com.zzimcong.user.application.dto.AddressUpdateRequest;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.common.exception.NotFoundException;
import com.zzimcong.user.domain.entity.Address;
import com.zzimcong.user.domain.mapper.AddressMapper;
import com.zzimcong.user.domain.repository.AddressRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class AddressService {
    private final AddressMapper addressMapper;
    private final AddressRepository addressRepository;

    public AddressService(AddressMapper addressMapper, AddressRepository addressRepository) {
        this.addressMapper = addressMapper;
        this.addressRepository = addressRepository;
    }

    public AddressResponse createAddress(Long userId, AddressCreateRequest request) {
        Address address = addressMapper.toEntity(request);
        address.setUserId(userId);
        Address savedAddress = addressRepository.save(address);
        return addressMapper.toDto(savedAddress);
    }

    public AddressResponse getAddress(Long userId, Long id) {
        Address address = addressRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.ADDRESS_NOT_FOUND));
        if (!address.getUserId().equals(userId)) {
            throw new NotFoundException(ErrorCode.ADDRESS_NOT_FOUND);
        }
        return addressMapper.toDto(address);
    }

    public List<AddressResponse> getUserAddresses(Long userId) {
        List<Address> addresses = addressRepository.findAllByUserId(userId);
        return addressMapper.toDtoList(addresses);
    }

    public AddressResponse updateAddress(Long userId, Long id, AddressUpdateRequest request) {
        Address address = addressRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("주소를 찾을 수 없습니다."));
        if (!address.getUserId().equals(userId)) {
            throw new IllegalArgumentException("해당 주소에 접근할 수 없습니다.");
        }
        addressMapper.updateEntityFromDto(request, address);
        Address savedAddress = addressRepository.save(address);
        return addressMapper.toDto(savedAddress);
    }

    public void deleteAddress(Long userId, Long id) {
        Address address = addressRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("주소를 찾을 수 없습니다."));
        if (!address.getUserId().equals(userId)) {
            throw new IllegalArgumentException("해당 주소에 접근할 수 없습니다.");
        }
        addressRepository.delete(address);
    }

    @Transactional
    public AddressResponse setDefaultAddress(Long userId, Long addressId) {
        Address address = addressRepository.findById(addressId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.ADDRESS_NOT_FOUND));

        addressRepository.resetDefaultForUser(userId);

        address.setIsDefault(true);
        Address savedAddress = addressRepository.save(address);

        return addressMapper.toDto(savedAddress);
    }

    public AddressResponse getDefaultAddress(Long userId) {
        Address address = addressRepository.findAllByUserIdAndIsDefaultTrue(userId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.ADDRESS_NOT_FOUND));

        return addressMapper.toDto(address);
    }
}


--------


File: ./user/src/main/java/com/zzimcong/user/application/service/EmailService.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.common.exception.InternalServerErrorException;
import com.zzimcong.user.infrastructure.config.EmailProperties;
import com.zzimcong.user.common.exception.ErrorCode;
import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import org.springframework.util.StreamUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Random;

@Slf4j(topic = "EMAIL_SERVICE")
@Service
@RequiredArgsConstructor
public class EmailService {
    private final EmailProperties emailProperties;
    private final JavaMailSender mailSender;
    private final ResourceLoader resourceLoader;

    public String generateVerificationCode() {
        Random random = new Random();
        return String.format("%0" + emailProperties.getVerification().getCode().getLength() + "d",
                random.nextInt((int) Math.pow(10, emailProperties.getVerification().getCode().getLength())));
    }

    private String prepareEmailContent(String verificationCode) {
        try {
            String template = loadEmailTemplate();
            return template.replace("${verificationCode}", verificationCode);
        } catch (IOException e) {
            log.error("Failed to load email template", e);
            throw new InternalServerErrorException(ErrorCode.RESOURCE_LOAD_FAILED,
                    "이메일 템플릿 로딩에 실패했습니다.");
        }
    }

    private String loadEmailTemplate() throws IOException {
        Resource resource = resourceLoader.getResource(emailProperties.getTemplate().getPath());
        return StreamUtils.copyToString(resource.getInputStream(), StandardCharsets.UTF_8);
    }

    public void sendVerificationEmail(String toEmail, String verificationCode) {
        try {
            String content = prepareEmailContent(verificationCode);
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8");

            helper.setFrom(emailProperties.getSender());
            helper.setTo(toEmail);
            helper.setSubject(emailProperties.getSubject());
            helper.setText(content, true);

            mailSender.send(message);
            log.info("인증 메일이 성공적으로 전송되었습니다: {}", toEmail);
        } catch (MessagingException e) {
            log.error("인증 메일 전송에 실패했습니다: {}", toEmail, e);
            throw new InternalServerErrorException(ErrorCode.EMAIL_SEND_FAILED,
                    "인증 메일 전송에 실패했습니다.");
        }
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/TokenService.java
--------
package com.zzimcong.user.application.service;

import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
public class TokenService {
    private final RedisTemplate<String, String> redisTemplate;

    public TokenService(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public void storeRefreshToken(String username, String refreshToken) {
        redisTemplate.opsForValue().set(username, refreshToken);
        redisTemplate.expire(username, 7, TimeUnit.DAYS);
    }

    public void deleteRefreshToken(String username) {
        redisTemplate.delete(username);
    }

    public String getRefreshToken(String username) {
        return redisTemplate.opsForValue().get(username);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/application/service/UserDetailsServiceImpl.java
--------
package com.zzimcong.user.application.service;

import com.zzimcong.user.common.util.AESUtil;
import com.zzimcong.user.domain.entity.User;
import com.zzimcong.user.common.exception.NotFoundException;
import com.zzimcong.user.common.exception.ErrorCode;
import com.zzimcong.user.domain.repository.UserRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;
    private final AESUtil aesUtil;

    public UserDetailsServiceImpl(UserRepository userRepository, AESUtil aesUtil) {
        this.userRepository = userRepository;
        this.aesUtil = aesUtil;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(aesUtil.encrypt(email))
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));
        return org.springframework.security.core.userdetails.User
                .withUsername(String.valueOf(user.getId()))
                .password(user.getPassword())
                .roles("USER")
                .build();
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/JacksonConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import java.io.IOException;

@Slf4j(topic = "jackson-config")
@Configuration
public class JacksonConfig {
    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.addHandler(new DeserializationProblemHandler() {
            @Override
            public boolean handleUnknownProperty(DeserializationContext ctxt, JsonParser p,
                                                 JsonDeserializer<?> deserializer,
                                                 Object beanOrClass, String propertyName) throws IOException {
                log.warn("알 수 없는 속성이 요청에 포함되어 있습니다. 클래스: {}, 속성명: {}",
                        beanOrClass.getClass().getSimpleName(), propertyName);
                p.skipChildren();
                return true;
            }
        });
        return objectMapper;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/EmailConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;

import java.util.Properties;

@Configuration
public class EmailConfig {

    private final EmailProperties emailProperties;

    public EmailConfig(EmailProperties emailProperties) {
        this.emailProperties = emailProperties;
    }

    @Bean
    public JavaMailSender mailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(emailProperties.getHost());
        mailSender.setPort(emailProperties.getPort());
        mailSender.setUsername(emailProperties.getUsername());
        mailSender.setPassword(emailProperties.getPassword());

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", String.valueOf(emailProperties.getProperties().getMail().getSmtp().isAuth()));
        props.put("mail.smtp.starttls.enable", String.valueOf(
                emailProperties.getProperties().getMail().getSmtp().getStarttls().isEnable()));

        // 개발 환경에서만 디버그 모드 활성화
        if (System.getProperty("spring.profiles.active", "").contains("local")) {
            props.put("mail.debug", "true");
        }

        return mailSender;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/RefreshTokenCookieProperties.java
--------
package com.zzimcong.user.infrastructure.config;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;

@Component
@ConfigurationProperties(prefix = "auth.cookie.refresh-token")
@Validated
@Getter
@Setter
public class RefreshTokenCookieProperties {
    @NotBlank
    private String name;

    @Min(0)
    private int maxAge;

    private boolean httpOnly;
    private boolean secure;

    @NotBlank
    private String path;
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/RedisConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

@Configuration
@EnableCaching
public class RedisConfig {
    @Bean
    public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, String> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new StringRedisSerializer());
        return template;
    }

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(cacheConfig)
                .build();
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/WebConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import com.zzimcong.user.infrastructure.config.interceptor.TokenInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    private final TokenInterceptor tokenInterceptor;

    public WebConfig(TokenInterceptor tokenInterceptor) {
        this.tokenInterceptor = tokenInterceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(tokenInterceptor).addPathPatterns("/api/**");
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/SwaggerConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("찜콩 API")
                        .version("1.0")
                        .description("선착순 구매 기능이 있는 이커머스 서비스 API 문서"));
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/EmailProperties.java
--------
package com.zzimcong.user.infrastructure.config;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

@ConfigurationProperties(prefix = "email")
@Validated
@Data
public class EmailProperties {
    @NotBlank
    private String host;

    @Min(1)
    @Max(65535)
    private int port;

    @NotBlank
    private String username;

    @NotBlank
    private String password;

    private Properties properties = new Properties();

    @Data
    public static class Properties {
        private Mail mail = new Mail();

        @Data
        public static class Mail {
            private Smtp smtp = new Smtp();

            @Data
            public static class Smtp {
                private boolean auth;
                private Starttls starttls = new Starttls();

                @Data
                public static class Starttls {
                    private boolean enable;
                }
            }
        }
    }

    @NotBlank
    private String sender;

    @NotBlank
    private String subject;

    private Template template = new Template();
    private Verification verification = new Verification();

    @Data
    public static class Template {
        @NotBlank
        private String path;
    }

    @Data
    public static class Verification {
        private Code code = new Code();
        private Token token = new Token();

        @Data
        public static class Code {
            @Min(4)
            @Max(10)
            private int length = 6;

            private Expiry expiry = new Expiry();

            @Data
            public static class Expiry {
                @Min(60)
                @Max(600)
                private long seconds = 300;
            }
        }

        @Data
        public static class Token {
            private Expiry expiry = new Expiry();

            @Data
            public static class Expiry {
                @Min(5)
                @Max(60)
                private long minutes = 30;
            }
        }
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/JpaConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
@EnableJpaAuditing
public class JpaConfig {
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/interceptor/TokenInterceptor.java
--------
package com.zzimcong.user.infrastructure.config.interceptor;

import com.zzimcong.user.application.service.CookieService;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

@Component
public class TokenInterceptor implements HandlerInterceptor {

    private final CookieService cookieService;

    public TokenInterceptor(CookieService cookieService) {
        this.cookieService = cookieService;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {
        String refreshToken = (String) request.getAttribute("refreshToken");
        if (refreshToken != null) {
            Cookie refreshTokenCookie = cookieService.createRefreshTokenCookie(refreshToken);
            response.addCookie(refreshTokenCookie);
        }
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/config/CorsConfig.java
--------
package com.zzimcong.user.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("http://localhost:3000"); // React 앱의 주소
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        source.registerCorsConfiguration("/api/**", config);
        return new CorsFilter(source);
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/security/jwt/JwtUtil.java
--------
package com.zzimcong.user.infrastructure.security.jwt;

import com.zzimcong.user.common.exception.BadRequestException;
import com.zzimcong.user.common.exception.ErrorCode;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;
import java.util.function.Function;

@Slf4j(topic = "JWT_UTIL")
@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.access-token.expiration}")
    private long accessTokenExpiration;

    @Value("${jwt.refresh-token.expiration}")
    private long refreshTokenExpiration;

    private Key getSigningKey() {
        byte[] keyBytes = secret.getBytes();
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateAccessToken(Long id) {
        return generateToken(id, accessTokenExpiration);
    }


    public String generateRefreshToken(Long id) {
        return generateToken(id, refreshTokenExpiration);
    }

    private String generateToken(Long id, long expiration) {
        Date now = new Date(System.currentTimeMillis());
        Date expiryDate = new Date(now.getTime() + expiration * 1000);
        log.info("Generating token for subject: {}, expiration: {}", id, expiryDate);
        return Jwts.builder()
                .setSubject(String.valueOf(id))
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(expiryDate)
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public Long extractId(String token) {
        return Long.parseLong(extractClaim(token, Claims::getSubject));
    }

    public Boolean validateToken(String token, Long id) {
        final Long tokenId = extractId(token);
        return (tokenId.equals(id) && !isTokenExpired(token));
    }

    public Boolean validateToken(String token) {
        try {
            // 1. 토큰 파싱 및 서명 검증
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token);

            // 2. 추가적인 검증 (예: 만료 시간)
            Claims claims = extractAllClaims(token);
            return !isTokenExpired(claims);
        } catch (JwtException | IllegalArgumentException e) {
            log.error("Invalid JWT token", e);
            // 3. 예외 처리
            return false;
        }
    }

    private boolean isTokenExpired(Claims claims) {
        return claims.getExpiration().before(new Date());
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        try {
            return Jwts.parserBuilder().setSigningKey(getSigningKey()).build().parseClaimsJws(token).getBody();
        } catch (Exception ex) {
            log.error("Invalid JWT token", ex);
            throw new BadRequestException(ErrorCode.INVALID_TOKEN);
        }
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String extractJwtFromRequest(HttpServletRequest request) {
        String authorizationHeader = request.getHeader("Authorization");
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            return authorizationHeader.substring(7);
        }
        return null;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/security/jwt/JwtRequestFilter.java
--------
package com.zzimcong.user.infrastructure.security.jwt;

import com.zzimcong.user.api.response.ErrorResponse;
import com.zzimcong.user.common.exception.*;
import com.zzimcong.user.domain.entity.User;
import com.zzimcong.user.domain.repository.UserRepository;
import com.zzimcong.user.infrastructure.security.UserDetailsImpl;
import io.jsonwebtoken.ExpiredJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Slf4j(topic = "JWT_REQUEST_FILTER")
@Component
public class JwtRequestFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final UserRepository userRepository;

    public JwtRequestFilter(JwtUtil jwtUtil, UserRepository userRepository) {
        this.jwtUtil = jwtUtil;
        this.userRepository = userRepository;
    }
    
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/api/v1/auth/") || path.startsWith("/api/v1/email-verifications/");
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        try {
            Long id = null;
            String jwt = jwtUtil.extractJwtFromRequest(request);
            try {
                id = jwtUtil.extractId(jwt);
            } catch (ExpiredJwtException e) {
                log.warn("JWT 토큰이 만료되었습니다", e);
                throw new UnauthorizedException(ErrorCode.EXPIRED_TOKEN);
            } catch (Exception e) {
                log.error("JWT 토큰에서 id를 추출하는 중 오류가 발생했습니다", e);
                throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
            }

            if (id != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                User user = userRepository.findById(id)
                        .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

                if (jwtUtil.validateToken(jwt, user.getId())) {
                    UserDetailsImpl userDetails = new UserDetailsImpl(user);

                    UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                            userDetails, null, userDetails.getAuthorities());
                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                    SecurityContextHolder.getContext().setAuthentication(authToken);
                } else {
                    log.warn("JWT 토큰 검증에 실패했습니다");
                    throw new UnauthorizedException(ErrorCode.INVALID_TOKEN);
                }
            }

            chain.doFilter(request, response);
        } catch (Exception e) {
            log.error("JWT 토큰 검증 중 오류가 발생했습니다", e);
            ErrorResponse errorResponse = createErrorResponse(e, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
            response.getWriter().write(errorResponse.toString());
        }
    }

    // Create ErrorResponse
    private ErrorResponse createErrorResponse(Exception ex, HttpStatus status, String path) {
        logException(ex, status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.INTERNAL_SERVER_ERROR);
        return ErrorResponse.of(baseException, status, path);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        log.error(
                "\n\nException occurred:: Error Code: {}, HTTP Status: {}, Message: {}, Path: {}\n",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage(),
                path,
                ex
        );
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/security/SecurityConfig.java
--------
package com.zzimcong.user.infrastructure.security;

import com.zzimcong.user.infrastructure.security.jwt.JwtRequestFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JwtRequestFilter jwtRequestFilter;

    public SecurityConfig(JwtRequestFilter jwtRequestFilter) {
        this.jwtRequestFilter = jwtRequestFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().permitAll()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/infrastructure/security/UserDetailsImpl.java
--------
package com.zzimcong.user.infrastructure.security;

import com.zzimcong.user.domain.entity.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;

public class UserDetailsImpl implements UserDetails {
    private final User user;

    public UserDetailsImpl(User user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name()));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return String.valueOf(user.getId());
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/domain/repository/AddressRepository.java
--------
package com.zzimcong.user.domain.repository;

import com.zzimcong.user.domain.entity.Address;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface AddressRepository extends JpaRepository<Address, Long> {
    List<Address> findAllByUserId(Long userId);

    Optional<Address> findAllByUserIdAndIsDefaultTrue(Long userId);

    @Modifying
    @Query("UPDATE Address a SET a.isDefault = false WHERE a.userId = :userId")
    void resetDefaultForUser(Long userId);

    Optional<Address> findByIdAndUserId(Long id, Long userId);

    void deleteByIdAndUserId(Long id, Long userId);

    void deleteAllByUserId(Long userId);
}


--------


File: ./user/src/main/java/com/zzimcong/user/domain/repository/UserRepository.java
--------
package com.zzimcong.user.domain.repository;

import com.zzimcong.user.domain.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Boolean existsByEmail(String email);

    Optional<User> findByEmail(String email);
}


--------


File: ./user/src/main/java/com/zzimcong/user/domain/entity/UserRole.java
--------
package com.zzimcong.user.domain.entity;

public enum UserRole {
    USER, ADMIN, SELLER
}

--------


File: ./user/src/main/java/com/zzimcong/user/domain/entity/BaseEntity.java
--------
package com.zzimcong.user.domain.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@Setter
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
public abstract class BaseEntity {

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

}

--------


File: ./user/src/main/java/com/zzimcong/user/domain/entity/User.java
--------
package com.zzimcong.user.domain.entity;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "users")
@Getter
@Setter
@Builder
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long id;

    @Column(nullable = false, unique = true, length = 64)
    private String email;

    @Column(nullable = false, length = 64)
    private String name;

    @Column(nullable = false, length = 255)
    private String password;

    @Column(nullable = false, length = 64)
    private String phone;

    @Column(nullable = false)
    @Builder.Default
    private Boolean abuser = false;

    @Column(nullable = false)
    @Builder.Default
    private Boolean signout = false;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @Builder.Default
    private UserRole role = UserRole.USER;

    public void signOut() {
        this.signout = true;
    }

    // role을 변경하는 메서드
    public void changeRole(UserRole newRole) {
        this.role = newRole != null ? newRole : UserRole.USER;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/domain/entity/Address.java
--------
package com.zzimcong.user.domain.entity;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "address")
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Address extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "address_id")
    private Long id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(name = "name", nullable = false, length = 64)
    private String name;

    @Column(name = "street_address", nullable = false)
    private String streetAddress;

    @Column(name = "address_detail", nullable = false)
    private String addressDetail;

    @Column(name = "zipcode", nullable = false, length = 10)
    private String zipcode;

    @Column(name = "phone", nullable = false, length = 20)
    private String phone;

    @Column(name = "message")
    private String message;

    @Column(name = "is_default")
    private Boolean isDefault = false;
}

--------


File: ./user/src/main/java/com/zzimcong/user/domain/entity/UserFactory.java
--------
package com.zzimcong.user.domain.entity;

import com.zzimcong.user.application.dto.SignupRequest;
import com.zzimcong.user.common.util.AESUtil;
import com.zzimcong.user.domain.mapper.UserMapper;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

// UserFactory.java
@Component
public class UserFactory {
    private final UserMapper userMapper;
    private final AESUtil aesUtil;
    private final PasswordEncoder passwordEncoder;

    public UserFactory(UserMapper userMapper, AESUtil aesUtil, PasswordEncoder passwordEncoder) {
        this.userMapper = userMapper;
        this.aesUtil = aesUtil;
        this.passwordEncoder = passwordEncoder;
    }

    public User createUser(SignupRequest dto) {
        return userMapper.toEntity(dto);
    }

    public User createAdminUser(SignupRequest dto) {
        User user = userMapper.toEntity(dto);
        user.changeRole(UserRole.ADMIN);
        return user;
    }

    public User createSellerUser(SignupRequest dto) {
        User user = userMapper.toEntity(dto);
        user.changeRole(UserRole.SELLER);
        return user;
    }
}

--------


File: ./user/src/main/java/com/zzimcong/user/domain/mapper/UserMapper.java
--------
package com.zzimcong.user.domain.mapper;

import com.zzimcong.user.application.dto.SignupRequest;
import com.zzimcong.user.application.dto.UserModifyRequest;
import com.zzimcong.user.application.dto.UserResponse;
import com.zzimcong.user.common.util.AESUtil;
import com.zzimcong.user.domain.entity.User;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;

@Mapper(componentModel = "spring")
public abstract class UserMapper {

    @Autowired
    protected AESUtil aesUtil;
    @Autowired
    protected PasswordEncoder passwordEncoder;

    @Mapping(target = "name", expression = "java(aesUtil.encrypt(dto.name()))")
    @Mapping(target = "email", expression = "java(aesUtil.encrypt(dto.email()))")
    @Mapping(target = "phone", expression = "java(aesUtil.encrypt(dto.phone()))")
    @Mapping(target = "password", expression = "java(passwordEncoder.encode(dto.password()))")
    public abstract User toEntity(SignupRequest dto);

    @Mapping(target = "email", expression = "java(aesUtil.decrypt(user.getEmail()))")
    @Mapping(target = "username", expression = "java(aesUtil.decrypt(user.getName()))")
    @Mapping(target = "phone", expression = "java(aesUtil.decrypt(user.getPhone()))")
    public abstract UserResponse toDto(User user);

    @Mapping(target = "name", expression = "java(aesUtil.encrypt(dto.name()))")
    @Mapping(target = "phone", expression = "java(aesUtil.encrypt(dto.phone()))")
    @Mapping(target = "password", expression = "java(passwordEncoder.encode(dto.password()))")
    public abstract User updateFromDto(UserModifyRequest dto, @MappingTarget User user);
}

--------


File: ./user/src/main/java/com/zzimcong/user/domain/mapper/AddressMapper.java
--------
package com.zzimcong.user.domain.mapper;

import com.zzimcong.user.application.dto.AddressCreateRequest;
import com.zzimcong.user.application.dto.AddressResponse;
import com.zzimcong.user.application.dto.AddressUpdateRequest;
import com.zzimcong.user.domain.entity.Address;
import org.mapstruct.*;

import java.util.List;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface AddressMapper {

    @Mapping(target = "id", ignore = true)
    Address toEntity(AddressCreateRequest request);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "userId", ignore = true)
    void updateEntityFromDto(AddressUpdateRequest request, @MappingTarget Address address);

    AddressResponse toDto(Address address);

    List<AddressResponse> toDtoList(List<Address> addresses);

    @AfterMapping
    default void setDefaults(@MappingTarget Address address) {
        if (address.getIsDefault() == null) {
            address.setIsDefault(false);
        }
    }
}

--------


File: ./product/src/test/java/com/zzimcong/product/ProductApplicationTests.java
--------
//package com.zzimcong.product;
//
//import org.junit.jupiter.api.Test;
//import org.springframework.boot.test.context.SpringBootTest;
//
//@SpringBootTest
//class ProductApplicationTests {
//
//    @Test
//    void contextLoads() {
//    }
//
//}


--------


File: ./product/src/test/java/com/zzimcong/product/application/service/CategoryServiceTest.java
--------
//package com.zzimcong.product.application.service;
//
//import com.zzimcong.product.application.dto.CategoryDto;
//import com.zzimcong.product.common.exception.NotFoundException;
//import com.zzimcong.product.domain.entity.Category;
//import com.zzimcong.product.domain.repository.CategoryRepository;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.mockito.InjectMocks;
//import org.mockito.Mock;
//import org.mockito.MockitoAnnotations;
//
//import java.util.Arrays;
//import java.util.List;
//import java.util.Optional;
//
//import static org.junit.jupiter.api.Assertions.*;
//import static org.mockito.ArgumentMatchers.*;
//import static org.mockito.Mockito.*;
//
//class CategoryServiceTest {
//
//    @Mock
//    private CategoryRepository categoryRepository;
//
//    @InjectMocks
//    private CategoryService categoryService;
//
//    @BeforeEach
//    void setUp() {
//        MockitoAnnotations.openMocks(this);
//    }
//
//    @Test
//    void testGetAllCategories() {
//        Category category1 = new Category();
//        category1.setId(1L);
//        category1.setName("Category 1");
//
//        Category category2 = new Category();
//        category2.setId(2L);
//        category2.setName("Category 2");
//        category2.setParentCategory(category1);
//
//        when(categoryRepository.findAllWithParent()).thenReturn(Arrays.asList(category1, category2));
//
//        List<CategoryDto> result = categoryService.getAllCategories();
//
//        assertNotNull(result);
//        assertEquals(1, result.size());
//        assertEquals("Category 1", result.get(0).getName());
//        assertEquals(1, result.get(0).getChildCategories().size());
//        assertEquals("Category 2", result.get(0).getChildCategories().get(0).getName());
//
//        verify(categoryRepository, times(1)).findAllWithParent();
//    }
//
//    @Test
//    void testCreateCategory() {
//        Category parentCategory = new Category();
//        parentCategory.setId(1L);
//        parentCategory.setPath("/1/");
//
//        Category newCategory = new Category();
//        newCategory.setId(2L);
//        newCategory.setName("New Category");
//        newCategory.setParentCategory(parentCategory);
//        newCategory.setPath("/1/2/");
//
//        when(categoryRepository.findById(1L)).thenReturn(Optional.of(parentCategory));
//        when(categoryRepository.save(any(Category.class))).thenReturn(newCategory);
//
//        Category result = categoryService.createCategory("New Category", 1L);
//
//        assertNotNull(result);
//        assertEquals(2L, result.getId());
//        assertEquals("New Category", result.getName());
//        assertEquals(parentCategory, result.getParentCategory());
//        assertEquals("/1/2/", result.getPath());
//
//        verify(categoryRepository, times(1)).findById(1L);
//        verify(categoryRepository, times(1)).save(any(Category.class));
//    }
//
//    @Test
//    void testCreateRootCategory() {
//        Category newCategory = new Category();
//        newCategory.setId(1L);
//        newCategory.setName("Root Category");
//        newCategory.setPath("/1/");
//
//        when(categoryRepository.save(any(Category.class))).thenReturn(newCategory);
//
//        Category result = categoryService.createCategory("Root Category", null);
//
//        assertNotNull(result);
//        assertEquals(1L, result.getId());
//        assertEquals("Root Category", result.getName());
//        assertNull(result.getParentCategory());
//        assertEquals("/1/", result.getPath());
//
//        verify(categoryRepository, never()).findById(anyLong());
//        verify(categoryRepository, times(1)).save(any(Category.class));
//    }
//
//    @Test
//    void testUpdateCategory() {
//        Category existingCategory = new Category();
//        existingCategory.setId(1L);
//        existingCategory.setName("Old Name");
//
//        CategoryDto updateDto = new CategoryDto();
//        updateDto.setName("New Name");
//
//        when(categoryRepository.findById(1L)).thenReturn(Optional.of(existingCategory));
//        when(categoryRepository.save(any(Category.class))).thenAnswer(invocation -> invocation.getArgument(0));
//
//        CategoryDto result = categoryService.updateCategory(1L, updateDto);
//
//        assertNotNull(result);
//        assertEquals(1L, result.getId());
//        assertEquals("New Name", result.getName());
//
//        verify(categoryRepository, times(1)).findById(1L);
//        verify(categoryRepository, times(1)).save(any(Category.class));
//    }
//
//    @Test
//    void testUpdateCategoryNotFound() {
//        when(categoryRepository.findById(1L)).thenReturn(Optional.empty());
//
//        CategoryDto updateDto = new CategoryDto();
//        updateDto.setName("New Name");
//
//        assertThrows(NotFoundException.class, () -> categoryService.updateCategory(1L, updateDto));
//
//        verify(categoryRepository, times(1)).findById(1L);
//        verify(categoryRepository, never()).save(any(Category.class));
//    }
//
//    @Test
//    void testDeleteCategory() {
//        Category category = new Category();
//        category.setId(1L);
//
//        when(categoryRepository.findById(1L)).thenReturn(Optional.of(category));
//
//        categoryService.deleteCategory(1L);
//
//        verify(categoryRepository, times(1)).findById(1L);
//        verify(categoryRepository, times(1)).delete(category);
//    }
//
//    @Test
//    void testDeleteCategoryNotFound() {
//        when(categoryRepository.findById(1L)).thenReturn(Optional.empty());
//
//        assertThrows(NotFoundException.class, () -> categoryService.deleteCategory(1L));
//
//        verify(categoryRepository, times(1)).findById(1L);
//        verify(categoryRepository, never()).delete(any(Category.class));
//    }
//
//    @Test
//    void testFindAllSubCategoryIds() {
//        Category parentCategory = new Category();
//        parentCategory.setId(1L);
//        parentCategory.setPath("/1/");
//
//        Category childCategory1 = new Category();
//        childCategory1.setId(2L);
//        childCategory1.setPath("/1/2/");
//
//        Category childCategory2 = new Category();
//        childCategory2.setId(3L);
//        childCategory2.setPath("/1/3/");
//
//        when(categoryRepository.findById(1L)).thenReturn(Optional.of(parentCategory));
//        when(categoryRepository.findByPathStartingWith("/1/")).thenReturn(Arrays.asList(childCategory1, childCategory2));
//
//        List<Long> result = categoryService.findAllSubCategoryIds(1L);
//
//        assertNotNull(result);
//        assertEquals(3, result.size());
//        assertTrue(result.containsAll(Arrays.asList(1L, 2L, 3L)));
//
//        verify(categoryRepository, times(1)).findById(1L);
//        verify(categoryRepository, times(1)).findByPathStartingWith("/1/");
//    }
//
//    @Test
//    void testFindAllSubCategoryIdsNotFound() {
//        when(categoryRepository.findById(1L)).thenReturn(Optional.empty());
//
//        assertThrows(NotFoundException.class, () -> categoryService.findAllSubCategoryIds(1L));
//
//        verify(categoryRepository, times(1)).findById(1L);
//        verify(categoryRepository, never()).findByPathStartingWith(anyString());
//    }
//
//    @Test
//    void testGetCategoryById() {
//        Category category = new Category();
//        category.setId(1L);
//        category.setName("Test Category");
//
//        when(categoryRepository.findById(1L)).thenReturn(Optional.of(category));
//
//        Category result = categoryService.getCategoryById(1L);
//
//        assertNotNull(result);
//        assertEquals(1L, result.getId());
//        assertEquals("Test Category", result.getName());
//
//        verify(categoryRepository, times(1)).findById(1L);
//    }
//
//    @Test
//    void testGetCategoryByIdNotFound() {
//        when(categoryRepository.findById(1L)).thenReturn(Optional.empty());
//
//        assertThrows(NotFoundException.class, () -> categoryService.getCategoryById(1L));
//
//        verify(categoryRepository, times(1)).findById(1L);
//    }
//}

--------


File: ./product/src/test/java/com/zzimcong/product/application/service/CartServiceTest.java
--------
//package com.zzimcong.product.application.service;
//
//import com.zzimcong.product.application.dto.CartItemDto;
//import com.zzimcong.product.common.exception.BadRequestException;
//import com.zzimcong.product.common.exception.ConflictException;
//import com.zzimcong.product.common.exception.NotFoundException;
//import com.zzimcong.product.domain.entity.CartItem;
//import com.zzimcong.product.domain.entity.Product;
//import com.zzimcong.product.domain.repository.CartRepository;
//import com.zzimcong.product.domain.repository.ProductRepository;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.mockito.InjectMocks;
//import org.mockito.Mock;
//import org.mockito.MockitoAnnotations;
//
//import java.util.Arrays;
//import java.util.List;
//import java.util.Optional;
//
//import static org.junit.jupiter.api.Assertions.*;
//import static org.mockito.ArgumentMatchers.any;
//import static org.mockito.ArgumentMatchers.anyLong;
//import static org.mockito.Mockito.*;
//
//class CartServiceTest {
//
//    @Mock
//    private CartRepository cartRepository;
//
//    @Mock
//    private ProductRepository productRepository;
//
//    @InjectMocks
//    private CartService cartService;
//
//    @BeforeEach
//    void setUp() {
//        MockitoAnnotations.openMocks(this);
//    }
//
//    @Test
//    void testGetCartItemsForUser() {
//        CartItem cartItem1 = new CartItem(1L, new Product(), 2);
//        CartItem cartItem2 = new CartItem(1L, new Product(), 3);
//
//        when(cartRepository.findByUserId(1L)).thenReturn(Arrays.asList(cartItem1, cartItem2));
//
//        List<CartItemDto> result = cartService.getCartItemsForUser(1L);
//
//        assertNotNull(result);
//        assertEquals(2, result.size());
//
//        verify(cartRepository, times(1)).findByUserId(1L);
//    }
//
//    @Test
//    void testAddProductToCart() {
//        Product product = new Product();
//        product.setId(1L);
//        product.setAvailableQuantity(10);
//
//        when(productRepository.findById(1L)).thenReturn(Optional.of(product));
//        when(cartRepository.findByUserIdAndProductId(1L, 1L)).thenReturn(Optional.empty());
//        when(cartRepository.save(any(CartItem.class))).thenAnswer(invocation -> invocation.getArgument(0));
//
//        cartService.addProductToCart(1L, 1L, 2);
//
//        verify(productRepository, times(1)).findById(1L);
//        verify(cartRepository, times(1)).findByUserIdAndProductId(1L, 1L);
//        verify(cartRepository, times(1)).save(any(CartItem.class));
//        verify(productRepository, times(1)).save(product);
//    }
//
//    @Test
//    void testAddProductToCartExistingItem() {
//        Product product = new Product();
//        product.setId(1L);
//        product.setAvailableQuantity(10);
//
//        CartItem existingCartItem = new CartItem(1L, product, 2);
//
//        when(productRepository.findById(1L)).thenReturn(Optional.of(product));
//        when(cartRepository.findByUserIdAndProductId(1L, 1L)).thenReturn(Optional.of(existingCartItem));
//        when(cartRepository.save(any(CartItem.class))).thenAnswer(invocation -> invocation.getArgument(0));
//
//        cartService.addProductToCart(1L, 1L, 3);
//
//        assertEquals(5, existingCartItem.getCount());
//
//        verify(productRepository, times(1)).findById(1L);
//        verify(cartRepository, times(1)).findByUserIdAndProductId(1L, 1L);
//        verify(cartRepository, times(1)).save(existingCartItem);
//        verify(productRepository, times(1)).save(product);
//    }
//
//    @Test
//    void testAddProductToCartInvalidQuantity() {
//        assertThrows(BadRequestException.class, () -> cartService.addProductToCart(1L, 1L, 0));
//
//        verify(productRepository, never()).findById(anyLong());
//        verify(cartRepository, never()).findByUserIdAndProductId(anyLong(), anyLong());
//        verify(cartRepository, never()).save(any(CartItem.class));
//    }
//
//    @Test
//    void testAddProductToCartInsufficientStock() {
//        Product product = new Product();
//        product.setId(1L);
//        product.setAvailableQuantity(5);
//
//        when(productRepository.findById(1L)).thenReturn(Optional.of(product));
//
//        assertThrows(ConflictException.class, () -> cartService.addProductToCart(1L, 1L, 10));
//
//        verify(productRepository, times(1)).findById(1L);
//        verify(cartRepository, never()).findByUserIdAndProductId(anyLong(), anyLong());
//        verify(cartRepository, never()).save(any(CartItem.class));
//    }
//
//    @Test
//    void testUpdateProductCount() {
//        Product product = new Product();
//        product.setId(1L);
//        product.setAvailableQuantity(10);
//
//        CartItem cartItem = new CartItem(1L, product, 2);
//
//        when(cartRepository.findByUserIdAndProductId(1L, 1L)).thenReturn(Optional.of(cartItem));
//        when(cartRepository.save(any(CartItem.class))).thenAnswer(invocation -> invocation.getArgument(0));
//
//        cartService.updateProductCount(1L, 1L, 5);
//
//        assertEquals(5, cartItem.getCount());
//
//        verify(cartRepository, times(1)).findByUserIdAndProductId(1L, 1L);
//        verify(cartRepository, times(1)).save(cartItem);
//    }
//
//    @Test
//    void testUpdateProductCountInvalidQuantity() {
//        assertThrows(BadRequestException.class, () -> cartService.updateProductCount(1L, 1L, 0));
//
//        verify(cartRepository, never()).findByUserIdAndProductId(anyLong(), anyLong());
//        verify(cartRepository, never()).save(any(CartItem.class));
//    }
//
//    @Test
//    void testUpdateProductCountInsufficientStock() {
//        Product product = new Product();
//        product.setId(1L);
//        product.setAvailableQuantity(5);
//
//        CartItem cartItem = new CartItem(1L, product, 2);
//
//        when(cartRepository.findByUserIdAndProductId(1L, 1L)).thenReturn(Optional.of(cartItem));
//
//        assertThrows(ConflictException.class, () -> cartService.updateProductCount(1L, 1L, 10));
//
//        verify(cartRepository, times(1)).findByUserIdAndProductId(1L, 1L);
//        verify(cartRepository, never()).save(any(CartItem.class));
//    }
//
//    @Test
//    void testDeleteProductFromCart() {
//        CartItem cartItem = new CartItem(1L, new Product(), 2);
//
//        when(cartRepository.findByUserIdAndProductId(1L, 1L)).thenReturn(Optional.of(cartItem));
//
//        cartService.deleteProductFromCart(1L, 1L);
//
//        verify(cartRepository, times(1)).findByUserIdAndProductId(1L, 1L);
//        verify(cartRepository, times(1)).delete(cartItem);
//    }
//
//    @Test
//    void testDeleteProductFromCartNotFound() {
//        when(cartRepository.findByUserIdAndProductId(1L, 1L)).thenReturn(Optional.empty());
//
//        assertThrows(NotFoundException.class, () -> cartService.deleteProductFromCart(1L, 1L));
//
//        verify(cartRepository, times(1)).findByUserIdAndProductId(1L, 1L);
//        verify(cartRepository, never()).delete(any(CartItem.class));
//    }
//}

--------


File: ./product/src/test/java/com/zzimcong/product/application/service/ProductServiceTest.java
--------
//package com.zzimcong.product.application.service;
//
//import com.zzimcong.product.application.dto.*;
//import com.zzimcong.product.domain.entity.Category;
//import com.zzimcong.product.domain.entity.Product;
//import com.zzimcong.product.domain.repository.ProductRepository;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.mockito.InjectMocks;
//import org.mockito.Mock;
//import org.mockito.MockitoAnnotations;
//import org.springframework.data.domain.Page;
//import org.springframework.data.domain.PageImpl;
//import org.springframework.data.domain.Pageable;
//
//import java.util.Arrays;
//import java.util.List;
//import java.util.Optional;
//
//import static org.junit.jupiter.api.Assertions.*;
//import static org.mockito.ArgumentMatchers.*;
//import static org.mockito.Mockito.*;
//
//class ProductServiceTest {
//
//    @Mock
//    private ProductRepository productRepository;
//
//    @Mock
//    private CategoryService categoryService;
//
//    @InjectMocks
//    private ProductService productService;
//
//    @BeforeEach
//    void setUp() {
//        MockitoAnnotations.openMocks(this);
//    }
//
//    @Test
//    void testCreateProduct() {
//        ProductRequestDto requestDto = new ProductRequestDto();
//        requestDto.setCategoryId(1L);
//        requestDto.setName("Test Product");
//        requestDto.setPrice(100);
//        requestDto.setSale(10);
//        requestDto.setContent("Test Content");
//        requestDto.setImage("test.jpg");
//        requestDto.setAvailableQuantity(50);
//
//        Category category = new Category();
//        category.setId(1L);
//
//        Product product = new Product(requestDto, category);
//        product.setId(1L);
//
//        when(categoryService.getCategoryById(1L)).thenReturn(category);
//        when(productRepository.save(any(Product.class))).thenReturn(product);
//
//        ProductResponseDto responseDto = productService.createProduct(requestDto);
//
//        assertNotNull(responseDto);
//        assertEquals(1L, responseDto.getProductId());
//        assertEquals("Test Product", responseDto.getName());
//        assertEquals(100, responseDto.getPrice());
//        assertEquals(10, responseDto.getSale());
//        assertEquals("Test Content", responseDto.getContent());
//        assertEquals("test.jpg", responseDto.getImage());
//        assertEquals(50, responseDto.getAvailableQuantity());
//
//        verify(categoryService, times(1)).getCategoryById(1L);
//        verify(productRepository, times(1)).save(any(Product.class));
//    }
//
//    @Test
//    void testGetProductById() {
//        Product product = new Product();
//        product.setId(1L);
//        product.setName("Test Product");
//        product.setPrice(100);
//        product.setSale(10);
//        product.setContent("Test Content");
//        product.setImage("test.jpg");
//        product.setAvailableQuantity(50);
//
//        Category category = new Category();
//        category.setId(1L);
//        product.setCategory(category);
//
//        when(productRepository.findById(1L)).thenReturn(Optional.of(product));
//
//        ProductResponseDto responseDto = productService.getProductById(1L);
//
//        assertNotNull(responseDto);
//        assertEquals(1L, responseDto.getProductId());
//        assertEquals("Test Product", responseDto.getName());
//        assertEquals(100, responseDto.getPrice());
//        assertEquals(10, responseDto.getSale());
//        assertEquals("Test Content", responseDto.getContent());
//        assertEquals("test.jpg", responseDto.getImage());
//        assertEquals(50, responseDto.getAvailableQuantity());
//
//        verify(productRepository, times(1)).findById(1L);
//    }
//
//    @Test
//    void testGetProductByIdNotFound() {
//        when(productRepository.findById(1L)).thenReturn(Optional.empty());
//
//        assertNull(productService.getProductById(1L));
//
//        verify(productRepository, times(1)).findById(1L);
//    }
//
//    @Test
//    void testUpdateProduct() {
//        ProductRequestDto requestDto = new ProductRequestDto();
//        requestDto.setCategoryId(2L);
//        requestDto.setName("Updated Product");
//        requestDto.setPrice(200);
//        requestDto.setSale(20);
//        requestDto.setContent("Updated Content");
//        requestDto.setImage("updated.jpg");
//        requestDto.setAvailableQuantity(100);
//
//        Product existingProduct = new Product();
//        existingProduct.setId(1L);
//        existingProduct.setName("Test Product");
//        existingProduct.setPrice(100);
//        existingProduct.setSale(10);
//        existingProduct.setContent("Test Content");
//        existingProduct.setImage("test.jpg");
//        existingProduct.setAvailableQuantity(50);
//
//        Category category = new Category();
//        category.setId(2L);
//
//        when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
//        when(categoryService.getCategoryById(2L)).thenReturn(category);
//        when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
//
//        ProductResponseDto responseDto = productService.updateProduct(1L, requestDto);
//
//        assertNotNull(responseDto);
//        assertEquals(1L, responseDto.getProductId());
//        assertEquals("Updated Product", responseDto.getName());
//        assertEquals(200, responseDto.getPrice());
//        assertEquals(20, responseDto.getSale());
//        assertEquals("Updated Content", responseDto.getContent());
//        assertEquals("updated.jpg", responseDto.getImage());
//        assertEquals(100, responseDto.getAvailableQuantity());
//
//        verify(productRepository, times(1)).findById(1L);
//        verify(categoryService, times(1)).getCategoryById(2L);
//        verify(productRepository, times(1)).save(any(Product.class));
//    }
//
//    @Test
//    void testUpdateProductNotFound() {
//        ProductRequestDto requestDto = new ProductRequestDto();
//        when(productRepository.findById(1L)).thenReturn(Optional.empty());
//
//        assertNull(productService.updateProduct(1L, requestDto));
//
//        verify(productRepository, times(1)).findById(1L);
//        verify(productRepository, never()).save(any(Product.class));
//    }
//
//    @Test
//    void testGetProducts() {
//        Product product1 = new Product();
//        product1.setId(1L);
//        product1.setName("Product 1");
//
//        Product product2 = new Product();
//        product2.setId(2L);
//        product2.setName("Product 2");
//
//        List<Product> productList = Arrays.asList(product1, product2);
//        Page<Product> productPage = new PageImpl<>(productList);
//
//        when(productRepository.findAllWithFilters(anyString(), anyList(), any(Pageable.class))).thenReturn(productPage);
//
//        List<ProductResponseDto> result = productService.getProducts(0, 10, "search", 1L);
//
//        assertNotNull(result);
//        assertEquals(2, result.size());
//        assertEquals("Product 1", result.get(0).getName());
//        assertEquals("Product 2", result.get(1).getName());
//
//        verify(productRepository, times(1)).findAllWithFilters(anyString(), anyList(), any(Pageable.class));
//    }
//
//    @Test
//    void testDeleteProduct() {
//        Product product = new Product();
//        product.setId(1L);
//        product.setDeleted(false);
//
//        when(productRepository.findById(1L)).thenReturn(Optional.of(product));
//        when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
//
//        productService.deleteProduct(1L);
//
//        assertTrue(product.isDeleted());
//        verify(productRepository, times(1)).findById(1L);
//        verify(productRepository, times(1)).save(product);
//    }
//
//    @Test
//    void testReserveInventory() {
//        Product product = new Product();
//        product.setId(1L);
//        product.setAvailableQuantity(10);
//        product.setReservedQuantity(0);
//
//        when(productRepository.findById(1L)).thenReturn(Optional.of(product));
//        when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
//
//        ReserveInventoryRequest request = new ReserveInventoryRequest();
//        request.setQuantity(5);
//
//        ReserveInventoryResponse response = productService.reserveInventory(1L, request);
//
//        assertTrue(response.isSuccess());
//        assertEquals("재고 예약 성공", response.getMessage());
//        assertEquals(5, product.getAvailableQuantity());
//        assertEquals(5, product.getReservedQuantity());
//
//        verify(productRepository, times(1)).findById(1L);
//        verify(productRepository, times(1)).save(product);
//    }
//
//    @Test
//    void testReserveInventoryInsufficientStock() {
//        Product product = new Product();
//        product.setId(1L);
//        product.setAvailableQuantity(3);
//        product.setReservedQuantity(0);
//
//        when(productRepository.findById(1L)).thenReturn(Optional.of(product));
//
//        ReserveInventoryRequest request = new ReserveInventoryRequest();
//        request.setQuantity(5);
//
//        ReserveInventoryResponse response = productService.reserveInventory(1L, request);
//
//        assertFalse(response.isSuccess());
//        assertEquals("가용 재고가 부족합니다.", response.getMessage());
//        assertEquals(3, product.getAvailableQuantity());
//        assertEquals(0, product.getReservedQuantity());
//
//        verify(productRepository, times(1)).findById(1L);
//        verify(productRepository, never()).save(any(Product.class));
//    }
//
//    @Test
//    void testReleaseInventory() {
//        Product product = new Product();
//        product.setId(1L);
//        product.setAvailableQuantity(5);
//        product.setReservedQuantity(5);
//
//        when(productRepository.findById(1L)).thenReturn(Optional.of(product));
//        when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
//
//        ReleaseInventoryRequest request = new ReleaseInventoryRequest();
//        request.setQuantity(3);
//
//        productService.releaseInventory(1L, request);
//
//        assertEquals(8, product.getAvailableQuantity());
//        assertEquals(2, product.getReservedQuantity());
//
//        verify(productRepository, times(1)).findById(1L);
//        verify(productRepository, times(1)).save(product);
//    }
//
//    @Test
//    void testReleaseInventoryInsufficientReservedStock() {
//        Product product = new Product();
//        product.setId(1L);
//        product.setAvailableQuantity(5);
//        product.setReservedQuantity(2);
//
//        when(productRepository.findById(1L)).thenReturn(Optional.of(product));
//
//        ReleaseInventoryRequest request = new ReleaseInventoryRequest();
//        request.setQuantity(3);
//
//        assertThrows(IllegalStateException.class, () -> productService.releaseInventory(1L, request));
//
//        verify(productRepository, times(1)).findById(1L);
//        verify(productRepository, never()).save(any(Product.class));
//    }
//}

--------


File: ./product/src/main/java/com/zzimcong/product/common/util/RedisUtil.java
--------
package com.zzimcong.product.common.util;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Service
@RequiredArgsConstructor
public class RedisUtil {
    private final StringRedisTemplate redisTemplate;//Redis에 접근하기 위한 Spring의 Redis 템플릿 클래스

    public String getData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 가져오는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        return valueOperations.get(key);
    }

    public void setData(String key, String value) {//지정된 키(key)에 값을 저장하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        valueOperations.set(key, value);
    }

    public void setDataExpire(String key, String value, long duration) {//지정된 키(key)에 값을 저장하고, 지정된 시간(duration) 후에 데이터가 만료되도록 설정하는 메서드
        ValueOperations<String, String> valueOperations = redisTemplate.opsForValue();
        Duration expireDuration = Duration.ofSeconds(duration);
        valueOperations.set(key, value, expireDuration);
    }

    public void deleteData(String key) {//지정된 키(key)에 해당하는 데이터를 Redis에서 삭제하는 메서드
        redisTemplate.delete(key);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/UserInfo.java
--------
package com.zzimcong.product.common;

import lombok.Data;

@Data
public class UserInfo {
    private Long id;
    private String username;
    private String role;
    // 필요한 다른 필드들...
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/ErrorCode.java
--------
package com.zzimcong.product.common.exception;

import lombok.Getter;

@Getter
public enum ErrorCode {
    // BadRequestException (400)
    INVALID_INPUT("잘못된 입력입니다."),
    INVALID_QUANTITY("상품 수량은 1 이상이어야 합니다."),
    MISSING_REQUEST_BODY("요청 바디가 존재하지 않습니다."),

    // UnauthorizedException (401)

    // NotFoundException (404)
    RESOURCE_NOT_FOUND("요청한 리소스를 찾을 수 없습니다."),
    PRODUCT_NOT_FOUND("상품을 찾을 수 없습니다."),
    CART_PRODUCT_NOT_FOUND("장바구니 상품을 찾을 수 없습니다."),
    CATEGORY_NOT_FOUND("카테고리를 찾을 수 없습니다."),

    // MethodNotAllowedException (405)
    METHOD_NOT_ALLOWED("허용되지 않은 HTTP 메서드입니다."),

    // ConflictException (409)
    INSUFFICIENT_STOCK("상품의 재고가 부족합니다."),

    // InternalServerErrorException (500)
    RESOURCE_LOAD_FAILED("내부 리소스 로딩에 실패했습니다."),
    INTERNAL_SERVER_ERROR("서버 내부 오류가 발생했습니다.");

    private final String message;

    ErrorCode(String message) {
        this.message = message;
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/ForbiddenException.java
--------
package com.zzimcong.product.common.exception;

public class ForbiddenException extends BaseException {
    public ForbiddenException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ForbiddenException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/UnauthorizedException.java
--------
package com.zzimcong.product.common.exception;

public class UnauthorizedException extends BaseException {
    public UnauthorizedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public UnauthorizedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/ConflictException.java
--------
package com.zzimcong.product.common.exception;

public class ConflictException extends BaseException {
    public ConflictException(ErrorCode errorCode) {
        super(errorCode);
    }

    public ConflictException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/MethodNotAllowedException.java
--------
package com.zzimcong.product.common.exception;

public class MethodNotAllowedException extends BaseException {
    public MethodNotAllowedException(ErrorCode errorCode) {
        super(errorCode);
    }

    public MethodNotAllowedException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/InternalServerErrorException.java
--------
package com.zzimcong.product.common.exception;

public class InternalServerErrorException extends BaseException {
    public InternalServerErrorException(ErrorCode errorCode) {
        super(errorCode);
    }

    public InternalServerErrorException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/GlobalExceptionHandler.java
--------
package com.zzimcong.product.common.exception;

import com.zzimcong.product.api.response.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j(topic = "GLOBAL_EXCEPTION_HANDLER")
@ControllerAdvice
public class GlobalExceptionHandler {
    // BadRequestException (400)
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorResponse> httpMessageNotReadableException(HttpServletRequest request) {
        BadRequestException ex = new BadRequestException(ErrorCode.MISSING_REQUEST_BODY);
        return createErrorResponse(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
    }

    // UnauthorizedException (401)
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(UnauthorizedException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.UNAUTHORIZED, request.getRequestURI());
    }

    // ForbiddenException (403)
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbiddenException(ForbiddenException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.FORBIDDEN, request.getRequestURI());
    }

    // NotFoundException (404)
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.NOT_FOUND, request.getRequestURI());
    }

    // MethodNotAllowedException (405)
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowedException(HttpServletRequest request) {
        MethodNotAllowedException ex = new MethodNotAllowedException(ErrorCode.METHOD_NOT_ALLOWED);
        return createErrorResponse(ex, HttpStatus.METHOD_NOT_ALLOWED, request.getRequestURI());
    }

    // ConflictException (409)
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(ConflictException ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.CONFLICT, request.getRequestURI());
    }

    // InternalServerErrorException (500)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllException(Exception ex, HttpServletRequest request) {
        return createErrorResponse(ex, HttpStatus.INTERNAL_SERVER_ERROR, request.getRequestURI());
    }

    // Create ErrorResponse
    private ResponseEntity<ErrorResponse> createErrorResponse(Exception ex, HttpStatus status, String path) {
        logException(ex, status, path);
        BaseException baseException = ex instanceof BaseException ?
                (BaseException) ex : new InternalServerErrorException(ErrorCode.INTERNAL_SERVER_ERROR);
        ErrorResponse errorResponse = ErrorResponse.of(baseException, status, path);
        return new ResponseEntity<>(errorResponse, status);
    }

    // Log Exception
    private void logException(Exception ex, HttpStatus status, String path) {
        // 스택 트레이스를 분석하여 예외 발생 위치 추출
        StackTraceElement[] stackTraceElements = ex.getStackTrace();
        String errorLocation = "Unknown";
        if (stackTraceElements.length > 0) {
            StackTraceElement element = stackTraceElements[0];
            errorLocation = String.format("%s.%s (Line: %d)",
                    element.getClassName(),
                    element.getMethodName(),
                    element.getLineNumber());
        }
        log.error(
                "Exception occurred:: {}, Path: {}",
                errorLocation,
                path
        );
        log.error("Error Code: {}, HTTP Status: {}, Message: {}",
                ex instanceof BaseException ? ((BaseException) ex).getErrorCode() : "UNKNOWN",
                status,
                ex.getMessage());
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/BadRequestException.java
--------
package com.zzimcong.product.common.exception;

public class BadRequestException extends BaseException {
    public BadRequestException(ErrorCode errorCode) {
        super(errorCode);
    }

    public BadRequestException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/BaseException.java
--------
package com.zzimcong.product.common.exception;

public class BaseException extends RuntimeException {
    private final ErrorCode errorCode;
    private final String message;

    public BaseException(ErrorCode errorCode) {
        this(errorCode, errorCode.getMessage());
    }

    public BaseException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.message = message;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    @Override
    public String getMessage() {
        return message;
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/common/exception/NotFoundException.java
--------
package com.zzimcong.product.common.exception;

public class NotFoundException extends BaseException {
    public NotFoundException(ErrorCode errorCode) {
        super(errorCode);
    }

    public NotFoundException(ErrorCode errorCode, String message) {
        super(errorCode, message);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/ProductApplication.java
--------
package com.zzimcong.product;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class ProductApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProductApplication.class, args);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/api/response/ApiResponse.java
--------
package com.zzimcong.product.api.response;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/api/response/ErrorResponse.java
--------
package com.zzimcong.product.api.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.zzimcong.product.common.exception.BaseException;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {
    private int status;
    private String message;
    private String errorCode;
    private LocalDateTime timestamp;
    private String path;

    public static ErrorResponse of(BaseException ex, HttpStatus status, String path) {
        ErrorResponse response = new ErrorResponse();
        response.setStatus(status.value());
        response.setMessage(ex.getMessage());
        response.setErrorCode(ex.getErrorCode().name());
        response.setTimestamp(LocalDateTime.now());
        response.setPath(path);
        return response;
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/api/controller/ProductController.java
--------
package com.zzimcong.product.api.controller;

import com.zzimcong.product.application.dto.*;
import com.zzimcong.product.application.service.ProductService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j(topic = "product-controller")
@RestController
@RequestMapping("/api/v1/products")
public class ProductController {
    private final ProductService productService;

    @Autowired
    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    //상품 목록 조회
    @GetMapping
    public ResponseEntity<List<ProductResponseDto>> getProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String search,
            @RequestParam(required = false) Long categoryId) {
        List<ProductResponseDto> products = productService.getProducts(page, size, search, categoryId);
        return ResponseEntity.ok(products);
    }

    //상품 등록
    @PostMapping
    public ResponseEntity<ProductResponseDto> createProduct(@RequestBody ProductRequestDto productRequestDto) {
        ProductResponseDto productResponseDto = productService.createProduct(productRequestDto);
        return ResponseEntity.ok(productResponseDto);
    }

    //상품 정보 조회
    @GetMapping("/{id}")
    public ResponseEntity<ProductResponseDto> getProductById(@PathVariable Long id) {
        ProductResponseDto productResponseDto = productService.getProductById(id);
        if (productResponseDto != null) {
            return ResponseEntity.ok(productResponseDto);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    //상품 정보 수정
    @PutMapping("/{id}")
    public ResponseEntity<ProductResponseDto> updateProduct(@PathVariable Long id, @RequestBody ProductRequestDto productRequestDto) {
        ProductResponseDto updatedProduct = productService.updateProduct(id, productRequestDto);
        if (updatedProduct != null) {
            return ResponseEntity.ok(updatedProduct);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    //상품 삭제
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> updateProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
        return ResponseEntity.ok().build();
    }

    //상품 재고 예약
    @PostMapping("/{productId}/reserve")
    public ResponseEntity<ReserveInventoryResponse> reserveInventory(@PathVariable("productId") Long productId,
                                                                     @RequestBody ReserveInventoryRequest request) {
        ReserveInventoryResponse response = productService.reserveInventory(productId, request);
        return ResponseEntity.ok(response);
    }

    //상품 재고 해제
    @PostMapping("/{productId}/release")
    public ResponseEntity<Void> releaseInventory(@PathVariable("productId") Long productId,
                                                 @RequestBody ReleaseInventoryRequest request) {
        productService.releaseInventory(productId, request);
        return ResponseEntity.noContent().build();
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/api/controller/CartController.java
--------
package com.zzimcong.product.api.controller;

import com.zzimcong.product.application.dto.CartItemDto;
import com.zzimcong.product.application.service.CartService;
import jakarta.validation.constraints.Min;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/cart")
public class CartController {
    private final CartService cartService;

    public CartController(CartService cartService) {
        this.cartService = cartService;
    }

    @GetMapping
    public ResponseEntity<List<CartItemDto>> getMyCart(@RequestHeader("X-Auth-User-ID") Long userId) {
        List<CartItemDto> cart = cartService.getCartItemsForUser(userId);
        return ResponseEntity.ok(cart);
    }

    @PostMapping("/{productId}")
    public ResponseEntity<String> addProductToCart(
            @RequestHeader("X-Auth-User-ID") Long userId,
            @PathVariable Long productId,
            @RequestParam @Min(value = 1, message = "수량은 1 이상이어야 합니다.") int count) {
        cartService.addProductToCart(userId, productId, count);
        return ResponseEntity.status(HttpStatus.CREATED).body("장바구니 추가 완료");
    }

    @PatchMapping("/{productId}")
    public ResponseEntity<String> updateProductCount(
            @RequestHeader("X-Auth-User-ID") Long userId,
            @PathVariable Long productId,
            @RequestParam @Min(value = 1, message = "수량은 1 이상이어야 합니다.") int count) {
        cartService.updateProductCount(userId, productId, count);
        return ResponseEntity.ok("수량 업데이트 완료");
    }

    @DeleteMapping("/{productId}")
    public ResponseEntity<Void> deleteProductFromCart(
            @RequestHeader("X-Auth-User-ID") Long userId,
            @PathVariable Long productId) {
        cartService.deleteProductFromCart(userId, productId);
        return ResponseEntity.noContent().build();
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/api/controller/CategoryController.java
--------
package com.zzimcong.product.api.controller;

import com.zzimcong.product.application.dto.CategoryCreateRequestDto;
import com.zzimcong.product.application.dto.CategoryDto;
import com.zzimcong.product.application.service.CategoryService;
import com.zzimcong.product.domain.entity.Category;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/categories")
public class CategoryController {
    private final CategoryService categoryService;

    @Autowired
    public CategoryController(CategoryService categoryService) {
        this.categoryService = categoryService;
    }

    //카테고리 목록 조회
    @GetMapping
    public List<CategoryDto> getCategories() {
        return categoryService.getAllCategories();
    }

    //카테고리 추가
    @PostMapping
    public ResponseEntity<Category> createCategory(@RequestBody CategoryCreateRequestDto request) {
        Category category = categoryService.createCategory(request.getName(), request.getParentCategoryId());
        return ResponseEntity.ok(category);
    }

    //카테고리 수정
    @PutMapping("/{id}")
    public CategoryDto updateCategory(@PathVariable Long id, @RequestBody CategoryDto categoryDto) {
        return categoryService.updateCategory(id, categoryDto);
    }

    //카테고리 삭제
    @DeleteMapping("/{id}")
    public void deleteCategory(@PathVariable Long id) {
        categoryService.deleteCategory(id);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/api/client/UserClient.java
--------
package com.zzimcong.product.api.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

@FeignClient(name = "user-service")
public interface UserClient {
    @GetMapping("/api/v1/auth/info")
    String getUserInfo();
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/ProductResponseDto.java
--------
package com.zzimcong.product.application.dto;

import com.zzimcong.product.domain.entity.Product;
import lombok.Data;

@Data
public class ProductResponseDto {
    private Long productId;
    private Long categoryId;
    private String name;
    private int price;
    private int sale;
    private String content;
    private String image;
    private int availableQuantity;
    private int reservedQuantity;
    private String createdAt;
    private boolean deleted;

    public ProductResponseDto(Product product) {
        this.productId = product.getId();
        this.categoryId = product.getCategory().getId();
        this.name = product.getName();
        this.price = product.getPrice();
        this.sale = product.getSale();
        this.content = product.getContent();
        this.image = product.getImage();
        this.availableQuantity = product.getAvailableQuantity();
        this.reservedQuantity = product.getReservedQuantity();
        this.createdAt = product.getCreatedAt().toString();
        this.deleted = product.isDeleted();
    }

    public static ProductResponseDto of(Product product) {
        return new ProductResponseDto(product);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/CategoryDto.java
--------
package com.zzimcong.product.application.dto;

import com.zzimcong.product.domain.entity.Category;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Getter
@Setter
@NoArgsConstructor
public class CategoryDto {
    private Long id;
    private String name;
    private Long parentCategoryId;
    private List<CategoryDto> childCategories;

    public CategoryDto(Category category) {
        this.id = category.getId();
        this.name = category.getName();
        this.parentCategoryId = category.getParentCategory() != null ? category.getParentCategory().getId() : null;
        this.childCategories = category.getChildCategories().stream()
                .map(CategoryDto::new)
                .collect(Collectors.toList());
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CategoryDto that = (CategoryDto) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    public static CategoryDto of(Category category) {
        return new CategoryDto(category);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/AddToCartRequestDto.java
--------
package com.zzimcong.product.application.dto;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class AddToCartRequestDto {
    private Long productId;
    private int count;
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/ProductRequestDto.java
--------
package com.zzimcong.product.application.dto;

import lombok.Data;

@Data
public class ProductRequestDto {
    private Long categoryId;
    private String name;
    private int price;
    private int sale;
    private String content;
    private String image;
    private int availableQuantity;
    private int reservedQuantity;
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/CategoryCreateRequestDto.java
--------
package com.zzimcong.product.application.dto;

import lombok.Data;

@Data
public class CategoryCreateRequestDto {
    private String name;
    private Long parentCategoryId;
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/ReleaseInventoryRequest.java
--------
package com.zzimcong.product.application.dto;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class ReleaseInventoryRequest {
    private int quantity;
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/CartItemDto.java
--------
package com.zzimcong.product.application.dto;

import com.zzimcong.product.domain.entity.CartItem;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class CartItemDto {
    private ProductResponseDto productResponseDto;
    private int count;

    //생성자
    public CartItemDto(CartItem cartItem) {
        this.productResponseDto = ProductResponseDto.of(cartItem.getProduct());
        this.count = cartItem.getCount();
    }

    //factory method
    public static CartItemDto of(CartItem cartItem) {
        return new CartItemDto(cartItem);
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/ReserveInventoryResponse.java
--------
package com.zzimcong.product.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ReserveInventoryResponse {
    private boolean success;
    private String message;
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/dto/ReserveInventoryRequest.java
--------
package com.zzimcong.product.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ReserveInventoryRequest {
    private int quantity;
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/service/CartService.java
--------
package com.zzimcong.product.application.service;

import com.zzimcong.product.application.dto.CartItemDto;
import com.zzimcong.product.common.exception.BadRequestException;
import com.zzimcong.product.common.exception.ConflictException;
import com.zzimcong.product.common.exception.ErrorCode;
import com.zzimcong.product.common.exception.NotFoundException;
import com.zzimcong.product.domain.entity.CartItem;
import com.zzimcong.product.domain.entity.Product;
import com.zzimcong.product.domain.repository.CartRepository;
import com.zzimcong.product.domain.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Slf4j(topic = "CartService")
@Service
@RequiredArgsConstructor
public class CartService {
    private final CartRepository cartRepository;
    private final ProductRepository productRepository;

    @Transactional(readOnly = true)
    public List<CartItemDto> getCartItemsForUser(Long userId) {
        List<CartItem> cartItems = cartRepository.findByUserId(userId);
        log.info("Retrieved {} cart products for user ID: {}", cartItems.size(), userId);
        return cartItems.stream()
                .map(CartItemDto::of)
                .toList();
    }

    @Transactional
    public void addProductToCart(Long userId, Long productId, int count) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.PRODUCT_NOT_FOUND));

        if (count <= 0) {
            throw new BadRequestException(ErrorCode.INVALID_QUANTITY);
        }

        if (product.getAvailableQuantity() < count) {
            throw new ConflictException(ErrorCode.INSUFFICIENT_STOCK);
        }

        Optional<CartItem> existingCartProduct = cartRepository.findByUserIdAndProductId(userId, productId);

        if (existingCartProduct.isPresent()) {
            CartItem cartItem = existingCartProduct.get();
            cartItem.setCount(cartItem.getCount() + count);
            cartRepository.save(cartItem);
            log.debug("Updated cart product quantity for user ID: {}, product ID: {}", userId, productId);
        } else {
            CartItem newCartItem = new CartItem(userId, product, count);
            cartRepository.save(newCartItem);
            log.debug("Added new product to cart for user ID: {}, product ID: {}", userId, productId);
        }

        productRepository.save(product);
    }

    @Transactional
    public void updateProductCount(Long userId, Long productId, int count) {
        CartItem cartItem = cartRepository.findByUserIdAndProductId(userId, productId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CART_PRODUCT_NOT_FOUND));

        if (count <= 0) {
            throw new BadRequestException(ErrorCode.INVALID_QUANTITY);
        }

        Product product = cartItem.getProduct();
        int stockDifference = count - cartItem.getCount();

        if (product.getAvailableQuantity() < stockDifference) {
            throw new ConflictException(ErrorCode.INSUFFICIENT_STOCK);
        }

        cartItem.setCount(count);
        cartRepository.save(cartItem);

        log.info("Updated cart product quantity for user ID: {}, product ID: {}, new quantity: {}", userId, productId, count);
    }

    @Transactional
    public void deleteProductFromCart(Long userId, Long productId) {
        CartItem cartItem = cartRepository.findByUserIdAndProductId(userId, productId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CART_PRODUCT_NOT_FOUND));

        cartRepository.delete(cartItem);
        log.info("Deleted product from cart for user ID: {}, product ID: {}", userId, productId);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/service/ProductService.java
--------
package com.zzimcong.product.application.service;

import com.zzimcong.product.application.dto.*;
import com.zzimcong.product.domain.entity.Category;
import com.zzimcong.product.domain.entity.Product;
import com.zzimcong.product.domain.repository.ProductRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;

@Slf4j(topic = "product-service")
@Service
public class ProductService {
    private final ProductRepository productRepository;
    private final CategoryService categoryService;

    @Autowired
    public ProductService(ProductRepository productRepository, CategoryService categoryService) {
        this.productRepository = productRepository;
        this.categoryService = categoryService;
    }

    //상품 등록
    public ProductResponseDto createProduct(ProductRequestDto productRequestDto) {
        Category category = categoryService.getCategoryById(productRequestDto.getCategoryId());
        Product product = new Product(productRequestDto, category);
        Product createdProduct = productRepository.save(product);
        return new ProductResponseDto(createdProduct);
    }

    //상품 조회
    public ProductResponseDto getProductById(Long id) {
        Product product = productRepository.findById(id).orElse(null);
        if (product != null) {
            return new ProductResponseDto(product);
        } else {
            return null;
        }
    }

    //상품 수정
    public ProductResponseDto updateProduct(Long id, ProductRequestDto productRequestDto) {
        Product updateProduct = productRepository.findById(id).orElse(null);
        if (updateProduct != null) {
            updateProduct.setName(productRequestDto.getName());
            updateProduct.setPrice(productRequestDto.getPrice());
            updateProduct.setSale(productRequestDto.getSale());
            updateProduct.setContent(productRequestDto.getContent());
            updateProduct.setImage(productRequestDto.getImage());
            updateProduct.setAvailableQuantity(productRequestDto.getAvailableQuantity());
            Category category = categoryService.getCategoryById(productRequestDto.getCategoryId());
            updateProduct.setCategory(category);
            Product updatedProduct = productRepository.save(updateProduct);
            return new ProductResponseDto(updatedProduct);
        } else {
            return null;
        }
    }

    //상품 목록 조회
    public List<ProductResponseDto> getProducts(int page, int size, String search, Long categoryId) {
        List<Long> categoryIds = categoryId != null ?
                categoryService.findAllSubCategoryIds(categoryId) : null;

        Pageable pageable = PageRequest.of(page, size);
        Page<Product> productPage = productRepository.findAllWithFilters(search, categoryIds, pageable);

        if (productPage.isEmpty()) {
            log.warn("No products found for page: {}, size: {}, search: {}, categoryId: {}", page, size, search, categoryId);
            return Collections.emptyList();
        }

        return productPage.map(ProductResponseDto::of).getContent();
    }

    //상품 삭제
    public void deleteProduct(Long id) {
        Product product = productRepository.findById(id).orElse(null);
        if (product != null) {
            product.setDeleted(true);
            productRepository.save(product);
        }
    }

    //재고 예약
    @Transactional
    public ReserveInventoryResponse reserveInventory(Long productId, ReserveInventoryRequest request) {
        log.info("Attempting to reserve inventory for product ID: {}, Requested quantity: {}", productId, request.getQuantity());
        try {
            // 상품 조회
            Product product = productRepository.findById(productId)
                    .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));
            log.info("Product found: ID={}, Current available quantity={}, Current reserved quantity={}",
                    productId, product.getAvailableQuantity(), product.getReservedQuantity());

            int requestedQuantity = request.getQuantity();

            // 가용 재고 확인
            if (product.getAvailableQuantity() < requestedQuantity) {
                log.warn("Insufficient available inventory. Product ID: {}, Available: {}, Requested: {}",
                        productId, product.getAvailableQuantity(), requestedQuantity);
                throw new IllegalStateException("가용 재고가 부족합니다.");
            }

            // 재고 예약
            int newAvailableQuantity = product.getAvailableQuantity() - requestedQuantity;
            int newReservedQuantity = product.getReservedQuantity() + requestedQuantity;
            product.setAvailableQuantity(newAvailableQuantity);
            product.setReservedQuantity(newReservedQuantity);
            productRepository.save(product);

            log.info("Successfully reserved inventory. Product ID: {}, Reserved: {}, New available quantity: {}, New reserved quantity: {}",
                    productId, requestedQuantity, newAvailableQuantity, newReservedQuantity);

            return new ReserveInventoryResponse(true, "재고 예약 성공");
        } catch (IllegalArgumentException | IllegalStateException e) {
            log.error("Failed to reserve inventory for product ID: {}. Error: {}", productId, e.getMessage(), e);
            return new ReserveInventoryResponse(false, e.getMessage());
        }
    }

    //재고 해제
    @Transactional
    public void releaseInventory(Long productId, ReleaseInventoryRequest request) {
        log.info("Attempting to release inventory for product ID: {}, Release quantity: {}", productId, request.getQuantity());
        try {
            // 상품 조회
            Product product = productRepository.findById(productId)
                    .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));
            log.info("Product found: ID={}, Current available quantity={}, Current reserved quantity={}",
                    productId, product.getAvailableQuantity(), product.getReservedQuantity());

            int releasedQuantity = request.getQuantity();

            // 예약된 재고 확인
            if (product.getReservedQuantity() < releasedQuantity) {
                log.warn("Insufficient reserved inventory to release. Product ID: {}, Reserved: {}, Requested to release: {}",
                        productId, product.getReservedQuantity(), releasedQuantity);
                throw new IllegalStateException("해제할 수 있는 예약 재고가 부족합니다.");
            }

            // 재고 해제
            int newReservedQuantity = product.getReservedQuantity() - releasedQuantity;
            int newAvailableQuantity = product.getAvailableQuantity() + releasedQuantity;
            product.setReservedQuantity(newReservedQuantity);
            product.setAvailableQuantity(newAvailableQuantity);
            productRepository.save(product);

            log.info("Successfully released inventory. Product ID: {}, Released: {}, New available quantity: {}, New reserved quantity: {}",
                    productId, releasedQuantity, newAvailableQuantity, newReservedQuantity);
        } catch (IllegalArgumentException | IllegalStateException e) {
            log.error("Failed to release inventory for product ID: {}. Error: {}", productId, e.getMessage(), e);
            throw e;
        }
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/application/service/InventoryService.java
--------
package com.zzimcong.product.application.service;

import com.zzimcong.product.domain.entity.InventoryEvent;
import com.zzimcong.product.domain.entity.InventoryEventType;
import com.zzimcong.product.domain.entity.Product;
import com.zzimcong.product.domain.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class InventoryService {
    private final ProductRepository productRepository;
    private final KafkaTemplate<String, InventoryEvent> kafkaTemplate;

    @Transactional
    public boolean reserveStock(Long productId, int quantity) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("제품을 찾을 수 없습니다."));

        if (product.getAvailableQuantity() >= quantity) {
            product.setReservedQuantity(product.getReservedQuantity() + quantity);
            product.setAvailableQuantity(product.getAvailableQuantity() - quantity);
            productRepository.save(product);

            kafkaTemplate.send("inventory-events", new InventoryEvent(productId, InventoryEventType.RESERVED, quantity));
            return true;
        }
        return false;
    }

    @Transactional
    public void confirmStockReduction(Long productId, int quantity) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("제품을 찾을 수 없습니다."));

        product.setReservedQuantity(product.getReservedQuantity() - quantity);
        productRepository.save(product);

        kafkaTemplate.send("inventory-events", new InventoryEvent(productId, InventoryEventType.CONFIRMED, quantity));
    }

    @Transactional
    public void cancelStockReservation(Long productId, int quantity) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("제품을 찾을 수 없습니다."));

        product.setReservedQuantity(product.getReservedQuantity() - quantity);
        product.setAvailableQuantity(product.getAvailableQuantity() + quantity);
        productRepository.save(product);

        kafkaTemplate.send("inventory-events", new InventoryEvent(productId, InventoryEventType.CANCELLED, quantity));
    }

    @Transactional
    public void restoreStock(Long productId, int quantity) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("제품을 찾을 수 없습니다."));

        product.setAvailableQuantity(product.getAvailableQuantity() + quantity);
        productRepository.save(product);

        kafkaTemplate.send("inventory-events", new InventoryEvent(productId, InventoryEventType.RESTORED, quantity));
    }

    public int getAvailableStock(Long productId) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("제품을 찾을 수 없습니다."));
        return product.getAvailableQuantity();
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/application/service/CategoryService.java
--------
package com.zzimcong.product.application.service;

import com.zzimcong.product.application.dto.CategoryDto;
import com.zzimcong.product.common.exception.ErrorCode;
import com.zzimcong.product.common.exception.NotFoundException;
import com.zzimcong.product.domain.entity.Category;
import com.zzimcong.product.domain.repository.CategoryRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Service
public class CategoryService {
    private final CategoryRepository categoryRepository;

    @Autowired
    public CategoryService(CategoryRepository categoryRepository) {
        this.categoryRepository = categoryRepository;
    }

    public List<CategoryDto> getAllCategories() {
        List<Category> allCategories = categoryRepository.findAllWithParent();
        log.debug("전체 카테고리 {}개를 조회했습니다.", allCategories.size());

        Map<Long, CategoryDto> categoryDtoMap = new HashMap<>();

        // 모든 카테고리를 DTO로 변환
        for (Category category : allCategories) {
            categoryDtoMap.put(category.getId(), CategoryDto.of(category));
        }

        // 부모-자식 관계 설정 (중복 검사 추가)
        for (Category category : allCategories) {
            if (category.getParentCategory() != null) {
                CategoryDto childDto = categoryDtoMap.get(category.getId());
                CategoryDto parentDto = categoryDtoMap.get(category.getParentCategory().getId());
                if (!parentDto.getChildCategories().contains(childDto)) {
                    parentDto.getChildCategories().add(childDto);
                }
            }
        }

        // 루트 카테고리만 필터링
        List<CategoryDto> rootCategories = categoryDtoMap.values().stream()
                .filter(dto -> dto.getParentCategoryId() == null)
                .collect(Collectors.toList());

        log.debug("최종적으로 {}개의 루트 카테고리를 반환합니다.", rootCategories.size());
        return rootCategories;
    }

    //카테고리 추가
    public Category createCategory(String name, Long parentId) {
        Category category = new Category();
        category.setName(name);

        if (parentId != null) {
            Category parentCategory = categoryRepository.findById(parentId)
                    .orElseThrow(() -> new NotFoundException(ErrorCode.CATEGORY_NOT_FOUND));
            category.setParentCategory(parentCategory);
            category.setPath(parentCategory.getPath() + parentCategory.getId() + "/");
        }

        return categoryRepository.save(category);
    }

    //카테고리 수정
    public CategoryDto updateCategory(Long id, CategoryDto categoryDto) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CATEGORY_NOT_FOUND));

        category.setName(categoryDto.getName());
        categoryRepository.save(category);

        return CategoryDto.of(category);
    }

    //카테고리 삭제
    public void deleteCategory(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CATEGORY_NOT_FOUND));

        categoryRepository.delete(category);
    }


    //서브 카테고리 조회
    public List<Long> findAllSubCategoryIds(Long categoryId) {
        Category category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CATEGORY_NOT_FOUND));

        List<Long> subCategoryIds = new ArrayList<>();
        subCategoryIds.add(categoryId);

        if (category.getPath() != null) {
            List<Category> subCategories = categoryRepository.findByPathStartingWith(category.getPath());
            subCategoryIds.addAll(subCategories.stream().map(Category::getId).toList());
        }

        return subCategoryIds;
    }


    public Category getCategoryById(Long categoryId) {
        return categoryRepository.findById(categoryId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.CATEGORY_NOT_FOUND));
    }
}


--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/config/JacksonConfig.java
--------
package com.zzimcong.product.infrastructure.config;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import java.io.IOException;

@Slf4j(topic = "jackson-config")
@Configuration
public class JacksonConfig {
    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.addHandler(new DeserializationProblemHandler() {
            @Override
            public boolean handleUnknownProperty(DeserializationContext ctxt, JsonParser p,
                                                 JsonDeserializer<?> deserializer,
                                                 Object beanOrClass, String propertyName) throws IOException {
                log.warn("알 수 없는 속성이 요청에 포함되어 있습니다. 클래스: {}, 속성명: {}",
                        beanOrClass.getClass().getSimpleName(), propertyName);
                p.skipChildren();
                return true;
            }
        });
        return objectMapper;
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/config/SecurityConfig.java
--------
package com.zzimcong.product.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .anyRequest().permitAll()
                )
                .httpBasic(Customizer.withDefaults());

        return http.build();
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/config/KafkaConfig.java
--------
package com.zzimcong.product.infrastructure.config;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.support.serializer.JsonSerializer;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Bean
    public <T> ProducerFactory<String, T> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public <T> KafkaTemplate<String, T> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/config/SwaggerConfig.java
--------
package com.zzimcong.product.infrastructure.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("찜콩 Product API")
                        .version("1.0")
                        .description("선착순 구매 기능이 있는 이커머스 서비스 API 문서"));
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/config/JpaConfig.java
--------
package com.zzimcong.product.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
@EnableJpaAuditing
public class JpaConfig {
}

--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/config/CorsConfig.java
--------
package com.zzimcong.product.infrastructure.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CorsConfig {

    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("http://localhost:3000"); // React 앱의 주소
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        source.registerCorsConfiguration("/api/**", config);
        return new CorsFilter(source);
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/infrastructure/KafkaProducer.java
--------
package com.zzimcong.product.infrastructure;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.stereotype.Component;

import java.util.concurrent.CompletableFuture;

@Component
public class KafkaProducer<T> {
    private static final Logger logger = LoggerFactory.getLogger(KafkaProducer.class);

    private final KafkaTemplate<String, T> kafkaTemplate;

    public KafkaProducer(KafkaTemplate<String, T> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    public void send(String topic, T payload) {
        logger.info("Sending Kafka message to topic: {} with payload: {}", topic, payload);
        CompletableFuture<SendResult<String, T>> future = kafkaTemplate.send(topic, payload);

        future.whenComplete((result, ex) -> {
            if (ex == null) {
                logger.info("Message sent successfully to topic: {}", topic);
            } else {
                logger.error("Failed to send message to topic: {}", topic, ex);
            }
        });
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/repository/ProductRepository.java
--------
package com.zzimcong.product.domain.repository;

import com.zzimcong.product.domain.entity.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Query("SELECT p FROM Product p LEFT JOIN FETCH p.category WHERE (:search IS NULL OR p.name LIKE %:search%) AND p.category.id IN :categoryIds")
    Page<Product> findAllWithFilters(
            @Param("search") String search,
            @Param("categoryIds") List<Long> categoryIds,
            Pageable pageable
    );
}


--------


File: ./product/src/main/java/com/zzimcong/product/domain/repository/CartRepository.java
--------
package com.zzimcong.product.domain.repository;

import com.zzimcong.product.domain.entity.CartItem;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface CartRepository extends JpaRepository<CartItem, Long> {
    List<CartItem> findByUserId(Long userId);

    Optional<CartItem> findByUserIdAndProductId(Long userId, Long productId);

    void deleteByUserIdAndProductId(Long userId, Long productId);
}


--------


File: ./product/src/main/java/com/zzimcong/product/domain/repository/CategoryRepository.java
--------
package com.zzimcong.product.domain.repository;

import com.zzimcong.product.domain.entity.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.util.List;

public interface CategoryRepository extends JpaRepository<Category, Long> {
    @Query("SELECT DISTINCT c FROM Category c LEFT JOIN FETCH c.parentCategory")
    List<Category> findAllWithParent();

    List<Category> findByPathStartingWith(String path);
}


--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/Product.java
--------
package com.zzimcong.product.domain.entity;

import com.zzimcong.product.application.dto.ProductRequestDto;
import jakarta.persistence.*;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "products")  // 복수형 사용
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "product_id")
    private Long id;

    @NotBlank
    @Size(max = 255)
    @Column(nullable = false)
    private String name;

    @Min(0)
    @Column(nullable = false)
    private int price;

    @Min(0)
    @Column(nullable = false)
    private int sale;

    @Column(columnDefinition = "TEXT")
    private String content;

    @Size(max = 255)
    private String image;

    @Column(nullable = false)
    private int availableQuantity;

    @Column(nullable = false)
    private int reservedQuantity;

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(nullable = false)
    private boolean deleted = false;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    private Category category;

    public Product(ProductRequestDto productRequestDto, Category category) {
        this.name = productRequestDto.getName();
        this.price = productRequestDto.getPrice();
        this.sale = productRequestDto.getSale();
        this.content = productRequestDto.getContent();
        this.image = productRequestDto.getImage();
        this.availableQuantity = productRequestDto.getAvailableQuantity();
        this.reservedQuantity = productRequestDto.getReservedQuantity();
        this.category = category;
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/Category.java
--------
package com.zzimcong.product.domain.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@Entity
@Table(name = "categories")
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "category_id")
    private Long id;

    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_category_id")
    private Category parentCategory;

    @OneToMany(mappedBy = "parentCategory")
    private List<Category> childCategories = new ArrayList<>();

    private int depth;
    private String path;
}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/BaseEntity.java
--------
package com.zzimcong.product.domain.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@Setter
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
public abstract class BaseEntity {

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/CartItem.java
--------
package com.zzimcong.product.domain.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Min;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "cart_items")  // 복수형 사용
public class CartItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "cart_item_id")
    private Long id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Min(1)
    @Column(nullable = false)
    private int count;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    public CartItem(Long userId, Product product, int count) {
        this.userId = userId;
        this.product = product;
        this.count = count;
    }
}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/InventoryEventType.java
--------
package com.zzimcong.product.domain.entity;

public enum InventoryEventType {
    RESERVED, CONFIRMED, CANCELLED, RESTORED
}

--------


File: ./product/src/main/java/com/zzimcong/product/domain/entity/InventoryEvent.java
--------
package com.zzimcong.product.domain.entity;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class InventoryEvent {
    private Long productId;
    private InventoryEventType eventType;
    private int quantity;
}

--------


